  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.bank;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Investment Account</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.bank.InvestmentAccount#getTransactions <em>Transactions</em>}</li>
 * </ul>
 *
 * @see edu.bank.BankPackage#getInvestmentAccount()
 * @model kind="class"
 * @generated
 */
public class InvestmentAccount extends Account
{
  protected EList<StockTransaction> transactions;

  protected InvestmentAccount()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<StockTransaction> getTransactions()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Purchase a stock, deducting the stock cost and a 10 % commission from the account
   *   balance, and record the transaction.
   * Algorithm:
   *   1. IF quantity ≤ 0 OR price ≤ 0 THEN return false.
   *   2. stockCost ← quantity * price.
   *   3. commission ← stockCost * COMMISSION_RATE (0.10).
   *   4. totalDeduction ← stockCost + commission.
   *   5. IF balance < totalDeduction THEN return false.   // insufficient funds.
   *   6. balance ← balance - totalDeduction.
   *   7. Create new StockTransaction tx:
   *        tx.stock ← stockSymbol
   *        tx.quantity ← quantity
   *        tx.price ← price
   *        tx.commission ← commission
   *        tx.account ← this
   *   8. transactions.add(tx).
   *   9. RETURN true.
   * Input:
   *   stockSymbol : String – ticker symbol of the stock (e.g., "AAPL").
   *   quantity    : int    – number of shares to buy; must be > 0.
   *   price       : double – purchase price per share; must be > 0.
   * Output:
   *   boolean – true if the purchase and recording succeeded, false otherwise.
   * Pre‑condition:
   *   InvestmentAccount.balance is a non‑negative finite double.
   *   transactions list is initialized.
   * Post‑condition:
   *   If true, balance = old_balance – (quantity*price)*(1 + 0.10).
   *   A new StockTransaction reflecting the purchase is appended to transactions.
   * <!-- end-model-doc -->
   * @model stockSymbolRequired="true" quantityRequired="true" priceRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean buyStock(final String stockSymbol, final int quantity, final double price)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Compute the total value of an investment account as the sum of the cash balance
   *   and the market value of all owned stocks (market price = 1.1 × purchase price).
   * Algorithm:
   *   1. total ← balance.
   *   2. FOR each tx in transactions DO
   *        marketPrice ← tx.price * MARKET_MULTIPLIER (1.10)
   *        total ← total + (tx.quantity * marketPrice)
   *   3. RETURN total.
   * Input:
   *   (none)
   * Output:
   *   double – total account value; if there are no transactions, this equals balance.
   * Pre‑condition:
   *   balance ≥ 0; each transaction’s price and quantity are non‑negative.
   * Post‑condition:
   *   No mutation of account state; returns a deterministic numeric value.
   * <!-- end-model-doc -->
   * @model required="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateValue()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // InvestmentAccount
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Account` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Public methods: public boolean deposit(final double amount)
  + Getter methods: public String getId(), public double getBalance(), public Customer getCustomer()
  + Setter methods: public void setId(String newId), public void setBalance(double newBalance), public void setCustomer(Customer newCustomer)
- Class `Customer` contains the following methods.
  + Instance creation: Use `BankFactory.eINSTANCE.createCustomer()`
  + Public methods: public boolean addSavingAccount(final String id, final double interestRate), public boolean addInvestmentAccount(final String id), public boolean removeInvestmentAccount(final String id), public boolean removeSavingAccount(final String id), public Account findAccountById(final String id)
  + Getter methods: public String getName(), public String getAddress(), public EList<Account> getAccounts()
  + Setter methods: public void setName(String newName), public void setAddress(String newAddress)
- Class `StockTransaction` contains the following methods.
  + Instance creation: Use `BankFactory.eINSTANCE.createStockTransaction()`
  + Getter methods: public String getStock(), public int getQuantity(), public double getPrice(), public double getCommission(), public InvestmentAccount getAccount()
  + Setter methods: public void setStock(String newStock), public void setQuantity(int newQuantity), public void setPrice(double newPrice), public void setCommission(double newCommission), public void setAccount(InvestmentAccount newAccount)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.bank;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

import edu.bank.BankFactory;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Investment Account</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.bank.InvestmentAccount#getTransactions <em>Transactions</em>}</li>
 * </ul>
 *
 * @see edu.bank.BankPackage#getInvestmentAccount()
 * @model kind="class"
 * @generated
 */
public class InvestmentAccount extends Account
{
  protected EList<StockTransaction> transactions;

  protected InvestmentAccount()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<StockTransaction> getTransactions()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Purchase a stock, deducting the stock cost and a 10 % commission from the account
   *   balance, and record the transaction.
   * Algorithm:
   *   1. IF quantity ≤ 0 OR price ≤ 0 THEN return false.
   *   2. stockCost ← quantity * price.
   *   3. commission ← stockCost * COMMISSION_RATE (0.10).
   *   4. totalDeduction ← stockCost + commission.
   *   5. IF balance < totalDeduction THEN return false.   // insufficient funds.
   *   6. balance ← balance - totalDeduction.
   *   7. Create new StockTransaction tx:
   *        tx.stock ← stockSymbol
   *        tx.quantity ← quantity
   *        tx.price ← price
   *        tx.commission ← commission
   *        tx.account ← this
   *   8. transactions.add(tx).
   *   9. RETURN true.
   * Input:
   *   stockSymbol : String – ticker symbol of the stock (e.g., "AAPL").
   *   quantity    : int    – number of shares to buy; must be > 0.
   *   price       : double – purchase price per share; must be > 0.
   * Output:
   *   boolean – true if the purchase and recording succeeded, false otherwise.
   * Pre‑condition:
   *   InvestmentAccount.balance is a non‑negative finite double.
   *   transactions list is initialized.
   * Post‑condition:
   *   If true, balance = old_balance – (quantity*price)*(1 + 0.10).
   *   A new StockTransaction reflecting the purchase is appended to transactions.
   * <!-- end-model-doc -->
   * @model stockSymbolRequired="true" quantityRequired="true" priceRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean buyStock(final String stockSymbol, final int quantity, final double price)
  {
    // Preconditions check
    if (quantity <= 0 || price <= 0) {
      return false;
    }

    final double stockCost = quantity * price;
    final double commission = stockCost * 0.10; // COMMISSION_RATE = 0.10
    final double totalDeduction = stockCost + commission;

    // Check sufficient balance
    if (getBalance() < totalDeduction) {
      return false;
    }

    // Deduct from balance
    setBalance(getBalance() - totalDeduction);

    // Create and populate a new StockTransaction
    StockTransaction tx = BankFactory.eINSTANCE.createStockTransaction();
    tx.setStock(stockSymbol);
    tx.setQuantity(quantity);
    tx.setPrice(price);
    tx.setCommission(commission);
    tx.setAccount(this);

    // Record the transaction
    if (transactions == null) {
      // Defensive: ensure the list is initialized (should be per pre‑condition)
      // The actual initialization logic is handled elsewhere; here we just guard against NPE.
      // If still null, we cannot record the transaction, so we return false.
      return false;
    }
    transactions.add(tx);

    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Compute the total value of an investment account as the sum of the cash balance
   *   and the market value of all owned stocks (market price = 1.1 × purchase price).
   * Algorithm:
   *   1. total ← balance.
   *   2. FOR each tx in transactions DO
   *        marketPrice ← tx.price * MARKET_MULTIPLIER (1.10)
   *        total ← total + (tx.quantity * marketPrice)
   *   3. RETURN total.
   * Input:
   *   (none)
   * Output:
   *   double – total account value; if there are no transactions, this equals balance.
   * Pre‑condition:
   *   balance ≥ 0; each transaction’s price and quantity are non‑negative.
   * Post‑condition:
   *   No mutation of account state; returns a deterministic numeric value.
   * <!-- end-model-doc -->
   * @model required="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateValue()
  {
    double total = getBalance();

    if (transactions != null) {
      for (StockTransaction tx : transactions) {
        double marketPrice = tx.getPrice() * 1.10; // MARKET_MULTIPLIER = 1.10
        total += tx.getQuantity() * marketPrice;
      }
    }

    return total;
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // InvestmentAccount
319608 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../BankSystem/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../BankSystem/src-gen/edu/bank/
319770 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
319770 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - ----------
1. WARNING in D:\EclipseWorkspace\BankSystem\src-gen\edu\bank\Customer.java (at line 22)
	import java.util.Iterator;
	       ^^^^^^^^^^^^^^^^^^
The import java.util.Iterator is never used
----------
----------
2. WARNING in D:\EclipseWorkspace\BankSystem\src-gen\edu\bank\InvestmentAccount.java (at line 17)
	import edu.bank.BankFactory;
	       ^^^^^^^^^^^^^^^^^^^^
The import edu.bank.BankFactory is never used
----------
2 problems (2 warnings)

319770 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
319770 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
319772 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample4.mwe2 启动完成
正在拷贝 src-gen/edu/bank 到 gpt-oss-120b/bank4...
拷贝完成！

======================================
正在启动 sample5.mwe2...
======================================
320129 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
320280 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project BankSystem at 'file:/D:/EclipseWorkspace/BankSystem/'
320285 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
320297 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@16433d56
320297 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
320299 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
320301 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
System description :A bank system contains data on customers (identified by name and address) and their accounts.
 Each account has a unique id, a balance and there are 2 type of accounts: one for savings which offers an interest rate. 
Each savings account is specified individually when it is opened. 
The other for investments, used to buy stocks.
 Stocks are bought at a certain quantity for a certain price (ticker) and the bank applies commission on stock orders. 
Customers can buy the same stock multiple times. The commission is 10% of the cost of each stock transaction. Customers need to pay commission when buying stocks.
Funtion requirement：
+ Manage accounts. Customers can add/remove accounts by providing account id. Each account has a unique account ID. If the account to be deleted has no a balance, or stock transactions, then remove the account. Return true if the operation is successful, false otherwise.

+ Deposit operation. Customers can deposit money into the savings and investments account and update the account balance. Check that the amount must be positive and cannot exceed the maximum single - deposit limit of $1000000. Return true if the operation is successful, false otherwise.

+ Calculate the daily interest of the savings account and update the daily interest to the balance at 23:59:59 on the same day. Daily interest = balance * interest rate / 360.

+ Buy stocks and update the investment account balance. The system save the transaction records. There is no need to combine multiple purchases of the same stock. Before buying stocks, it is necessary to ensure that the current balance is sufficient to cover the stock cost and the bank's commission. Stock cost = number of stocks * price. Return true if save the transaction records successfully, false otherwise. 

+ Calculate the value of the investment account, including the account balance and the total value of stocks. The value of each stock is the number of stocks multiplied by the current stock market price (1.1 times its purchase price). Return the account balance if there is no stock transaction in the investment account.
```

# Class Diagram
```plantuml
@startuml

title bank Model

abstract class Account {
    balance : double
    id : String
    customer : Customer
    deposit(amount : double) : boolean
}
class Customer {
    address : String
    name : String
    accounts : List<Account>
    addInvestmentAccount(id : String) : boolean
    addSavingAccount(id : String, interestRate : double) : boolean
    findAccountById(id : String) : Account
    removeInvestmentAccount(id : String) : boolean
    removeSavingAccount(id : String) : boolean
}
class InvestmentAccount {
    transactions : List<StockTransaction>
    buyStock(stockSymbol : String, quantity : int, price : double) : boolean
    calculateValue() : double
}
class SavingAccount {
    interestRate : double
    calculateDailyInterest() : double
}
class StockTransaction {
    commission : double
    price : double
    quantity : int
    stock : String
    account : InvestmentAccount
}

Account --> Customer : customer  'opposite: accounts
Customer *-- "*" Account : accounts  'opposite: customer
InvestmentAccount --|> Account
InvestmentAccount *-- "*" StockTransaction : transactions  'opposite: account
SavingAccount --|> Account
StockTransaction --> InvestmentAccount : account  'opposite: transactions
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

347811 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@3128be29 (name: findAccountById) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Retrieves the account (saving or investment) belonging to the customer that
  matches the supplied account id.
Algorithm:
  1. FOR each acct IN accounts DO
       IF acct.id equals id THEN RETURN acct.
     END FOR
  2. RETURN null.
Input:
  - id : String   // account identifier to search for.
Output:
  - Account
      The matching Account object, or null if none exists.
Pre‑condition:
  - Customer instance is initialized with accounts list.
Post‑condition:
  - No modification of any data., org.eclipse.emf.ecore.impl.EOperationImpl@1c68601b (name: addSavingAccount) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary:
  Creates a new SavingAccount with the supplied unique id and interest rate,
  then adds it to the customer's collection.
Algorithm:
  1. IF id is null/empty OR interestRate ≤ 0 THEN RETURN false.
  2. IF findAccountById(id) != null THEN RETURN false   // id must be unique.
  3. Create new SavingAccount savAcc.
  4. savAcc.id ← id; savAcc.interestRate ← interestRate;
     savAcc.customer ← this; savAcc.balance ← 0.
  5. accounts.add(savAcc).
  6. RETURN true.
Input:
  - id           : String   // unique account identifier.
  - interestRate : double   // annual interest rate (e.g., 0.03 for 3%); >0.
Output:
  - boolean
      true  – account created and stored.
      false – invalid parameters or duplicate id; no change.
Pre‑condition:
  - Customer exists.
Post‑condition:
  - On success, accounts contains a new SavingAccount with the given id and rate.
  - On failure, accounts unchanged., org.eclipse.emf.ecore.impl.EOperationImpl@4da454a7 (name: removeSavingAccount) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Removes a SavingAccount with the given id if its balance is zero.
Algorithm:
  1. acct ← findAccountById(id).
  2. IF acct == null OR acct NOT instanceof SavingAccount THEN RETURN false.
  3. IF acct.balance ≠ 0 THEN RETURN false.
  4. accounts.remove(acct).
  5. RETURN true.
Input:
  - id : String   // identifier of the saving account to delete.
Output:
  - boolean
      true  – account satisfied conditions and was removed.
      false – account not found, not a saving account, or balance non‑zero.
Pre‑condition:
  - Customer and its accounts list are initialized.
Post‑condition:
  - If true, the specified SavingAccount is removed from accounts.
  - If false, accounts unchanged., org.eclipse.emf.ecore.impl.EOperationImpl@12139db0 (name: buyStock) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Records a stock purchase transaction, deducts the total cost (stock price * quantity
  plus a 10 % commission) from the investment account balance, and stores the transaction.
Algorithm:
  1. IF stockSymbol is null/empty OR quantity ≤ 0 OR price ≤ 0 THEN RETURN false.
  2. stockCost ← quantity * price.
  3. commission ← 0.10 * stockCost.
  4. totalDeduction ← stockCost + commission.
  5. IF balance < totalDeduction THEN RETURN false.   // insufficient funds.
  6. balance ← balance - totalDeduction.
  7. Create new StockTransaction txn:
       txn.stock ← stockSymbol;
       txn.quantity ← quantity;
       txn.price ← price;
       txn.commission ← commission;
       txn.account ← this;
  8. transactions.add(txn).
  9. RETURN true.
Input:
  - stockSymbol : String   // ticker symbol of the stock (e.g., "AAPL").
  - quantity    : int      // number of shares to purchase; >0.
  - price       : double   // price per share at purchase time; >0.
Output:
  - boolean
      true  – transaction recorded and balance updated.
      false – invalid parameters or insufficient balance; no change.
Pre‑condition:
  - InvestmentAccount exists with a non‑negative balance.
Post‑condition:
  - If true, balance = old_balance - (quantity*price + commission) and a
    StockTransaction reflecting the purchase is appended to transactions.
  - If false, balance and transactions remain unchanged., org.eclipse.emf.ecore.impl.EOperationImpl@66beb02d (name: calculateValue) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary:
  Computes the total current value of the investment account, defined as the
  cash balance plus the market value of all owned stocks. Market value of each
  stock = quantity × (purchase price × 1.1) (i.e., a 10 % price increase over
  purchase price).
Algorithm:
  1. total ← balance.
  2. FOR each txn IN transactions DO
       marketPrice ← txn.price * 1.1;          // 10 % appreciation.
       total ← total + (txn.quantity * marketPrice);
     END FOR
  3. RETURN total.
Input:
  - (none)
Output:
  - double
      The computed total value; if transactions list is empty, result equals balance.
Pre‑condition:
  - InvestmentAccount instance is initialized; balance ≥ 0.
Post‑condition:
  - No state mutation; method is pure (read‑only)., org.eclipse.emf.ecore.impl.EOperationImpl@6a2cd5ea (name: addInvestmentAccount) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Creates a new InvestmentAccount with the supplied unique id and associates it
  with the customer.
Algorithm:
  1. IF id is null or empty THEN RETURN false.
  2. IF findAccountById(id) != null THEN RETURN false   // id must be unique.
  3. Create new InvestmentAccount invAcc.
  4. invAcc.id ← id; invAcc.customer ← this; invAcc.balance ← 0.
  5. accounts.add(invAcc).
  6. RETURN true.
Input:
  - id : String
      Unique identifier for the new investment account.
Output:
  - boolean
      true  – account created and added to the customer.
      false – id invalid or already used; no account added.
Pre‑condition:
  - Customer instance exists with a mutable accounts list.
Post‑condition:
  - On success, accounts contains a new InvestmentAccount with the given id.
  - On failure, accounts unchanged., org.eclipse.emf.ecore.impl.EOperationImpl@412b4aed (name: removeInvestmentAccount) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Removes an InvestmentAccount with the given id if its balance is zero and it
  has no stock transactions recorded.
Algorithm:
  1. acct ← findAccountById(id).
  2. IF acct == null OR acct NOT instanceof InvestmentAccount THEN RETURN false.
  3. IF acct.balance ≠ 0 THEN RETURN false.
  4. IF acct.transactions is not empty THEN RETURN false.
  5. accounts.remove(acct).
  6. RETURN true.
Input:
  - id : String   // identifier of the investment account to delete.
Output:
  - boolean
      true  – account satisfied conditions and was removed.
      false – account not found, not an investment account, non‑zero balance,
               or has transaction history; no removal.
Pre‑condition:
  - Customer and its accounts list are initialized.
Post‑condition:
  - If true, the specified InvestmentAccount no longer exists in accounts.
  - If false, accounts unchanged., org.eclipse.emf.ecore.impl.EOperationImpl@10fc01e0 (name: deposit) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Adds a positive amount of money to the account balance, respecting the maximum
  single‑deposit limit of $1,000,000.
Algorithm:
  1. IF amount ≤ 0 THEN RETURN false.
  2. IF amount > 1_000_000 THEN RETURN false.
  3. balance ← balance + amount.
  4. RETURN true.
Input:
  - amount : double
      The monetary amount to be deposited.
      Must be greater than 0 and not exceed 1,000,000.
Output:
  - boolean
      true  – deposit succeeded and balance updated.
      false – amount invalid (≤0 or >1,000,000); balance unchanged.
Pre‑condition:
  - The Account instance exists.
Post‑condition:
  - If true is returned, balance = old_balance + amount.
  - If false is returned, balance remains unchanged., org.eclipse.emf.ecore.impl.EOperationImpl@7d59e235 (name: calculateDailyInterest) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary:
  Calculates one day's interest for the saving account using the formula:
      dailyInterest = balance × interestRate / 360
  and adds the interest to the account balance.
Algorithm:
  1. IF balance ≤ 0 THEN RETURN 0.0.   // no interest on non‑positive balance.
  2. dailyInterest ← balance * interestRate / 360.   // interestRate expressed as decimal.
  3. balance ← balance + dailyInterest.
  4. RETURN dailyInterest.
Input:
  - (none)
Output:
  - double
      The amount of interest added to the balance for the day.
Pre‑condition:
  - SavingAccount exists; interestRate > 0.
Post‑condition:
  - balance = old_balance + dailyInterest.
  - Returned value equals the increment applied.}
347814 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
347879 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../BankSystem/src-gen/edu/bank
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.bank;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Customer</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.bank.Customer#getName <em>Name</em>}</li>
 *   <li>{@link edu.bank.Customer#getAddress <em>Address</em>}</li>
 *   <li>{@link edu.bank.Customer#getAccounts <em>Accounts</em>}</li>
 * </ul>
 *
 * @see edu.bank.BankPackage#getCustomer()
 * @model kind="class"
 * @generated
 */
public class Customer extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected static final String ADDRESS_EDEFAULT = null;

  protected String address = ADDRESS_EDEFAULT;

  protected EList<Account> accounts;

  protected Customer()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public String getAddress()
  { ... /* omitted */ }

  public void setAddress(String newAddress)
  { ... /* omitted */ }

  public EList<Account> getAccounts()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Creates a new SavingAccount with the supplied unique id and interest rate,
   *   then adds it to the customer's collection.
   * Algorithm:
   *   1. IF id is null/empty OR interestRate ≤ 0 THEN RETURN false.
   *   2. IF findAccountById(id) != null THEN RETURN false   // id must be unique.
   *   3. Create new SavingAccount savAcc.
   *   4. savAcc.id ← id; savAcc.interestRate ← interestRate;
   *      savAcc.customer ← this; savAcc.balance ← 0.
   *   5. accounts.add(savAcc).
   *   6. RETURN true.
   * Input:
   *   - id           : String   // unique account identifier.
   *   - interestRate : double   // annual interest rate (e.g., 0.03 for 3%); >0.
   * Output:
   *   - boolean
   *       true  – account created and stored.
   *       false – invalid parameters or duplicate id; no change.
   * Pre‑condition:
   *   - Customer exists.
   * Post‑condition:
   *   - On success, accounts contains a new SavingAccount with the given id and rate.
   *   - On failure, accounts unchanged.
   * <!-- end-model-doc -->
   * @model required="true" idRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean addSavingAccount(final String id, final double interestRate)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Creates a new InvestmentAccount with the supplied unique id and associates it
   *   with the customer.
   * Algorithm:
   *   1. IF id is null or empty THEN RETURN false.
   *   2. IF findAccountById(id) != null THEN RETURN false   // id must be unique.
   *   3. Create new InvestmentAccount invAcc.
   *   4. invAcc.id ← id; invAcc.customer ← this; invAcc.balance ← 0.
   *   5. accounts.add(invAcc).
   *   6. RETURN true.
   * Input:
   *   - id : String
   *       Unique identifier for the new investment account.
   * Output:
   *   - boolean
   *       true  – account created and added to the customer.
   *       false – id invalid or already used; no account added.
   * Pre‑condition:
   *   - Customer instance exists with a mutable accounts list.
   * Post‑condition:
   *   - On success, accounts contains a new InvestmentAccount with the given id.
   *   - On failure, accounts unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean addInvestmentAccount(final String id)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Removes an InvestmentAccount with the given id if its balance is zero and it
   *   has no stock transactions recorded.
   * Algorithm:
   *   1. acct ← findAccountById(id).
   *   2. IF acct == null OR acct NOT instanceof InvestmentAccount THEN RETURN false.
   *   3. IF acct.balance ≠ 0 THEN RETURN false.
   *   4. IF acct.transactions is not empty THEN RETURN false.
   *   5. accounts.remove(acct).
   *   6. RETURN true.
   * Input:
   *   - id : String   // identifier of the investment account to delete.
   * Output:
   *   - boolean
   *       true  – account satisfied conditions and was removed.
   *       false – account not found, not an investment account, non‑zero balance,
   *                or has transaction history; no removal.
   * Pre‑condition:
   *   - Customer and its accounts list are initialized.
   * Post‑condition:
   *   - If true, the specified InvestmentAccount no longer exists in accounts.
   *   - If false, accounts unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean removeInvestmentAccount(final String id)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Removes a SavingAccount with the given id if its balance is zero.
   * Algorithm:
   *   1. acct ← findAccountById(id).
   *   2. IF acct == null OR acct NOT instanceof SavingAccount THEN RETURN false.
   *   3. IF acct.balance ≠ 0 THEN RETURN false.
   *   4. accounts.remove(acct).
   *   5. RETURN true.
   * Input:
   *   - id : String   // identifier of the saving account to delete.
   * Output:
   *   - boolean
   *       true  – account satisfied conditions and was removed.
   *       false – account not found, not a saving account, or balance non‑zero.
   * Pre‑condition:
   *   - Customer and its accounts list are initialized.
   * Post‑condition:
   *   - If true, the specified SavingAccount is removed from accounts.
   *   - If false, accounts unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean removeSavingAccount(final String id)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves the account (saving or investment) belonging to the customer that
   *   matches the supplied account id.
   * Algorithm:
   *   1. FOR each acct IN accounts DO
   *        IF acct.id equals id THEN RETURN acct.
   *      END FOR
   *   2. RETURN null.
   * Input:
   *   - id : String   // account identifier to search for.
   * Output:
   *   - Account
   *       The matching Account object, or null if none exists.
   * Pre‑condition:
   *   - Customer instance is initialized with accounts list.
   * Post‑condition:
   *   - No modification of any data.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public Account findAccountById(final String id)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Customer
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Account` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Public methods: public boolean deposit(final double amount)
  + Getter methods: public String getId(), public double getBalance(), public Customer getCustomer()
  + Setter methods: public void setId(String newId), public void setBalance(double newBalance), public void setCustomer(Customer newCustomer)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.bank;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Customer</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.bank.Customer#getName <em>Name</em>}</li>
 *   <li>{@link edu.bank.Customer#getAddress <em>Address</em>}</li>
 *   <li>{@link edu.bank.Customer#getAccounts <em>Accounts</em>}</li>
 * </ul>
 *
 * @see edu.bank.BankPackage#getCustomer()
 * @model kind="class"
 * @generated
 */
public class Customer extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected static final String ADDRESS_EDEFAULT = null;

  protected String address = ADDRESS_EDEFAULT;

  protected EList<Account> accounts;

  protected Customer()
  { /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { /* omitted */ }

  public String getName()
  { /* omitted */ }

  public void setName(String newName)
  { /* omitted */ }

  public String getAddress()
  { /* omitted */ }

  public void setAddress(String newAddress)
  { /* omitted */ }

  public EList<Account> getAccounts()
  { /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Creates a new SavingAccount with the supplied unique id and interest rate,
   *   then adds it to the customer's collection.
   * Algorithm:
   *   1. IF id is null/empty OR interestRate ≤ 0 THEN RETURN false.
   *   2. IF findAccountById(id) != null THEN RETURN false   // id must be unique.
   *   3. Create new SavingAccount savAcc.
   *   4. savAcc.id ← id; savAcc.interestRate ← interestRate;
   *      savAcc.customer ← this; savAcc.balance ← 0.
   *   5. accounts.add(savAcc).
   *   6. RETURN true.
   * Input:
   *   - id           : String   // unique account identifier.
   *   - interestRate : double   // annual interest rate (e.g., 0.03 for 3%); >0.
   * Output:
   *   - boolean
   *       true  – account created and stored.
   *       false – invalid parameters or duplicate id; no change.
   * Pre‑condition:
   *   - Customer exists.
   * Post‑condition:
   *   - On success, accounts contains a new SavingAccount with the given id and rate.
   *   - On failure, accounts unchanged.
   * <!-- end-model-doc -->
   * @model required="true" idRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean addSavingAccount(final String id, final double interestRate)
  {
    // 1. Validate parameters
    if (id == null || id.isEmpty() || interestRate <= 0) {
      return false;
    }
    // 2. Ensure id uniqueness
    if (findAccountById(id) != null) {
      return false;
    }
    // 3. Create new SavingAccount and set its properties
    SavingAccount savAcc = new SavingAccount();
    savAcc.setId(id);
    savAcc.setInterestRate(interestRate);
    savAcc.setCustomer(this);
    savAcc.setBalance(0.0);
    // 5. Add to accounts collection
    getAccounts().add(savAcc);
    // 6. Success
    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Creates a new InvestmentAccount with the supplied unique id and associates it
   *   with the customer.
   * Algorithm:
   *   1. IF id is null or empty THEN RETURN false.
   *   2. IF findAccountById(id) != null THEN RETURN false   // id must be unique.
   *   3. Create new InvestmentAccount invAcc.
   *   4. invAcc.id ← id; invAcc.customer ← this; invAcc.balance ← 0.
   *   5. accounts.add(invAcc).
   *   6. RETURN true.
   * Input:
   *   - id : String
   *       Unique identifier for the new investment account.
   * Output:
   *   - boolean
   *       true  – account created and added to the customer.
   *       false – id invalid or already used; no account added.
   * Pre‑condition:
   *   - Customer instance exists with a mutable accounts list.
   * Post‑condition:
   *   - On success, accounts contains a new InvestmentAccount with the given id.
   *   - On failure, accounts unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean addInvestmentAccount(final String id)
  {
    // 1. Validate id
    if (id == null || id.isEmpty()) {
      return false;
    }
    // 2. Ensure uniqueness
    if (findAccountById(id) != null) {
      return false;
    }
    // 3. Create new InvestmentAccount and set properties
    InvestmentAccount invAcc = new InvestmentAccount();
    invAcc.setId(id);
    invAcc.setCustomer(this);
    invAcc.setBalance(0.0);
    // 5. Add to accounts collection
    getAccounts().add(invAcc);
    // 6. Success
    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Removes an InvestmentAccount with the given id if its balance is zero and it
   *   has no stock transactions recorded.
   * Algorithm:
   *   1. acct ← findAccountById(id).
   *   2. IF acct == null OR acct NOT instanceof InvestmentAccount THEN RETURN false.
   *   3. IF acct.balance ≠ 0 THEN RETURN false.
   *   4. IF acct.transactions is not empty THEN RETURN false.
   *   5. accounts.remove(acct).
   *   6. RETURN true.
   * Input:
   *   - id : String   // identifier of the investment account to delete.
   * Output:
   *   - boolean
   *       true  – account satisfied conditions and was removed.
   *       false – account not found, not an investment account, non‑zero balance,
   *                or has transaction history; no removal.
   * Pre‑condition:
   *   - Customer and its accounts list are initialized.
   * Post‑condition:
   *   - If true, the specified InvestmentAccount no longer exists in accounts.
   *   - If false, accounts unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean removeInvestmentAccount(final String id)
  {
    // 1. Locate the account
    Account acct = findAccountById(id);
    // 2. Validate type
    if (acct == null || !(acct instanceof InvestmentAccount)) {
      return false;
    }
    // 3. Check balance
    if (acct.getBalance() != 0.0) {
      return false;
    }
    // 4. Check transaction history
    InvestmentAccount invAcct = (InvestmentAccount) acct;
    Collection<?> transactions = invAcct.getTransactions();
    if (transactions != null && !transactions.isEmpty()) {
      return false;
    }
    // 5. Remove from collection
    getAccounts().remove(acct);
    // 6. Success
    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Removes a SavingAccount with the given id if its balance is zero.
   * Algorithm:
   *   1. acct ← findAccountById(id).
   *   2. IF acct == null OR acct NOT instanceof SavingAccount THEN RETURN false.
   *   3. IF acct.balance ≠ 0 THEN RETURN false.
   *   4. accounts.remove(acct).
   *   5. RETURN true.
   * Input:
   *   - id : String   // identifier of the saving account to delete.
   * Output:
   *   - boolean
   *       true  – account satisfied conditions and was removed.
   *       false – account not found, not a saving account, or balance non‑zero.
   * Pre‑condition:
   *   - Customer and its accounts list are initialized.
   * Post‑condition:
   *   - If true, the specified SavingAccount is removed from accounts.
   *   - If false, accounts unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean removeSavingAccount(final String id)
  {
    // 1. Locate the account
    Account acct = findAccountById(id);
    // 2. Validate type
    if (acct == null || !(acct instanceof SavingAccount)) {
      return false;
    }
    // 3. Check balance
    if (acct.getBalance() != 0.0) {
      return false;
    }
    // 4. Remove from collection
    getAccounts().remove(acct);
    // 5. Success
    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves the account (saving or investment) belonging to the customer that
   *   matches the supplied account id.
   * Algorithm:
   *   1. FOR each acct IN accounts DO
   *        IF acct.id equals id THEN RETURN acct.
   *      END FOR
   *   2. RETURN null.
   * Input:
   *   - id : String   // account identifier to search for.
   * Output:
   *   - Account
   *       The matching Account object, or null if none exists.
   * Pre‑condition:
   *   - Customer instance is initialized with accounts list.
   * Post‑condition:
   *   - No modification of any data.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Account findAccountById(final String id)
  {
    if (id == null) {
      return null;
    }
    for (Account acct : getAccounts()) {
      if (id.equals(acct.getId())) {
        return acct;
      }
    }
    return null;
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { /* omitted */ }

  @Override
  public String toString()
  { /* omitted */ }

} // Customer
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.bank;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Account</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.bank.Account#getId <em>Id</em>}</li>
 *   <li>{@link edu.bank.Account#getBalance <em>Balance</em>}</li>
 *   <li>{@link edu.bank.Account#getCustomer <em>Customer</em>}</li>
 * </ul>
 *
 * @see edu.bank.BankPackage#getAccount()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Account extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String ID_EDEFAULT = null;

  protected String id = ID_EDEFAULT;

  protected static final double BALANCE_EDEFAULT = 0.0;

  protected double balance = BALANCE_EDEFAULT;

  protected Account()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getId()
  { ... /* omitted */ }

  public void setId(String newId)
  { ... /* omitted */ }

  public double getBalance()
  { ... /* omitted */ }

  public void setBalance(double newBalance)
  { ... /* omitted */ }

  public Customer getCustomer()
  { ... /* omitted */ }

  public NotificationChain basicSetCustomer(Customer newCustomer, NotificationChain msgs)
  { ... /* omitted */ }

  public void setCustomer(Customer newCustomer)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Adds a positive amount of money to the account balance, respecting the maximum
   *   single‑deposit limit of $1,000,000.
   * Algorithm:
   *   1. IF amount ≤ 0 THEN RETURN false.
   *   2. IF amount > 1_000_000 THEN RETURN false.
   *   3. balance ← balance + amount.
   *   4. RETURN true.
   * Input:
   *   - amount : double
   *       The monetary amount to be deposited.
   *       Must be greater than 0 and not exceed 1,000,000.
   * Output:
   *   - boolean
   *       true  – deposit succeeded and balance updated.
   *       false – amount invalid (≤0 or >1,000,000); balance unchanged.
   * Pre‑condition:
   *   - The Account instance exists.
   * Post‑condition:
   *   - If true is returned, balance = old_balance + amount.
   *   - If false is returned, balance remains unchanged.
   * <!-- end-model-doc -->
   * @model amountRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean deposit(final double amount)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Account
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Customer` contains the following methods.
  + Instance creation: Use `BankFactory.eINSTANCE.createCustomer()`
  + Public methods: public boolean addSavingAccount(final String id, final double interestRate), public boolean addInvestmentAccount(final String id), public boolean removeInvestmentAccount(final String id), public boolean removeSavingAccount(final String id), public Account findAccountById(final String id)
  + Getter methods: public String getName(), public String getAddress(), public EList<Account> getAccounts()
  + Setter methods: public void setName(String newName), public void setAddress(String newAddress)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.bank;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Account</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.bank.Account#getId <em>Id</em>}</li>
 *   <li>{@link edu.bank.Account#getBalance <em>Balance</em>}</li>
 *   <li>{@link edu.bank.Account#getCustomer <em>Customer</em>}</li>
 * </ul>
 *
 * @see edu.bank.BankPackage#getAccount()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Account extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String ID_EDEFAULT = null;

  protected String id = ID_EDEFAULT;

  protected static final double BALANCE_EDEFAULT = 0.0;

  protected double balance = BALANCE_EDEFAULT;

  protected Account()
  { /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { /* omitted */ }

  public String getId()
  { /* omitted */ }

  public void setId(String newId)
  { /* omitted */ }

  public double getBalance()
  { /* omitted */ }

  public void setBalance(double newBalance)
  { /* omitted */ }

  public Customer getCustomer()
  { /* omitted */ }

  public NotificationChain basicSetCustomer(Customer newCustomer, NotificationChain msgs)
  { /* omitted */ }

  public void setCustomer(Customer newCustomer)
  { /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Adds a positive amount of money to the account balance, respecting the maximum
   *   single‑deposit limit of $1,000,000.
   * Algorithm:
   *   1. IF amount ≤ 0 THEN RETURN false.
   *   2. IF amount > 1_000_000 THEN RETURN false.
   *   3. balance ← balance + amount.
   *   4. RETURN true.
   * Input:
   *   - amount : double
   *       The monetary amount to be deposited.
   *       Must be greater than 0 and not exceed 1,000,000.
   * Output:
   *   - boolean
   *       true  – deposit succeeded and balance updated.
   *       false – amount invalid (≤0 or >1,000,000); balance unchanged.
   * Pre‑condition:
   *   - The Account instance exists.
   * Post‑condition:
   *   - If true is returned, balance = old_balance + amount.
   *   - If false is returned, balance remains unchanged.
   * <!-- end-model-doc -->
   * @model amountRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean deposit(final double amount)
  {
    // Validate amount is positive
    if (amount <= 0) {
      return false;
    }
    // Validate amount does not exceed the maximum single‑deposit limit
    if (amount > 1_000_000) {
      return false;
    }
    // Update the balance using the generated setter to keep EMF notifications consistent
    setBalance(this.balance + amount);
    return true;
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { /* omitted */ }

  @Override
  public String toString()
  { /* omitted */ }

} // Account
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.bank;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.impl.ENotificationImpl;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Saving Account</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.bank.SavingAccount#getInterestRate <em>Interest Rate</em>}</li>
 * </ul>
 *
 * @see edu.bank.BankPackage#getSavingAccount()
 * @model kind="class"
 * @generated
 */
public class SavingAccount extends Account
{
  protected static final double INTEREST_RATE_EDEFAULT = 0.0;

  protected double interestRate = INTEREST_RATE_EDEFAULT;

  protected SavingAccount()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public double getInterestRate()
  { ... /* omitted */ }

  public void setInterestRate(double newInterestRate)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Calculates one day's interest for the saving account using the formula:
   *       dailyInterest = balance × interestRate / 360
   *   and adds the interest to the account balance.
   * Algorithm:
   *   1. IF balance ≤ 0 THEN RETURN 0.0.   // no interest on non‑positive balance.
   *   2. dailyInterest ← balance * interestRate / 360.   // interestRate expressed as decimal.
   *   3. balance ← balance + dailyInterest.
   *   4. RETURN dailyInterest.
   * Input:
   *   - (none)
   * Output:
   *   - double
   *       The amount of interest added to the balance for the day.
   * Pre‑condition:
   *   - SavingAccount exists; interestRate > 0.
   * Post‑condition:
   *   - balance = old_balance + dailyInterest.
   *   - Returned value equals the increment applied.
   * <!-- end-model-doc -->
   * @model required="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateDailyInterest()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // SavingAccount
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Account` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Public methods: public boolean deposit(final double amount)
  + Getter methods: public String getId(), public double getBalance(), public Customer getCustomer()
  + Setter methods: public void setId(String newId), public void setBalance(double newBalance), public void setCustomer(Customer newCustomer)
- Class `Customer` contains the following methods.
  + Instance creation: Use `BankFactory.eINSTANCE.createCustomer()`
  + Public methods: public boolean addSavingAccount(final String id, final double interestRate), public boolean addInvestmentAccount(final String id), public boolean removeInvestmentAccount(final String id), public boolean removeSavingAccount(final String id), public Account findAccountById(final String id)
  + Getter methods: public String getName(), public String getAddress(), public EList<Account> getAccounts()
  + Setter methods: public void setName(String newName), public void setAddress(String newAddress)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.bank;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.impl.ENotificationImpl;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Saving Account</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.bank.SavingAccount#getInterestRate <em>Interest Rate</em>}</li>
 * </ul>
 *
 * @see edu.bank.BankPackage#getSavingAccount()
 * @model kind="class"
 * @generated
 */
public class SavingAccount extends Account
{
  protected static final double INTEREST_RATE_EDEFAULT = 0.0;

  protected double interestRate = INTEREST_RATE_EDEFAULT;

  protected SavingAccount()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public double getInterestRate()
  { ... /* omitted */ }

  public void setInterestRate(double newInterestRate)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Calculates one day's interest for the saving account using the formula:
   *       dailyInterest = balance × interestRate / 360
   *   and adds the interest to the account balance.
   * Algorithm:
   *   1. IF balance ≤ 0 THEN RETURN 0.0.   // no interest on non‑positive balance.
   *   2. dailyInterest ← balance * interestRate / 360.   // interestRate expressed as decimal.
   *   3. balance ← balance + dailyInterest.
   *   4. RETURN dailyInterest.
   * Input:
   *   - (none)
   * Output:
   *   - double
   *       The amount of interest added to the balance for the day.
   * Pre‑condition:
   *   - SavingAccount exists; interestRate > 0.
   * Post‑condition:
   *   - balance = old_balance + dailyInterest.
   *   - Returned value equals the increment applied.
   * <!-- end-model-doc -->
   * @model required="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateDailyInterest()
  {
    double balance = getBalance();
    if (balance <= 0) {
      return 0.0;
    }
    double dailyInterest = balance * interestRate / 360.0;
    setBalance(balance + dailyInterest);
    return dailyInterest;
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // SavingAccount
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.bank;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Investment Account</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.bank.InvestmentAccount#getTransactions <em>Transactions</em>}</li>
 * </ul>
 *
 * @see edu.bank.BankPackage#getInvestmentAccount()
 * @model kind="class"
 * @generated
 */
public class InvestmentAccount extends Account
{
  protected EList<StockTransaction> transactions;

  protected InvestmentAccount()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<StockTransaction> getTransactions()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Records a stock purchase transaction, deducts the total cost (stock price * quantity
   *   plus a 10 % commission) from the investment account balance, and stores the transaction.
   * Algorithm:
   *   1. IF stockSymbol is null/empty OR quantity ≤ 0 OR price ≤ 0 THEN RETURN false.
   *   2. stockCost ← quantity * price.
   *   3. commission ← 0.10 * stockCost.
   *   4. totalDeduction ← stockCost + commission.
   *   5. IF balance < totalDeduction THEN RETURN false.   // insufficient funds.
   *   6. balance ← balance - totalDeduction.
   *   7. Create new StockTransaction txn:
   *        txn.stock ← stockSymbol;
   *        txn.quantity ← quantity;
   *        txn.price ← price;
   *        txn.commission ← commission;
   *        txn.account ← this;
   *   8. transactions.add(txn).
   *   9. RETURN true.
   * Input:
   *   - stockSymbol : String   // ticker symbol of the stock (e.g., "AAPL").
   *   - quantity    : int      // number of shares to purchase; >0.
   *   - price       : double   // price per share at purchase time; >0.
   * Output:
   *   - boolean
   *       true  – transaction recorded and balance updated.
   *       false – invalid parameters or insufficient balance; no change.
   * Pre‑condition:
   *   - InvestmentAccount exists with a non‑negative balance.
   * Post‑condition:
   *   - If true, balance = old_balance - (quantity*price + commission) and a
   *     StockTransaction reflecting the purchase is appended to transactions.
   *   - If false, balance and transactions remain unchanged.
   * <!-- end-model-doc -->
   * @model stockSymbolRequired="true" quantityRequired="true" priceRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean buyStock(final String stockSymbol, final int quantity, final double price)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes the total current value of the investment account, defined as the
   *   cash balance plus the market value of all owned stocks. Market value of each
   *   stock = quantity × (purchase price × 1.1) (i.e., a 10 % price increase over
   *   purchase price).
   * Algorithm:
   *   1. total ← balance.
   *   2. FOR each txn IN transactions DO
   *        marketPrice ← txn.price * 1.1;          // 10 % appreciation.
   *        total ← total + (txn.quantity * marketPrice);
   *      END FOR
   *   3. RETURN total.
   * Input:
   *   - (none)
   * Output:
   *   - double
   *       The computed total value; if transactions list is empty, result equals balance.
   * Pre‑condition:
   *   - InvestmentAccount instance is initialized; balance ≥ 0.
   * Post‑condition:
   *   - No state mutation; method is pure (read‑only).
   * <!-- end-model-doc -->
   * @model required="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateValue()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // InvestmentAccount
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Account` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Public methods: public boolean deposit(final double amount)
  + Getter methods: public String getId(), public double getBalance(), public Customer getCustomer()
  + Setter methods: public void setId(String newId), public void setBalance(double newBalance), public void setCustomer(Customer newCustomer)
- Class `Customer` contains the following methods.
  + Instance creation: Use `BankFactory.eINSTANCE.createCustomer()`
  + Public methods: public boolean addSavingAccount(final String id, final double interestRate), public boolean addInvestmentAccount(final String id), public boolean removeInvestmentAccount(final String id), public boolean removeSavingAccount(final String id), public Account findAccountById(final String id)
  + Getter methods: public String getName(), public String getAddress(), public EList<Account> getAccounts()
  + Setter methods: public void setName(String newName), public void setAddress(String newAddress)
- Class `StockTransaction` contains the following methods.
  + Instance creation: Use `BankFactory.eINSTANCE.createStockTransaction()`
  + Getter methods: public String getStock(), public int getQuantity(), public double getPrice(), public double getCommission(), public InvestmentAccount getAccount()
  + Setter methods: public void setStock(String newStock), public void setQuantity(int newQuantity), public void setPrice(double newPrice), public void setCommission(double newCommission), public void setAccount(InvestmentAccount newAccount)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.bank;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Investment Account</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.bank.InvestmentAccount#getTransactions <em>Transactions</em>}</li>
 * </ul>
 *
 * @see edu.bank.BankPackage#getInvestmentAccount()
 * @model kind="class"
 * @generated
 */
public class InvestmentAccount extends Account
{
  protected EList<StockTransaction> transactions;

  protected InvestmentAccount()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<StockTransaction> getTransactions()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Records a stock purchase transaction, deducts the total cost (stock price * quantity
   *   plus a 10 % commission) from the investment account balance, and stores the transaction.
   * Algorithm:
   *   1. IF stockSymbol is null/empty OR quantity ≤ 0 OR price ≤ 0 THEN RETURN false.
   *   2. stockCost ← quantity * price.
   *   3. commission ← 0.10 * stockCost.
   *   4. totalDeduction ← stockCost + commission.
   *   5. IF balance < totalDeduction THEN RETURN false.   // insufficient funds.
   *   6. balance ← balance - totalDeduction.
   *   7. Create new StockTransaction txn:
   *        txn.stock ← stockSymbol;
   *        txn.quantity ← quantity;
   *        txn.price ← price;
   *        txn.commission ← commission;
   *        txn.account ← this;
   *   8. transactions.add(txn).
   *   9. RETURN true.
   * Input:
   *   - stockSymbol : String   // ticker symbol of the stock (e.g., "AAPL").
   *   - quantity    : int      // number of shares to purchase; >0.
   *   - price       : double   // price per share at purchase time; >0.
   * Output:
   *   - boolean
   *       true  – transaction recorded and balance updated.
   *       false – invalid parameters or insufficient balance; no change.
   * Pre‑condition:
   *   - InvestmentAccount exists with a non‑negative balance.
   * Post‑condition:
   *   - If true, balance = old_balance - (quantity*price + commission) and a
   *     StockTransaction reflecting the purchase is appended to transactions.
   *   - If false, balance and transactions remain unchanged.
   * <!-- end-model-doc -->
   * @model stockSymbolRequired="true" quantityRequired="true" priceRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean buyStock(final String stockSymbol, final int quantity, final double price)
  {
    // Validate parameters
    if (stockSymbol == null || stockSymbol.isEmpty() || quantity <= 0 || price <= 0) {
      return false;
    }

    // Compute costs
    double stockCost = quantity * price;
    double commission = 0.10 * stockCost;
    double totalDeduction = stockCost + commission;

    // Check sufficient balance
    if (getBalance() < totalDeduction) {
      return false;
    }

    // Deduct from balance
    setBalance(getBalance() - totalDeduction);

    // Create and populate the transaction
    StockTransaction txn = BankFactory.eINSTANCE.createStockTransaction();
    txn.setStock(stockSymbol);
    txn.setQuantity(quantity);
    txn.setPrice(price);
    txn.setCommission(commission);
    txn.setAccount(this);

    // Store the transaction
    getTransactions().add(txn);

    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes the total current value of the investment account, defined as the
   *   cash balance plus the market value of all owned stocks. Market value of each
   *   stock = quantity × (purchase price × 1.1) (i.e., a 10 % price increase over
   *   purchase price).
   * Algorithm:
   *   1. total ← balance.
   *   2. FOR each txn IN transactions DO
   *        marketPrice ← txn.price * 1.1;          // 10 % appreciation.
   *        total ← total + (txn.quantity * marketPrice);
   *      END FOR
   *   3. RETURN total.
   * Input:
   *   - (none)
   * Output:
   *   - double
   *       The computed total value; if transactions list is empty, result equals balance.
   * Pre‑condition:
   *   - InvestmentAccount instance is initialized; balance ≥ 0.
   * Post‑condition:
   *   - No state mutation; method is pure (read‑only).
   * <!-- end-model-doc -->
   * @model required="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateValue()
  {
    double total = getBalance();

    for (StockTransaction txn : getTransactions()) {
      double marketPrice = txn.getPrice() * 1.1; // 10 % appreciation
      total += txn.getQuantity() * marketPrice;
    }

    return total;
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // InvestmentAccount
403211 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../BankSystem/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../BankSystem/src-gen/edu/bank/
403353 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
403353 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
403353 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
403353 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
403356 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample5.mwe2 启动完成
正在拷贝 src-gen/edu/bank 到 gpt-oss-120b/bank5...
拷贝完成！

======================================
所有任务完成！
======================================

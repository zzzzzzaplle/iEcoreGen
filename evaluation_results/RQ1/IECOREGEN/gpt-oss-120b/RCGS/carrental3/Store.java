/**
 * generated by Enhanced EcoreGen
 */
package edu.carrental;

import java.util.Collection;
import java.util.Date;
import java.util.Map;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;
import java.util.HashMap;
import java.util.Comparator;
import org.eclipse.emf.common.util.BasicEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Store</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.carrental.Store#getCars <em>Cars</em>}</li>
 *   <li>{@link edu.carrental.Store#getRentals <em>Rentals</em>}</li>
 *   <li>{@link edu.carrental.Store#getNotices <em>Notices</em>}</li>
 * </ul>
 *
 * @see edu.carrental.CarrentalPackage#getStore()
 * @model kind="class"
 * @generated
 */
public class Store extends MinimalEObjectImpl.Container implements EObject
{
  /**
   * The cached value of the '{@link #getCars() <em>Cars</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getCars()
   * @generated
   * @ordered
   */
  protected EList<Car> cars;

  /**
   * The cached value of the '{@link #getRentals() <em>Rentals</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getRentals()
   * @generated
   * @ordered
   */
  protected EList<Rental> rentals;

  /**
   * The cached value of the '{@link #getNotices() <em>Notices</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getNotices()
   * @generated
   * @ordered
   */
  protected EList<OverdueNotice> notices;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected Store()
  {
    super();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  protected EClass eStaticClass()
  {
    return CarrentalPackage.Literals.STORE;
  }

  /**
   * Returns the value of the '<em><b>Cars</b></em>' containment reference list.
   * The list contents are of type {@link edu.carrental.Car}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Cars</em>' containment reference list.
   * @see edu.carrental.CarrentalPackage#getStore_Cars()
   * @model containment="true"
   * @generated
   */
  public EList<Car> getCars()
  {
    if (cars == null)
    {
      cars = new EObjectContainmentEList<Car>(Car.class, this, CarrentalPackage.STORE__CARS);
    }
    return cars;
  }

  /**
   * Returns the value of the '<em><b>Rentals</b></em>' containment reference list.
   * The list contents are of type {@link edu.carrental.Rental}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Rentals</em>' containment reference list.
   * @see edu.carrental.CarrentalPackage#getStore_Rentals()
   * @model containment="true"
   * @generated
   */
  public EList<Rental> getRentals()
  {
    if (rentals == null)
    {
      rentals = new EObjectContainmentEList<Rental>(Rental.class, this, CarrentalPackage.STORE__RENTALS);
    }
    return rentals;
  }

  /**
   * Returns the value of the '<em><b>Notices</b></em>' containment reference list.
   * The list contents are of type {@link edu.carrental.OverdueNotice}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Notices</em>' containment reference list.
   * @see edu.carrental.CarrentalPackage#getStore_Notices()
   * @model containment="true"
   * @generated
   */
  public EList<OverdueNotice> getNotices()
  {
    if (notices == null)
    {
      notices = new EObjectContainmentEList<OverdueNotice>(OverdueNotice.class, this, CarrentalPackage.STORE__NOTICES);
    }
    return notices;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns a list of cars that are not currently rented, sorted by their daily rental price in ascending order.
   * Algorithm:
   *   1. Initialise an empty list `availableCars`.
   *   2. FOR each `car` in `this.cars` DO
   *        a. IF there exists no `rental` in `this.rentals` such that
   *              rental.car.plate == car.plate AND rental.backDate == null
   *           THEN add `car` to `availableCars`.
   *   3. Sort `availableCars` by `car.dailyPrice` using a stable ascending comparator.
   *   4. RETURN `availableCars`.
   * Input:
   *   - None.
   * Output:
   *   - List<Car> `availableCars`
   *       * Meaning: all cars that are currently free for rent.
   *       * Format: mutable List ordered by `dailyPrice` (lowest first).
   *       * Value range: may be empty if every car is rented.
   * Pre‑condition:
   *   - `this.cars` and `this.rentals` are non‑null collections (may be empty).
   * Post‑condition:
   *   - Returned list contains only cars that have no active rental (`backDate == null`).
   *   - The list is sorted strictly by `dailyPrice` in ascending order.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Car> identifyAvailableCars()
  {
    // 1. Initialise an empty list `availableCars`.
    EList<Car> availableCars = new BasicEList<>();

    // 2. Iterate over each car in this.cars
    for (Car car : getCars()) {
      boolean hasActiveRental = false;
      // Check rentals for an active one with the same plate
      for (Rental rental : getRentals()) {
        Car rentedCar = rental.getCar();
        if (rentedCar != null
            && rentedCar.getPlate() != null
            && rentedCar.getPlate().equals(car.getPlate())
            && rental.getBackDate() == null) {
          hasActiveRental = true;
          break;
        }
      }
      // a. If no such rental exists, add the car to the result list
      if (!hasActiveRental) {
        availableCars.add(car);
      }
    }

    // 3. Sort the list by dailyPrice (ascending, stable)
    availableCars.sort(Comparator.comparingDouble(Car::getDailyPrice));

    // 4. Return the list
    return availableCars;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes the total revenue generated by all completed rentals stored in the store.
   * Algorithm:
   *   1. Initialise `totalRevenue` ← 0.0.
   *   2. FOR each `rental` in `this.rentals` DO
   *        a. IF rental.backDate != null        // rental is finished
   *           THEN `totalRevenue` ← `totalRevenue` + rental.totalPrice.
   *   3. RETURN `totalRevenue`.
   * Input:
   *   - None.
   * Output:
   *   - double `totalRevenue`
   *       * Meaning: sum of `totalPrice` of all rentals that have been returned.
   *       * Format: floating‑point number rounded to two decimal places (currency style).
   *       * Value range: ≥ 0.0.
   * Pre‑condition:
   *   - `this.rentals` is non‑null.
   * Post‑condition:
   *   - `totalRevenue` equals Σ rental.totalPrice for all rentals where backDate ≠ null.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateTotalRevenue()
  {
    double totalRevenue = 0.0;

    for (Rental rental : getRentals()) {
      if (rental.getBackDate() != null) {
        totalRevenue += rental.getTotalPrice();
      }
    }

    return totalRevenue;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves all customers whose active rentals are overdue as of `currentDate`.
   * Algorithm:
   *   1. Validate that `currentDate` is not null; THROW IllegalArgumentException otherwise.
   *   2. Initialise empty list `overdueCustomers`.
   *   3. FOR each `rental` in `this.rentals` DO
   *        a. IF rental.backDate == null                               // still out
   *           AND rental.dueDate < `currentDate`                       // past due
   *           THEN
   *                i. IF rental.customer NOT already in `overdueCustomers`
   *                   THEN add rental.customer to `overdueCustomers`.
   *   4. RETURN `overdueCustomers`.
   * Input:
   *   - EDate `currentDate`
   *       * Meaning: the date against which overdue status is evaluated.
   *       * Format: ISO‑8601 string "yyyy-MM-dd" (e.g., "2025-11-14").
   *       * Value range: any valid calendar date.
   * Output:
   *   - List<Customer> `overdueCustomers`
   *       * Meaning: distinct customers with at least one active overdue rental.
   *       * Format: mutable list; order of insertion (no specific sorting required).
   *       * Value range: may be empty if no overdue rentals exist.
   * Pre‑condition:
   *   - `this.rentals` is non‑null.
   *   - `currentDate` is a valid, non‑null date.
   * Post‑condition:
   *   - Every customer in the returned list has at least one rental where `backDate == null`
   *     and `dueDate` precedes `currentDate`.
   *   - No duplicate customers appear in the list.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Customer> findCustomersWithOverdueRentals(final Date currentDate)
  {
    if (currentDate == null) {
      throw new IllegalArgumentException("currentDate must not be null");
    }

    EList<Customer> overdueCustomers = new BasicEList<>();

    for (Rental rental : getRentals()) {
      if (rental.getBackDate() == null && rental.getDueDate() != null
          && rental.getDueDate().compareTo(currentDate) < 0) {
        Customer cust = rental.getCustomer();
        if (cust != null && !overdueCustomers.contains(cust)) {
          overdueCustomers.add(cust);
        }
      }
    }

    return overdueCustomers;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Calculates the average daily price of all cars recorded in the store.
   * Algorithm:
   *   1. IF `this.cars` is empty THEN RETURN 0.0.
   *   2. Initialise `sumPrice` ← 0.0.
   *   3. FOR each `car` in `this.cars` DO
   *        a. `sumPrice` ← `sumPrice` + car.dailyPrice.
   *   4. `average` ← `sumPrice` / size(`this.cars`).
   *   5. RETURN `average`.
   * Input:
   *   - None.
   * Output:
   *   - double `average`
   *       * Meaning: arithmetic mean of daily prices of all cars.
   *       * Format: floating‑point number (two decimal places).
   *       * Value range: 0.0 ≤ `average`.
   * Pre‑condition:
   *   - `this.cars` is non‑null.
   * Post‑condition:
   *   - If the store has at least one car, `average` = Σ car.dailyPrice / numberOfCars.
   *   - If the store has no cars, `average` = 0.0.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double determineAverageDailyPrice()
  {
    if (getCars().isEmpty()) {
      return 0.0;
    }

    double sumPrice = 0.0;
    for (Car car : getCars()) {
      sumPrice += car.getDailyPrice();
    }

    return sumPrice / getCars().size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Produces a mapping from each customer to the number of cars they have rented (including both
   *   active and completed rentals).
   * Algorithm:
   *   1. Initialise empty map `countMap` : Customer → Integer.
   *   2. FOR each `rental` in `this.rentals` DO
   *        a. Let `cust` ← rental.customer.
   *        b. IF `cust` is already a key in `countMap`
   *              THEN `countMap[cust]` ← `countMap[cust]` + 1
   *              ELSE `countMap[cust]` ← 1.
   *   3. Convert `countMap` into a List<EMap> where each element contains:
   *        - key : Customer
   *        - value : Integer (rental count)
   *   4. RETURN the list.
   * Input:
   *   - None.
   * Output:
   *   - List<EMap> `customerRentalCounts`
   *       * Meaning: each entry pairs a Customer object with the integer count of rentals they have made.
   *       * Format: List where each element implements map‑like access (`entry.key`, `entry.value`).
   *       * Value range: may be empty if no rentals have been recorded.
   * Pre‑condition:
   *   - `this.rentals` is non‑null.
   * Post‑condition:
   *   - For every Customer `c` that appears in any Rental, there exists exactly one entry
   *     (`c`, n) in the returned list where n equals the number of rentals associated with `c`.
   *   - Customers without rentals are absent from the list.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Map<Customer, Integer>> countCarsRentedPerCustomer()
  {
    // 1. Initialise countMap
    Map<Customer, Integer> countMap = new HashMap<>();

    // 2. Populate the map
    for (Rental rental : getRentals()) {
      Customer cust = rental.getCustomer();
      if (cust != null) {
        countMap.put(cust, countMap.getOrDefault(cust, 0) + 1);
      }
    }

    // 3. Convert each entry into a single‑entry map and collect them into a list
    EList<Map<Customer, Integer>> result = new BasicEList<>();
    for (Map.Entry<Customer, Integer> entry : countMap.entrySet()) {
      Map<Customer, Integer> singleMap = new HashMap<>();
      singleMap.put(entry.getKey(), entry.getValue());
      result.add(singleMap);
    }

    // 4. Return the list
    return result;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  {
    switch (featureID)
    {
      case CarrentalPackage.STORE__CARS:
        return ((InternalEList<?>)getCars()).basicRemove(otherEnd, msgs);
      case CarrentalPackage.STORE__RENTALS:
        return ((InternalEList<?>)getRentals()).basicRemove(otherEnd, msgs);
      case CarrentalPackage.STORE__NOTICES:
        return ((InternalEList<?>)getNotices()).basicRemove(otherEnd, msgs);
    }
    return super.eInverseRemove(otherEnd, featureID, msgs);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  {
    switch (featureID)
    {
      case CarrentalPackage.STORE__CARS:
        return getCars();
      case CarrentalPackage.STORE__RENTALS:
        return getRentals();
      case CarrentalPackage.STORE__NOTICES:
        return getNotices();
    }
    return super.eGet(featureID, resolve, coreType);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  {
    switch (featureID)
    {
      case CarrentalPackage.STORE__CARS:
        getCars().clear();
        getCars().addAll((Collection<? extends Car>)newValue);
        return;
      case CarrentalPackage.STORE__RENTALS:
        getRentals().clear();
        getRentals().addAll((Collection<? extends Rental>)newValue);
        return;
      case CarrentalPackage.STORE__NOTICES:
        getNotices().clear();
        getNotices().addAll((Collection<? extends OverdueNotice>)newValue);
        return;
    }
    super.eSet(featureID, newValue);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public void eUnset(int featureID)
  {
    switch (featureID)
    {
      case CarrentalPackage.STORE__CARS:
        getCars().clear();
        return;
      case CarrentalPackage.STORE__RENTALS:
        getRentals().clear();
        return;
      case CarrentalPackage.STORE__NOTICES:
        getNotices().clear();
        return;
    }
    super.eUnset(featureID);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public boolean eIsSet(int featureID)
  {
    switch (featureID)
    {
      case CarrentalPackage.STORE__CARS:
        return cars != null && !cars.isEmpty();
      case CarrentalPackage.STORE__RENTALS:
        return rentals != null && !rentals.isEmpty();
      case CarrentalPackage.STORE__NOTICES:
        return notices != null && !notices.isEmpty();
    }
    return super.eIsSet(featureID);
  }

} // Store

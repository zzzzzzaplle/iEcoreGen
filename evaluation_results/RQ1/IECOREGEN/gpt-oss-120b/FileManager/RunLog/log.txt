   *   Counts how many documents have a creation date later than a specified date.
   * Algorithm:
   *   1. Validate that `date` is not null; otherwise throw IllegalArgumentException.
   *   2. Initialize counter ← 0.
   *   3. For each Document d in this.documents do
   *        if d.createDate.isAfter(date) then
   *            counter ← counter + 1
   *   4. Return counter.
   * Input:
   *   - date : EDate – the reference date. Must be a valid EDate instance.
   * Output:
   *   int – number of documents whose `createDate` is strictly after the supplied `date`.
   * Pre-condition:
   *   - `date` is a non‑null EDate object.
   * Post-condition:
   *   - Returned value equals |{ d ∈ documents | d.createDate > date }|.
   *   - No modification to any Document or the FileSystem.
   * <!-- end-model-doc -->
   * @model dateRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int countDocumentsAfterDate(final Date date)
  {
    if (date == null) {
      throw new IllegalArgumentException("Parameter 'date' must not be null.");
    }
    int counter = 0;
    for (Document d : getDocuments()) {
      Date docDate = d.getCreateDate();
      if (docDate != null && docDate.after(date)) {
        counter++;
      }
    }
    return counter;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves a list of distinct author names whose documents are associated with a given editor.
   * Algorithm:
   *   1. Validate that `editor` is not null; otherwise throw IllegalArgumentException.
   *   2. Initialise an empty Set<String> authorSet.
   *   3. For each Document d in this.documents do
   *        if d.editor == editor then
   *            authorSet.add(d.author)
   *   4. Convert authorSet to a List<String> preserving any order (e.g., insertion order).
   *   5. Return the list.
   * Input:
   *   - editor : Editor – the editor whose authors are to be retrieved. Must be an instance
   *     of one of the concrete editor classes (TextEditor, ImageEditor, VideoEditor).
   * Output:
   *   List<String> – a collection of unique author names (no duplicates) whose documents use the
   *   specified editor. If no such documents exist, the list is empty.
   * Pre-condition:
   *   - `editor` is a non‑null reference to a concrete Editor object that exists in this.editors
   *     (or at least matches the reference used inside Document objects).
   * Post-condition:
   *   - Returned list contains exactly the set { d.author | d ∈ documents ∧ d.editor == editor }.
   *   - The internal state of the FileSystem and its Documents remains unchanged.
   * <!-- end-model-doc -->
   * @model editorRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> getAuthorsByEditor(final Editor editor)
  {
    if (editor == null) {
      throw new IllegalArgumentException("Parameter 'editor' must not be null.");
    }
    Set<String> authorSet = new HashSet<>();
    for (Document d : getDocuments()) {
      if (editor.equals(d.getEditor())) {
        String author = d.getAuthor();
        if (author != null) {
          authorSet.add(author);
        }
      }
    }
    // BasicEList has a constructor that accepts a Collection
    return new BasicEList<>(authorSet);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Produces a mapping from each editor type (Text, Image, Video) to the count of documents
   *   that are assigned to that editor.
   * Algorithm:
   *   1. Create an empty map resultMap : Map<String, Integer>.
   *   2. Initialise resultMap entries for all known editor types with 0:
   *        resultMap["TextEditor"]  ← 0
   *        resultMap["ImageEditor"] ← 0
   *        resultMap["VideoEditor"] ← 0
   *   3. For each Document d in this.documents do
   *        editorName ← d.editor.name   // assumed to be one of the three names above
   *        current ← resultMap[editorName]
   *        resultMap[editorName] ← current + 1
   *   4. Return resultMap.
   * Input:
   *   None.
   * Output:
   *   EMap (implemented as Map<String, Integer>) – keys are editor class names
   *   ("TextEditor", "ImageEditor", "VideoEditor") and values are the corresponding
   *   document counts (≥ 0). If no documents exist for a type, its count is 0.
   * Pre-condition:
   *   - The FileSystem instance has its `documents` list initialized.
   *   - Each Document in the list has a non‑null `editor` reference whose `name`
   *     matches one of the three supported editor names.
   * Post-condition:
   *   - Returned map reflects the exact distribution of documents across editor types.
   *   - The FileSystem state remains unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Map<String, Integer> countDocumentsPerEditorType()
  {
    Map<String, Integer> resultMap = new HashMap<>();
    // initialise known editor types
    resultMap.put("TextEditor", 0);
    resultMap.put("ImageEditor", 0);
    resultMap.put("VideoEditor", 0);

    for (Document d : getDocuments()) {
      Editor editor = d.getEditor();
      if (editor == null) {
        continue; // safety, though model says non‑null
      }
      String name = editor.getName();
      // only consider known types; unknown types are ignored
      if (resultMap.containsKey(name)) {
        resultMap.put(name, resultMap.get(name) + 1);
      }
    }
    return resultMap;
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // FileSystem
100647 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../FileManager/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../FileManager/src-gen/edu/fs/
100828 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
100828 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - ----------
1. WARNING in D:\EclipseWorkspace\FileManager\src-gen\edu\fs\FileSystem.java (at line 23)
	import java.util.List;
	       ^^^^^^^^^^^^^^
The import java.util.List is never used
----------
2. WARNING in D:\EclipseWorkspace\FileManager\src-gen\edu\fs\FileSystem.java (at line 24)
	import java.util.ArrayList;
	       ^^^^^^^^^^^^^^^^^^^
The import java.util.ArrayList is never used
----------
2 problems (2 warnings)

100828 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
100829 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
100830 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample3.mwe2 启动完成
正在拷贝 src-gen/edu/fs 到 gpt-oss-120b/fs3...
拷贝完成！

======================================
正在启动 sample4.mwe2...
======================================
101139 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
101214 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project FileManager at 'file:/D:/EclipseWorkspace/FileManager/'
101216 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
101225 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@5382a35f
101225 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
101229 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
101230 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
A file system contains information from multiple documents. The document can be added and removed from the file system, and all the documents can be listed. Each document uses an editor suitable for creation. A document contains the document's name, creation date, author information, and size. The user determines the assignment of the editor to the documents. Each editor has a name. The system has three editors that allow you to manage documents: Text Editor, Image Editor, and Video Editor.
Function requirement:
+ Calculate the total size of all documents in the file system. Output the sum of all document sizes. Return 0 if there is no document.

+ Compute the average size of all documents for each editor (Text Editor, Image Editor, and Video Editor) in the file system.Return 0 if there is no document.

+ Count the number of documents in the file system that were created after a specified date.

+ Count the number of documents for each editor (TextEditor, ImageEditor, VideoEditor) in the file system.

+ Retrieve the names of all authors whose documents are edited with a specified editor in the file system.
```

# Class Diagram
```plantuml
@startuml

title fs Model

class Document {
    author : String
    createDate : EDate
    name : String
    size : int
    editor : Editor
}
abstract class Editor {
    name : String
    documents : List<Document>
}
class FileSystem {
    documents : List<Document>
    editors : List<Editor>
    calculateTotalDocumentSize() : int
    countDocumentsAfterDate(date : EDate) : int
    countDocumentsPerEditorType() : EMap
    findAverageSizePerEditor() : EMap
    getAuthorsByEditor(editor : Editor) : List<String>
}
class ImageEditor {
}
class TextEditor {
}
class VideoEditor {
}

Document --> Editor : editor  'opposite: documents
Editor --> "*" Document : documents  'opposite: editor
FileSystem *-- "*" Document : documents
FileSystem *-- "*" Editor : editors
ImageEditor --|> Editor
TextEditor --|> Editor
VideoEditor --|> Editor
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

114215 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@7a78d2aa (name: countDocumentsAfterDate) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Counts how many documents have a creation date later than the supplied date.
Algorithm:
  1. Validate that the argument `date` is not null.
  2. Initialise count ← 0.
  3. FOR each doc IN this.documents DO
       IF doc.createDate > date THEN
           count ← count + 1
       END IF
     END FOR
  4. RETURN count.
Input:
  - date : EDate
      The reference date. Must represent a valid calendar date.
Output:
  - count : int
      Number of documents whose createDate is after `date`. Guarantees count ≥ 0.
Pre-condition:
  - `date` is a valid, non‑null EDate instance.
  - this.documents is not null.
Post-condition:
  - The returned count equals the cardinality of { d ∈ this.documents | d.createDate > date }.
  - The file system remains unchanged., org.eclipse.emf.ecore.impl.EOperationImpl@2a9e7b4d (name: findAverageSizePerEditor) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Computes, for each editor type, the average size of the documents that are
  edited with that editor. If an editor has no documents, its average is 0.0.
Algorithm:
  1. CREATE sumMap ← map<String, long> with keys "TextEditor","ImageEditor","VideoEditor", all values 0.
  2. CREATE countMap ← map<String, int> with same keys, all values 0.
  3. FOR each doc IN this.documents DO
       editorName ← doc.editor.getClass().getSimpleName()
       IF sumMap contains editorName THEN
           sumMap[editorName] ← sumMap[editorName] + doc.size
           countMap[editorName] ← countMap[editorName] + 1
       END IF
     END FOR
  4. CREATE avgMap ← empty map<String, double>.
  5. FOR each editorName IN sumMap.keys DO
       IF countMap[editorName] > 0 THEN
           avg ← sumMap[editorName] / countMap[editorName] as double
       ELSE
           avg ← 0.0
       END IF
       avgMap[editorName] ← avg
     END FOR
  6. RETURN avgMap.
Input:
  - (none)
Output:
  - avgMap : EMap<String, double>
      Keys: "TextEditor", "ImageEditor", "VideoEditor".
      Values: average document size for the corresponding editor; 0.0 when no documents exist.
Pre-condition:
  - this.documents is not null.
Post-condition:
  - For each editor e, avgMap[e] = ( Σ size of docs with editor e ) / (number of docs with editor e),
    or 0.0 if denominator is zero.
  - The file system state is unchanged., org.eclipse.emf.ecore.impl.EOperationImpl@72406594 (name: getAuthorsByEditor) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary:
  Retrieves a list of distinct author names whose documents are edited with the
  specified editor.
Algorithm:
  1. Validate that `editor` is not null and belongs to this.editors.
  2. CREATE authorSet ← empty Set<String>.
  3. FOR each doc IN this.documents DO
       IF doc.editor == editor THEN
           authorSet.add(doc.author)
       END IF
     END FOR
  4. CONVERT authorSet to a List<String> preserving any desired ordering (e.g., alphabetical).
  5. RETURN the list.
Input:
  - editor : Editor
      The concrete editor instance (TextEditor, ImageEditor or VideoEditor) for which authors are requested.
Output:
  - authors : List<String>
      A list of unique author names (strings). May be empty if no document uses the given editor.
Pre-condition:
  - `editor` is a non‑null reference to an Editor object that exists in this.editors.
  - this.documents is not null.
Post-condition:
  - The returned list contains exactly the distinct values of doc.author for all documents
    where doc.editor equals the supplied `editor`.
  - No modification of any Document, Editor, or the FileSystem occurs., org.eclipse.emf.ecore.impl.EOperationImpl@29ae2517 (name: calculateTotalDocumentSize) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Returns the sum of the sizes of all documents stored in the file system.
Algorithm:
  1. Initialise totalSize ← 0.
  2. FOR each doc IN this.documents DO
       totalSize ← totalSize + doc.size
     END FOR
  3. RETURN totalSize.
Input:
  - (none)
Output:
  - totalSize : int
      The total size in bytes (or the domain‑specific unit) of all documents.
      Guarantees: totalSize ≥ 0. Returns 0 when the document list is empty.
Pre-condition:
  - this.documents is not null (may be empty).
Post-condition:
  - The returned value equals the mathematical sum of doc.size for every doc in this.documents.
  - No modification of the file system state., org.eclipse.emf.ecore.impl.EOperationImpl@254d8ef6 (name: countDocumentsPerEditorType) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Provides a mapping from each editor type (TextEditor, ImageEditor, VideoEditor)
  to the number of documents that use that editor.
Algorithm:
  1. CREATE resultMap ← empty map<String, int>.
  2. FOR each editorType IN {"TextEditor","ImageEditor","VideoEditor"} DO
       resultMap[editorType] ← 0
     END FOR
  3. FOR each doc IN this.documents DO
       editorName ← doc.editor.getClass().getSimpleName()
       IF resultMap contains editorName THEN
           resultMap[editorName] ← resultMap[editorName] + 1
       END IF
     END FOR
  4. RETURN resultMap.
Input:
  - (none)
Output:
  - resultMap : EMap<String, int>
      Keys are exactly "TextEditor", "ImageEditor", "VideoEditor".
      Values are non‑negative integers indicating document counts.
Pre-condition:
  - this.documents is not null.
Post-condition:
  - For each editor type e, resultMap[e] equals the number of documents whose
    doc.editor is an instance of the corresponding concrete editor class.
  - No mutation of the file system occurs.}
114218 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
114238 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../FileManager/src-gen/edu/fs
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.fs;

import java.util.Collection;
import java.util.Date;
import java.util.Map;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>File System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.fs.FileSystem#getDocuments <em>Documents</em>}</li>
 *   <li>{@link edu.fs.FileSystem#getEditors <em>Editors</em>}</li>
 * </ul>
 *
 * @see edu.fs.FsPackage#getFileSystem()
 * @model kind="class"
 * @generated
 */
public class FileSystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Document> documents;

  protected EList<Editor> editors;

  protected FileSystem()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Document> getDocuments()
  { ... /* omitted */ }

  public EList<Editor> getEditors()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns the sum of the sizes of all documents stored in the file system.
   * Algorithm:
   *   1. Initialise totalSize ← 0.
   *   2. FOR each doc IN this.documents DO
   *        totalSize ← totalSize + doc.size
   *      END FOR
   *   3. RETURN totalSize.
   * Input:
   *   - (none)
   * Output:
   *   - totalSize : int
   *       The total size in bytes (or the domain‑specific unit) of all documents.
   *       Guarantees: totalSize ≥ 0. Returns 0 when the document list is empty.
   * Pre-condition:
   *   - this.documents is not null (may be empty).
   * Post-condition:
   *   - The returned value equals the mathematical sum of doc.size for every doc in this.documents.
   *   - No modification of the file system state.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int calculateTotalDocumentSize()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes, for each editor type, the average size of the documents that are
   *   edited with that editor. If an editor has no documents, its average is 0.0.
   * Algorithm:
   *   1. CREATE sumMap ← map<String, long> with keys "TextEditor","ImageEditor","VideoEditor", all values 0.
   *   2. CREATE countMap ← map<String, int> with same keys, all values 0.
   *   3. FOR each doc IN this.documents DO
   *        editorName ← doc.editor.getClass().getSimpleName()
   *        IF sumMap contains editorName THEN
   *            sumMap[editorName] ← sumMap[editorName] + doc.size
   *            countMap[editorName] ← countMap[editorName] + 1
   *        END IF
   *      END FOR
   *   4. CREATE avgMap ← empty map<String, double>.
   *   5. FOR each editorName IN sumMap.keys DO
   *        IF countMap[editorName] > 0 THEN
   *            avg ← sumMap[editorName] / countMap[editorName] as double
   *        ELSE
   *            avg ← 0.0
   *        END IF
   *        avgMap[editorName] ← avg
   *      END FOR
   *   6. RETURN avgMap.
   * Input:
   *   - (none)
   * Output:
   *   - avgMap : EMap<String, double>
   *       Keys: "TextEditor", "ImageEditor", "VideoEditor".
   *       Values: average document size for the corresponding editor; 0.0 when no documents exist.
   * Pre-condition:
   *   - this.documents is not null.
   * Post-condition:
   *   - For each editor e, avgMap[e] = ( Σ size of docs with editor e ) / (number of docs with editor e),
   *     or 0.0 if denominator is zero.
   *   - The file system state is unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public Map<String, Float> findAverageSizePerEditor()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Counts how many documents have a creation date later than the supplied date.
   * Algorithm:
   *   1. Validate that the argument `date` is not null.
   *   2. Initialise count ← 0.
   *   3. FOR each doc IN this.documents DO
   *        IF doc.createDate > date THEN
   *            count ← count + 1
   *        END IF
   *      END FOR
   *   4. RETURN count.
   * Input:
   *   - date : EDate
   *       The reference date. Must represent a valid calendar date.
   * Output:
   *   - count : int
   *       Number of documents whose createDate is after `date`. Guarantees count ≥ 0.
   * Pre-condition:
   *   - `date` is a valid, non‑null EDate instance.
   *   - this.documents is not null.
   * Post-condition:
   *   - The returned count equals the cardinality of { d ∈ this.documents | d.createDate > date }.
   *   - The file system remains unchanged.
   * <!-- end-model-doc -->
   * @model dateRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int countDocumentsAfterDate(final Date date)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves a list of distinct author names whose documents are edited with the
   *   specified editor.
   * Algorithm:
   *   1. Validate that `editor` is not null and belongs to this.editors.
   *   2. CREATE authorSet ← empty Set<String>.
   *   3. FOR each doc IN this.documents DO
   *        IF doc.editor == editor THEN
   *            authorSet.add(doc.author)
   *        END IF
   *      END FOR
   *   4. CONVERT authorSet to a List<String> preserving any desired ordering (e.g., alphabetical).
   *   5. RETURN the list.
   * Input:
   *   - editor : Editor
   *       The concrete editor instance (TextEditor, ImageEditor or VideoEditor) for which authors are requested.
   * Output:
   *   - authors : List<String>
   *       A list of unique author names (strings). May be empty if no document uses the given editor.
   * Pre-condition:
   *   - `editor` is a non‑null reference to an Editor object that exists in this.editors.
   *   - this.documents is not null.
   * Post-condition:
   *   - The returned list contains exactly the distinct values of doc.author for all documents
   *     where doc.editor equals the supplied `editor`.
   *   - No modification of any Document, Editor, or the FileSystem occurs.
   * <!-- end-model-doc -->
   * @model editorRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<String> getAuthorsByEditor(final Editor editor)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Provides a mapping from each editor type (TextEditor, ImageEditor, VideoEditor)
   *   to the number of documents that use that editor.
   * Algorithm:
   *   1. CREATE resultMap ← empty map<String, int>.
   *   2. FOR each editorType IN {"TextEditor","ImageEditor","VideoEditor"} DO
   *        resultMap[editorType] ← 0
   *      END FOR
   *   3. FOR each doc IN this.documents DO
   *        editorName ← doc.editor.getClass().getSimpleName()
   *        IF resultMap contains editorName THEN
   *            resultMap[editorName] ← resultMap[editorName] + 1
   *        END IF
   *      END FOR
   *   4. RETURN resultMap.
   * Input:
   *   - (none)
   * Output:
   *   - resultMap : EMap<String, int>
   *       Keys are exactly "TextEditor", "ImageEditor", "VideoEditor".
   *       Values are non‑negative integers indicating document counts.
   * Pre-condition:
   *   - this.documents is not null.
   * Post-condition:
   *   - For each editor type e, resultMap[e] equals the number of documents whose
   *     doc.editor is an instance of the corresponding concrete editor class.
   *   - No mutation of the file system occurs.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public Map<String, Integer> countDocumentsPerEditorType()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // FileSystem
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Document` contains the following methods.
  + Instance creation: Use `FsFactory.eINSTANCE.createDocument()`
  + Getter methods: public String getName(), public Date getCreateDate(), public String getAuthor(), public int getSize(), public Editor getEditor()
  + Setter methods: public void setName(String newName), public void setCreateDate(Date newCreateDate), public void setAuthor(String newAuthor), public void setSize(int newSize), public void setEditor(Editor newEditor)
- Class `Editor` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: public String getName(), public EList<Document> getDocuments()
  + Setter methods: public void setName(String newName)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.fs;

import java.util.Collection;
import java.util.Date;
import java.util.Map;
import java.util.HashMap;
import java.util.HashSet;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Set;
import java.util.List;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.BasicEList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>File System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.fs.FileSystem#getDocuments <em>Documents</em>}</li>
 *   <li>{@link edu.fs.FileSystem#getEditors <em>Editors</em>}</li>
 * </ul>
 *
 * @see edu.fs.FsPackage#getFileSystem()
 * @model kind="class"
 * @generated
 */
public class FileSystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Document> documents;

  protected EList<Editor> editors;

  protected FileSystem()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Document> getDocuments()
  { ... /* omitted */ }

  public EList<Editor> getEditors()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns the sum of the sizes of all documents stored in the file system.
   * Algorithm:
   *   1. Initialise totalSize ← 0.
   *   2. FOR each doc IN this.documents DO
   *        totalSize ← totalSize + doc.size
   *      END FOR
   *   3. RETURN totalSize.
   * Input:
   *   - (none)
   * Output:
   *   - totalSize : int
   *       The total size in bytes (or the domain‑specific unit) of all documents.
   *       Guarantees: totalSize ≥ 0. Returns 0 when the document list is empty.
   * Pre-condition:
   *   - this.documents is not null (may be empty).
   * Post-condition:
   *   - The returned value equals the mathematical sum of doc.size for every doc in this.documents.
   *   - No modification of the file system state.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateTotalDocumentSize()
  {
    int totalSize = 0;
    for (Document doc : this.documents) {
      totalSize += doc.getSize();
    }
    return totalSize;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes, for each editor type, the average size of the documents that are
   *   edited with that editor. If an editor has no documents, its average is 0.0.
   * Algorithm:
   *   1. CREATE sumMap ← map<String, long> with keys "TextEditor","ImageEditor","VideoEditor", all values 0.
   *   2. CREATE countMap ← map<String, int> with same keys, all values 0.
   *   3. FOR each doc IN this.documents DO
   *        editorName ← doc.editor.getClass().getSimpleName()
   *        IF sumMap contains editorName THEN
   *            sumMap[editorName] ← sumMap[editorName] + doc.size
   *            countMap[editorName] ← countMap[editorName] + 1
   *        END IF
   *      END FOR
   *   4. CREATE avgMap ← empty map<String, double>.
   *   5. FOR each editorName IN sumMap.keys DO
   *        IF countMap[editorName] > 0 THEN
   *            avg ← sumMap[editorName] / countMap[editorName] as double
   *        ELSE
   *            avg ← 0.0
   *        END IF
   *        avgMap[editorName] ← avg
   *      END FOR
   *   6. RETURN avgMap.
   * Input:
   *   - (none)
   * Output:
   *   - avgMap : EMap<String, double>
   *       Keys: "TextEditor", "ImageEditor", "VideoEditor".
   *       Values: average document size for the corresponding editor; 0.0 when no documents exist.
   * Pre-condition:
   *   - this.documents is not null.
   * Post-condition:
   *   - For each editor e, avgMap[e] = ( Σ size of docs with editor e ) / (number of docs with editor e),
   *     or 0.0 if denominator is zero.
   *   - The file system state is unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Map<String, Float> findAverageSizePerEditor()
  {
    Map<String, Long> sumMap = new HashMap<>();
    Map<String, Integer> countMap = new HashMap<>();

    // initialise maps with the three editor types
    String[] editorTypes = { "TextEditor", "ImageEditor", "VideoEditor" };
    for (String type : editorTypes) {
      sumMap.put(type, 0L);
      countMap.put(type, 0);
    }

    // accumulate sums and counts
    for (Document doc : this.documents) {
      Editor editor = doc.getEditor();
      if (editor != null) {
        String editorName = editor.getClass().getSimpleName();
        if (sumMap.containsKey(editorName)) {
          sumMap.put(editorName, sumMap.get(editorName) + doc.getSize());
          countMap.put(editorName, countMap.get(editorName) + 1);
        }
      }
    }

    // compute averages
    Map<String, Float> avgMap = new HashMap<>();
    for (String editorName : sumMap.keySet()) {
      int count = countMap.get(editorName);
      float avg = (count > 0) ? (float) (sumMap.get(editorName) / (double) count) : 0.0f;
      avgMap.put(editorName, avg);
    }

    return avgMap;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Counts how many documents have a creation date later than the supplied date.
   * Algorithm:
   *   1. Validate that the argument `date` is not null.
   *   2. Initialise count ← 0.
   *   3. FOR each doc IN this.documents DO
   *        IF doc.createDate > date THEN
   *            count ← count + 1
   *        END IF
   *      END FOR
   *   4. RETURN count.
   * Input:
   *   - date : EDate
   *       The reference date. Must represent a valid calendar date.
   * Output:
   *   - count : int
   *       Number of documents whose createDate is after `date`. Guarantees count ≥ 0.
   * Pre-condition:
   *   - `date` is a valid, non‑null EDate instance.
   *   - this.documents is not null.
   * Post-condition:
   *   - The returned count equals the cardinality of { d ∈ this.documents | d.createDate > date }.
   *   - The file system remains unchanged.
   * <!-- end-model-doc -->
   * @model dateRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int countDocumentsAfterDate(final Date date)
  {
    if (date == null) {
      throw new IllegalArgumentException("date must not be null");
    }

    int count = 0;
    for (Document doc : this.documents) {
      Date createDate = doc.getCreateDate();
      if (createDate != null && createDate.after(date)) {
        count++;
      }
    }
    return count;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves a list of distinct author names whose documents are edited with the
   *   specified editor.
   * Algorithm:
   *   1. Validate that `editor` is not null and belongs to this.editors.
   *   2. CREATE authorSet ← empty Set<String>.
   *   3. FOR each doc IN this.documents DO
   *        IF doc.editor == editor THEN
   *            authorSet.add(doc.author)
   *        END IF
   *      END FOR
   *   4. CONVERT authorSet to a List<String> preserving any desired ordering (e.g., alphabetical).
   *   5. RETURN the list.
   * Input:
   *   - editor : Editor
   *       The concrete editor instance (TextEditor, ImageEditor or VideoEditor) for which authors are requested.
   * Output:
   *   - authors : List<String>
   *       A list of unique author names (strings). May be empty if no document uses the given editor.
   * Pre-condition:
   *   - `editor` is a non‑null reference to an Editor object that exists in this.editors.
   *   - this.documents is not null.
   * Post-condition:
   *   - The returned list contains exactly the distinct values of doc.author for all documents
   *     where doc.editor equals the supplied `editor`.
   *   - No modification of any Document, Editor, or the FileSystem occurs.
   * <!-- end-model-doc -->
   * @model editorRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> getAuthorsByEditor(final Editor editor)
  {
    if (editor == null) {
      throw new IllegalArgumentException("editor must not be null");
    }
    if (this.editors == null || !this.editors.contains(editor)) {
      throw new IllegalArgumentException("editor does not belong to this FileSystem");
    }

    Set<String> authorSet = new HashSet<>();
    for (Document doc : this.documents) {
      if (editor.equals(doc.getEditor())) {
        String author = doc.getAuthor();
        if (author != null) {
          authorSet.add(author);
        }
      }
    }

    List<String> authorList = new ArrayList<>(authorSet);
    Collections.sort(authorList);
    return new BasicEList<>(authorList);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Provides a mapping from each editor type (TextEditor, ImageEditor, VideoEditor)
   *   to the number of documents that use that editor.
   * Algorithm:
   *   1. CREATE resultMap ← empty map<String, int>.
   *   2. FOR each editorType IN {"TextEditor","ImageEditor","VideoEditor"} DO
   *        resultMap[editorType] ← 0
   *      END FOR
   *   3. FOR each doc IN this.documents DO
   *        editorName ← doc.editor.getClass().getSimpleName()
   *        IF resultMap contains editorName THEN
   *            resultMap[editorName] ← resultMap[editorName] + 1
   *        END IF
   *      END FOR
   *   4. RETURN resultMap.
   * Input:
   *   - (none)
   * Output:
   *   - resultMap : EMap<String, int>
   *       Keys are exactly "TextEditor", "ImageEditor", "VideoEditor".
   *       Values are non‑negative integers indicating document counts.
   * Pre-condition:
   *   - this.documents is not null.
   * Post-condition:
   *   - For each editor type e, resultMap[e] equals the number of documents whose
   *     doc.editor is an instance of the corresponding concrete editor class.
   *   - No mutation of the file system occurs.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Map<String, Integer> countDocumentsPerEditorType()
  {
    Map<String, Integer> resultMap = new HashMap<>();
    String[] editorTypes = { "TextEditor", "ImageEditor", "VideoEditor" };
    for (String type : editorTypes) {
      resultMap.put(type, 0);
    }

    for (Document doc : this.documents) {
      Editor editor = doc.getEditor();
      if (editor != null) {
        String editorName = editor.getClass().getSimpleName();
        if (resultMap.containsKey(editorName)) {
          resultMap.put(editorName, resultMap.get(editorName) + 1);
        }
      }
    }

    return resultMap;
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // FileSystem
140275 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../FileManager/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../FileManager/src-gen/edu/fs/
140389 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
140389 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
140389 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
140390 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
140391 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample4.mwe2 启动完成
正在拷贝 src-gen/edu/fs 到 gpt-oss-120b/fs4...
拷贝完成！

======================================
正在启动 sample5.mwe2...
======================================
140582 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
140654 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project FileManager at 'file:/D:/EclipseWorkspace/FileManager/'
140657 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
140663 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@39179470
140663 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
140664 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
140665 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
A file system contains information from multiple documents. The document can be added and removed from the file system, and all the documents can be listed. Each document uses an editor suitable for creation. A document contains the document's name, creation date, author information, and size. The user determines the assignment of the editor to the documents. Each editor has a name. The system has three editors that allow you to manage documents: Text Editor, Image Editor, and Video Editor.
Function requirement:
+ Calculate the total size of all documents in the file system. Output the sum of all document sizes. Return 0 if there is no document.

+ Compute the average size of all documents for each editor (Text Editor, Image Editor, and Video Editor) in the file system.Return 0 if there is no document.

+ Count the number of documents in the file system that were created after a specified date.

+ Count the number of documents for each editor (TextEditor, ImageEditor, VideoEditor) in the file system.

+ Retrieve the names of all authors whose documents are edited with a specified editor in the file system.
```

# Class Diagram
```plantuml
@startuml

title fs Model

class Document {
    author : String
    createDate : EDate
    name : String
    size : int
    editor : Editor
}
abstract class Editor {
    name : String
    documents : List<Document>
}
class FileSystem {
    documents : List<Document>
    editors : List<Editor>
    calculateTotalDocumentSize() : int
    countDocumentsAfterDate(date : EDate) : int
    countDocumentsPerEditorType() : EMap
    findAverageSizePerEditor() : EMap
    getAuthorsByEditor(editor : Editor) : List<String>
}
class ImageEditor {
}
class TextEditor {
}
class VideoEditor {
}

Document --> Editor : editor  'opposite: documents
Editor --> "*" Document : documents  'opposite: editor
FileSystem *-- "*" Document : documents
FileSystem *-- "*" Editor : editors
ImageEditor --|> Editor
TextEditor --|> Editor
VideoEditor --|> Editor
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

148372 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@488c6c98 (name: countDocumentsPerEditorType) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Produces a mapping from each editor type (TextEditor, ImageEditor, VideoEditor) to the number of documents associated with that editor in the FileSystem.
Algorithm:
  1. Create an empty map resultMap where key = String (editor name) and value = Integer (count).
  2. Initialise counts for the three known editors to 0:
       resultMap["TextEditor"] = 0
       resultMap["ImageEditor"] = 0
       resultMap["VideoEditor"] = 0
  3. For each Document d in this.documents:
       editorName = d.editor.name   // guaranteed to be one of the three names
       resultMap[editorName] = resultMap[editorName] + 1
  4. Return resultMap.
Input:
  None.
Output:
  EMap (implemented as Map<String, Integer>) – a map containing exactly three entries:
       "TextEditor" → count of TextEditor documents,
       "ImageEditor" → count of ImageEditor documents,
       "VideoEditor" → count of VideoEditor documents.
  If there are no documents, all counts are 0.
Pre-condition:
  - The FileSystem instance exists and its `documents` list is initialized (may be empty).
  - Every Document's `editor` reference points to an instance whose `name` matches one of the three supported editors.
Post-condition:
  The map reflects the exact number of documents per editor type at the moment of invocation., org.eclipse.emf.ecore.impl.EOperationImpl@2530baf6 (name: findAverageSizePerEditor) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Calculates the average document size for each editor type (TextEditor, ImageEditor, VideoEditor) present in the FileSystem.
Algorithm:
  1. Create two auxiliary maps:
       totalSizeMap  (String → long) initialized to 0 for each editor name.
       countMap      (String → int)  initialized to 0 for each editor name.
  2. For each Document d in this.documents:
       editorName = d.editor.name
       totalSizeMap[editorName] = totalSizeMap[editorName] + d.size
       countMap[editorName]     = countMap[editorName] + 1
  3. Create resultMap (String → double).
  4. For each editorName in {"TextEditor","ImageEditor","VideoEditor"}:
       if countMap[editorName] == 0 then
           resultMap[editorName] = 0.0
       else
           resultMap[editorName] = totalSizeMap[editorName] / (double) countMap[editorName]
  5. Return resultMap.
Input:
  None.
Output:
  EMap (implemented as Map<String, Double>) – a map with three entries:
       "TextEditor" → average size of TextEditor documents,
       "ImageEditor" → average size of ImageEditor documents,
       "VideoEditor" → average size of VideoEditor documents.
  The average is expressed as a double; if an editor has no documents, its average is 0.0.
Pre-condition:
  - The FileSystem instance is properly initialised.
  - All Document objects have non‑negative `size` values.
Post-condition:
  The returned map represents the exact arithmetic mean of document sizes per editor at the time of the call., org.eclipse.emf.ecore.impl.EOperationImpl@ad6255e (name: calculateTotalDocumentSize) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Computes the total size (in bytes) of all Document objects stored in the FileSystem.
Algorithm:
  1. Initialize totalSize = 0.
  2. For each Document d in this.documents:
       totalSize = totalSize + d.size
  3. Return totalSize.
Input:
  None.
Output:
  int – the sum of the `size` attribute of every Document in the FileSystem.
  Returns 0 if the documents collection is empty.
Pre-condition:
  The FileSystem instance has been properly instantiated; its `documents` list may be empty but never null.
Post-condition:
  The returned value equals the arithmetic sum of all document sizes at the moment of invocation., org.eclipse.emf.ecore.impl.EOperationImpl@81a56b2 (name: countDocumentsAfterDate) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Counts how many documents in the FileSystem were created strictly after a given date.
Algorithm:
  1. Validate that the parameter `date` is not null; otherwise throw IllegalArgumentException.
  2. Initialize counter = 0.
  3. For each Document d in this.documents:
       if d.createDate.isAfter(date) then counter = counter + 1
  4. Return counter.
Input:
  date : EDate – the reference creation date. Must be a valid date object; format follows the EDate specification (e.g., YYYY‑MM‑DD). The date can represent any past, present or future moment.
Output:
  int – the number of documents whose `createDate` is later than the supplied `date`.
  Returns 0 when no document satisfies the condition or the documents collection is empty.
Pre-condition:
  - `date` is not null.
  - The FileSystem's `documents` list is initialized.
Post-condition:
  The returned integer accurately reflects the count of documents with creation dates after the supplied date at the time of execution., org.eclipse.emf.ecore.impl.EOperationImpl@1e7797db (name: getAuthorsByEditor) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary:
  Retrieves a list of distinct author names whose documents are edited by the specified editor.
Algorithm:
  1. Validate that the parameter `editor` is not null; otherwise throw IllegalArgumentException.
  2. Initialise an empty Set<String> authorSet to guarantee uniqueness.
  3. For each Document d in this.documents:
       if d.editor == editor then
           authorSet.add(d.author)
  4. Convert authorSet to a List<String> preserving insertion order (or any order) and return it.
Input:
  editor : Editor – a reference to one of the three concrete editor instances (TextEditor, ImageEditor, VideoEditor). Must not be null.
Output:
  List<String> – a collection of unique author names (String) whose documents are associated with the supplied editor.
  Returns an empty list if no documents match the editor.
Pre-condition:
  - `editor` is a non‑null object that belongs to the FileSystem's `editors` collection.
  - The FileSystem's `documents` list is initialized.
Post-condition:
  The returned list contains no duplicate author names and includes exactly those authors for which at least one Document in the FileSystem references the given editor at the moment of invocation.}
148375 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
148395 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../FileManager/src-gen/edu/fs
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.fs;

import java.util.Collection;
import java.util.Date;
import java.util.Map;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>File System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.fs.FileSystem#getDocuments <em>Documents</em>}</li>
 *   <li>{@link edu.fs.FileSystem#getEditors <em>Editors</em>}</li>
 * </ul>
 *
 * @see edu.fs.FsPackage#getFileSystem()
 * @model kind="class"
 * @generated
 */
public class FileSystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Document> documents;

  protected EList<Editor> editors;

  protected FileSystem()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Document> getDocuments()
  { ... /* omitted */ }

  public EList<Editor> getEditors()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes the total size (in bytes) of all Document objects stored in the FileSystem.
   * Algorithm:
   *   1. Initialize totalSize = 0.
   *   2. For each Document d in this.documents:
   *        totalSize = totalSize + d.size
   *   3. Return totalSize.
   * Input:
   *   None.
   * Output:
   *   int – the sum of the `size` attribute of every Document in the FileSystem.
   *   Returns 0 if the documents collection is empty.
   * Pre-condition:
   *   The FileSystem instance has been properly instantiated; its `documents` list may be empty but never null.
   * Post-condition:
   *   The returned value equals the arithmetic sum of all document sizes at the moment of invocation.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int calculateTotalDocumentSize()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Calculates the average document size for each editor type (TextEditor, ImageEditor, VideoEditor) present in the FileSystem.
   * Algorithm:
   *   1. Create two auxiliary maps:
   *        totalSizeMap  (String → long) initialized to 0 for each editor name.
   *        countMap      (String → int)  initialized to 0 for each editor name.
   *   2. For each Document d in this.documents:
   *        editorName = d.editor.name
   *        totalSizeMap[editorName] = totalSizeMap[editorName] + d.size
   *        countMap[editorName]     = countMap[editorName] + 1
   *   3. Create resultMap (String → double).
   *   4. For each editorName in {"TextEditor","ImageEditor","VideoEditor"}:
   *        if countMap[editorName] == 0 then
   *            resultMap[editorName] = 0.0
   *        else
   *            resultMap[editorName] = totalSizeMap[editorName] / (double) countMap[editorName]
   *   5. Return resultMap.
   * Input:
   *   None.
   * Output:
   *   EMap (implemented as Map<String, Double>) – a map with three entries:
   *        "TextEditor" → average size of TextEditor documents,
   *        "ImageEditor" → average size of ImageEditor documents,
   *        "VideoEditor" → average size of VideoEditor documents.
   *   The average is expressed as a double; if an editor has no documents, its average is 0.0.
   * Pre-condition:
   *   - The FileSystem instance is properly initialised.
   *   - All Document objects have non‑negative `size` values.
   * Post-condition:
   *   The returned map represents the exact arithmetic mean of document sizes per editor at the time of the call.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public Map<String, Float> findAverageSizePerEditor()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Counts how many documents in the FileSystem were created strictly after a given date.
   * Algorithm:
   *   1. Validate that the parameter `date` is not null; otherwise throw IllegalArgumentException.
   *   2. Initialize counter = 0.
   *   3. For each Document d in this.documents:
   *        if d.createDate.isAfter(date) then counter = counter + 1
   *   4. Return counter.
   * Input:
   *   date : EDate – the reference creation date. Must be a valid date object; format follows the EDate specification (e.g., YYYY‑MM‑DD). The date can represent any past, present or future moment.
   * Output:
   *   int – the number of documents whose `createDate` is later than the supplied `date`.
   *   Returns 0 when no document satisfies the condition or the documents collection is empty.
   * Pre-condition:
   *   - `date` is not null.
   *   - The FileSystem's `documents` list is initialized.
   * Post-condition:
   *   The returned integer accurately reflects the count of documents with creation dates after the supplied date at the time of execution.
   * <!-- end-model-doc -->
   * @model dateRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int countDocumentsAfterDate(final Date date)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves a list of distinct author names whose documents are edited by the specified editor.
   * Algorithm:
   *   1. Validate that the parameter `editor` is not null; otherwise throw IllegalArgumentException.
   *   2. Initialise an empty Set<String> authorSet to guarantee uniqueness.
   *   3. For each Document d in this.documents:
   *        if d.editor == editor then
   *            authorSet.add(d.author)
   *   4. Convert authorSet to a List<String> preserving insertion order (or any order) and return it.
   * Input:
   *   editor : Editor – a reference to one of the three concrete editor instances (TextEditor, ImageEditor, VideoEditor). Must not be null.
   * Output:
   *   List<String> – a collection of unique author names (String) whose documents are associated with the supplied editor.
   *   Returns an empty list if no documents match the editor.
   * Pre-condition:
   *   - `editor` is a non‑null object that belongs to the FileSystem's `editors` collection.
   *   - The FileSystem's `documents` list is initialized.
   * Post-condition:
   *   The returned list contains no duplicate author names and includes exactly those authors for which at least one Document in the FileSystem references the given editor at the moment of invocation.
   * <!-- end-model-doc -->
   * @model editorRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<String> getAuthorsByEditor(final Editor editor)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Produces a mapping from each editor type (TextEditor, ImageEditor, VideoEditor) to the number of documents associated with that editor in the FileSystem.
   * Algorithm:
   *   1. Create an empty map resultMap where key = String (editor name) and value = Integer (count).
   *   2. Initialise counts for the three known editors to 0:
   *        resultMap["TextEditor"] = 0
   *        resultMap["ImageEditor"] = 0
   *        resultMap["VideoEditor"] = 0
   *   3. For each Document d in this.documents:
   *        editorName = d.editor.name   // guaranteed to be one of the three names
   *        resultMap[editorName] = resultMap[editorName] + 1
   *   4. Return resultMap.
   * Input:
   *   None.
   * Output:
   *   EMap (implemented as Map<String, Integer>) – a map containing exactly three entries:
   *        "TextEditor" → count of TextEditor documents,
   *        "ImageEditor" → count of ImageEditor documents,
   *        "VideoEditor" → count of VideoEditor documents.
   *   If there are no documents, all counts are 0.
   * Pre-condition:
   *   - The FileSystem instance exists and its `documents` list is initialized (may be empty).
   *   - Every Document's `editor` reference points to an instance whose `name` matches one of the three supported editors.
   * Post-condition:
   *   The map reflects the exact number of documents per editor type at the moment of invocation.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public Map<String, Integer> countDocumentsPerEditorType()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // FileSystem
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Document` contains the following methods.
  + Instance creation: Use `FsFactory.eINSTANCE.createDocument()`
  + Getter methods: public String getName(), public Date getCreateDate(), public String getAuthor(), public int getSize(), public Editor getEditor()
  + Setter methods: public void setName(String newName), public void setCreateDate(Date newCreateDate), public void setAuthor(String newAuthor), public void setSize(int newSize), public void setEditor(Editor newEditor)
- Class `Editor` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: public String getName(), public EList<Document> getDocuments()
  + Setter methods: public void setName(String newName)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.fs;

import java.util.Collection;
import java.util.Date;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
import java.util.List;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.BasicEList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>File System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.fs.FileSystem#getDocuments <em>Documents</em>}</li>
 *   <li>{@link edu.fs.FileSystem#getEditors <em>Editors</em>}</li>
 * </ul>
 *
 * @see edu.fs.FsPackage#getFileSystem()
 * @model kind="class"
 * @generated
 */
public class FileSystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Document> documents;

  protected EList<Editor> editors;

  protected FileSystem()
  { /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { /* omitted */ }

  public EList<Document> getDocuments()
  { /* omitted */ }

  public EList<Editor> getEditors()
  { /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes the total size (in bytes) of all Document objects stored in the FileSystem.
   * Algorithm:
   *   1. Initialize totalSize = 0.
   *   2. For each Document d in this.documents:
   *        totalSize = totalSize + d.size
   *   3. Return totalSize.
   * Input:
   *   None.
   * Output:
   *   int – the sum of the `size` attribute of every Document in the FileSystem.
   *   Returns 0 if the documents collection is empty.
   * Pre-condition:
   *   The FileSystem instance has been properly instantiated; its `documents` list may be empty but never null.
   * Post-condition:
   *   The returned value equals the arithmetic sum of all document sizes at the moment of invocation.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateTotalDocumentSize()
  {
    int totalSize = 0;
    for (Document d : this.documents) {
      totalSize += d.getSize();
    }
    return totalSize;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Calculates the average document size for each editor type (TextEditor, ImageEditor, VideoEditor) present in the FileSystem.
   * Algorithm:
   *   1. Create two auxiliary maps:
   *        totalSizeMap  (String → long) initialized to 0 for each editor name.
   *        countMap      (String → int)  initialized to 0 for each editor name.
   *   2. For each Document d in this.documents:
   *        editorName = d.editor.name
   *        totalSizeMap[editorName] = totalSizeMap[editorName] + d.size
   *        countMap[editorName]     = countMap[editorName] + 1
   *   3. Create resultMap (String → double).
   *   4. For each editorName in {"TextEditor","ImageEditor","VideoEditor"}:
   *        if countMap[editorName] == 0 then
   *            resultMap[editorName] = 0.0
   *        else
   *            resultMap[editorName] = totalSizeMap[editorName] / (double) countMap[editorName]
   *   5. Return resultMap.
   * Input:
   *   None.
   * Output:
   *   EMap (implemented as Map<String, Double>) – a map with three entries:
   *        "TextEditor" → average size of TextEditor documents,
   *        "ImageEditor" → average size of ImageEditor documents,
   *        "VideoEditor" → average size of VideoEditor documents.
   *   The average is expressed as a double; if an editor has no documents, its average is 0.0.
   * Pre-condition:
   *   - The FileSystem instance is properly initialised.
   *   - All Document objects have non‑negative `size` values.
   * Post-condition:
   *   The returned map represents the exact arithmetic mean of document sizes per editor at the time of the call.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Map<String, Float> findAverageSizePerEditor()
  {
    Map<String, Long> totalSizeMap = new HashMap<>();
    Map<String, Integer> countMap = new HashMap<>();

    // initialise for known editors
    String[] editors = { "TextEditor", "ImageEditor", "VideoEditor" };
    for (String e : editors) {
      totalSizeMap.put(e, 0L);
      countMap.put(e, 0);
    }

    // aggregate sizes and counts
    for (Document d : this.documents) {
      Editor ed = d.getEditor();
      if (ed != null) {
        String editorName = ed.getName();
        if (totalSizeMap.containsKey(editorName)) {
          totalSizeMap.put(editorName, totalSizeMap.get(editorName) + d.getSize());
          countMap.put(editorName, countMap.get(editorName) + 1);
        }
      }
    }

    // compute averages
    Map<String, Float> resultMap = new HashMap<>();
    for (String e : editors) {
      int cnt = countMap.get(e);
      if (cnt == 0) {
        resultMap.put(e, 0.0f);
      } else {
        long total = totalSizeMap.get(e);
        float avg = (float) total / (float) cnt;
        resultMap.put(e, avg);
      }
    }

    return resultMap;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Counts how many documents in the FileSystem were created strictly after a given date.
   * Algorithm:
   *   1. Validate that the parameter `date` is not null; otherwise throw IllegalArgumentException.
   *   2. Initialize counter = 0.
   *   3. For each Document d in this.documents:
   *        if d.createDate.isAfter(date) then counter = counter + 1
   *   4. Return counter.
   * Input:
   *   date : EDate – the reference creation date. Must be a valid date object; format follows the EDate specification (e.g., YYYY‑MM‑DD). The date can represent any past, present or future moment.
   * Output:
   *   int – the number of documents whose `createDate` is later than the supplied `date`.
   *   Returns 0 when no document satisfies the condition or the documents collection is empty.
   * Pre-condition:
   *   - `date` is not null.
   *   - The FileSystem's `documents` list is initialized.
   * Post-condition:
   *   The returned integer accurately reflects the count of documents with creation dates after the supplied date at the time of execution.
   * <!-- end-model-doc -->
   * @model dateRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int countDocumentsAfterDate(final Date date)
  {
    if (date == null) {
      throw new IllegalArgumentException("Parameter 'date' must not be null.");
    }

    int counter = 0;
    for (Document d : this.documents) {
      Date createDate = d.getCreateDate();
      if (createDate != null && createDate.after(date)) {
        counter++;
      }
    }
    return counter;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves a list of distinct author names whose documents are edited by the specified editor.
   * Algorithm:
   *   1. Validate that the parameter `editor` is not null; otherwise throw IllegalArgumentException.
   *   2. Initialise an empty Set<String> authorSet to guarantee uniqueness.
   *   3. For each Document d in this.documents:
   *        if d.editor == editor then
   *            authorSet.add(d.author)
   *   4. Convert authorSet to a List<String> preserving insertion order (or any order) and return it.
   * Input:
   *   editor : Editor – a reference to one of the three concrete editor instances (TextEditor, ImageEditor, VideoEditor). Must not be null.
   * Output:
   *   List<String> – a collection of unique author names (String) whose documents are associated with the supplied editor.
   *   Returns an empty list if no documents match the editor.
   * Pre-condition:
   *   - `editor` is a non‑null object that belongs to the FileSystem's `editors` collection.
   *   - The FileSystem's `documents` list is initialized.
   * Post-condition:
   *   The returned list contains no duplicate author names and includes exactly those authors for which at least one Document in the FileSystem references the given editor at the moment of invocation.
   * <!-- end-model-doc -->
   * @model editorRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> getAuthorsByEditor(final Editor editor)
  {
    if (editor == null) {
      throw new IllegalArgumentException("Parameter 'editor' must not be null.");
    }

    Set<String> authorSet = new HashSet<>();
    for (Document d : this.documents) {
      if (editor.equals(d.getEditor())) {
        String author = d.getAuthor();
        if (author != null) {
          authorSet.add(author);
        }
      }
    }

    // Convert the set to an EList (order does not matter)
    return new BasicEList<>(authorSet);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Produces a mapping from each editor type (TextEditor, ImageEditor, VideoEditor) to the number of documents associated with that editor in the FileSystem.
   * Algorithm:
   *   1. Create an empty map resultMap where key = String (editor name) and value = Integer (count).
   *   2. Initialise counts for the three known editors to 0:
   *        resultMap["TextEditor"] = 0
   *        resultMap["ImageEditor"] = 0
   *        resultMap["VideoEditor"] = 0
   *   3. For each Document d in this.documents:
   *        editorName = d.editor.name   // guaranteed to be one of the three names
   *        resultMap[editorName] = resultMap[editorName] + 1
   *   4. Return resultMap.
   * Input:
   *   None.
   * Output:
   *   EMap (implemented as Map<String, Integer>) – a map containing exactly three entries:
   *        "TextEditor" → count of TextEditor documents,
   *        "ImageEditor" → count of ImageEditor documents,
   *        "VideoEditor" → count of VideoEditor documents.
   *   If there are no documents, all counts are 0.
   * Pre-condition:
   *   - The FileSystem instance exists and its `documents` list is initialized (may be empty).
   *   - Every Document's `editor` reference points to an instance whose `name` matches one of the three supported editors.
   * Post-condition:
   *   The map reflects the exact number of documents per editor type at the moment of invocation.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Map<String, Integer> countDocumentsPerEditorType()
  {
    Map<String, Integer> resultMap = new HashMap<>();

    // initialise counts
    resultMap.put("TextEditor", 0);
    resultMap.put("ImageEditor", 0);
    resultMap.put("VideoEditor", 0);

    for (Document d : this.documents) {
      Editor ed = d.getEditor();
      if (ed != null) {
        String editorName = ed.getName();
        if (resultMap.containsKey(editorName)) {
          resultMap.put(editorName, resultMap.get(editorName) + 1);
        }
      }
    }

    return resultMap;
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { /* omitted */ }

} // FileSystem
171076 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../FileManager/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../FileManager/src-gen/edu/fs/
171189 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
171189 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - ----------
1. WARNING in D:\EclipseWorkspace\FileManager\src-gen\edu\fs\FileSystem.java (at line 23)
	import java.util.ArrayList;
	       ^^^^^^^^^^^^^^^^^^^
The import java.util.ArrayList is never used
----------
2. WARNING in D:\EclipseWorkspace\FileManager\src-gen\edu\fs\FileSystem.java (at line 26)
	import java.util.List;
	       ^^^^^^^^^^^^^^
The import java.util.List is never used
----------
2 problems (2 warnings)

171189 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
171189 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
171191 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample5.mwe2 启动完成
正在拷贝 src-gen/edu/fs 到 gpt-oss-120b/fs5...
拷贝完成！

======================================
所有任务完成！
======================================

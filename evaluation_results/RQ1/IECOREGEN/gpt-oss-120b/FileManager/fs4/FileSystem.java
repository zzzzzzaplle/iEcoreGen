/**
 * generated by Enhanced EcoreGen
 */
package edu.fs;

import java.util.Collection;
import java.util.Date;
import java.util.Map;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Set;
import java.util.List;
import org.eclipse.emf.common.util.BasicEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>File System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.fs.FileSystem#getDocuments <em>Documents</em>}</li>
 *   <li>{@link edu.fs.FileSystem#getEditors <em>Editors</em>}</li>
 * </ul>
 *
 * @see edu.fs.FsPackage#getFileSystem()
 * @model kind="class"
 * @generated
 */
public class FileSystem extends MinimalEObjectImpl.Container implements EObject
{
  /**
   * The cached value of the '{@link #getDocuments() <em>Documents</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getDocuments()
   * @generated
   * @ordered
   */
  protected EList<Document> documents;

  /**
   * The cached value of the '{@link #getEditors() <em>Editors</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getEditors()
   * @generated
   * @ordered
   */
  protected EList<Editor> editors;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected FileSystem()
  {
    super();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  protected EClass eStaticClass()
  {
    return FsPackage.Literals.FILE_SYSTEM;
  }

  /**
   * Returns the value of the '<em><b>Documents</b></em>' containment reference list.
   * The list contents are of type {@link edu.fs.Document}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Documents</em>' containment reference list.
   * @see edu.fs.FsPackage#getFileSystem_Documents()
   * @model containment="true"
   * @generated
   */
  public EList<Document> getDocuments()
  {
    if (documents == null)
    {
      documents = new EObjectContainmentEList<Document>(Document.class, this, FsPackage.FILE_SYSTEM__DOCUMENTS);
    }
    return documents;
  }

  /**
   * Returns the value of the '<em><b>Editors</b></em>' containment reference list.
   * The list contents are of type {@link edu.fs.Editor}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Editors</em>' containment reference list.
   * @see edu.fs.FsPackage#getFileSystem_Editors()
   * @model containment="true"
   * @generated
   */
  public EList<Editor> getEditors()
  {
    if (editors == null)
    {
      editors = new EObjectContainmentEList<Editor>(Editor.class, this, FsPackage.FILE_SYSTEM__EDITORS);
    }
    return editors;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns the sum of the sizes of all documents stored in the file system.
   * Algorithm:
   *   1. Initialise totalSize ← 0.
   *   2. FOR each doc IN getDocuments() DO
   *        totalSize ← totalSize + doc.size
   *      END FOR
   *   3. RETURN totalSize.
   * Input:
   *   - (none)
   * Output:
   *   - totalSize : int
   *       The total size in bytes (or the domain‑specific unit) of all documents.
   *       Guarantees: totalSize ≥ 0. Returns 0 when the document list is empty.
   * Pre-condition:
   *   - documents list is initialized (may be empty).
   * Post-condition:
   *   - The returned value equals the mathematical sum of doc.size for every doc in documents.
   *   - No modification of the file system state.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateTotalDocumentSize()
  {
    int totalSize = 0;
    for (Document doc : getDocuments()) {
      totalSize += doc.getSize();
    }
    return totalSize;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes, for each editor type, the average size of the documents that are
   *   edited with that editor. If an editor has no documents, its average is 0.0.
   * Algorithm:
   *   1. CREATE sumMap ← map<String, long> with keys "TextEditor","ImageEditor","VideoEditor", all values 0.
   *   2. CREATE countMap ← map<String, int> with same keys, all values 0.
   *   3. FOR each doc IN getDocuments() DO
   *        editorName ← doc.editor.getClass().getSimpleName()
   *        IF sumMap contains editorName THEN
   *            sumMap[editorName] ← sumMap[editorName] + doc.size
   *            countMap[editorName] ← countMap[editorName] + 1
   *        END IF
   *      END FOR
   *   4. CREATE avgMap ← empty map<String, double>.
   *   5. FOR each editorName IN sumMap.keys DO
   *        IF countMap[editorName] > 0 THEN
   *            avg ← sumMap[editorName] / countMap[editorName] as double
   *        ELSE
   *            avg ← 0.0
   *        END IF
   *        avgMap[editorName] ← avg
   *      END FOR
   *   6. RETURN avgMap.
   * Input:
   *   - (none)
   * Output:
   *   - avgMap : EMap<String, double>
   *       Keys: "TextEditor", "ImageEditor", "VideoEditor".
   *       Values: average document size for the corresponding editor; 0.0 when no documents exist.
   * Pre-condition:
   *   - documents list is initialized.
   * Post-condition:
   *   - For each editor e, avgMap[e] = ( Σ size of docs with editor e ) / (number of docs with editor e),
   *     or 0.0 if denominator is zero.
   *   - The file system state is unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Map<String, Float> findAverageSizePerEditor()
  {
    Map<String, Long> sumMap = new HashMap<>();
    Map<String, Integer> countMap = new HashMap<>();

    // initialise maps with the three editor types
    String[] editorTypes = { "TextEditor", "ImageEditor", "VideoEditor" };
    for (String type : editorTypes) {
      sumMap.put(type, 0L);
      countMap.put(type, 0);
    }

    // accumulate sums and counts
    for (Document doc : getDocuments()) {
      Editor editor = doc.getEditor();
      if (editor != null) {
        String editorName = editor.getClass().getSimpleName();
        if (sumMap.containsKey(editorName)) {
          sumMap.put(editorName, sumMap.get(editorName) + doc.getSize());
          countMap.put(editorName, countMap.get(editorName) + 1);
        }
      }
    }

    // compute averages
    Map<String, Float> avgMap = new HashMap<>();
    for (String editorName : sumMap.keySet()) {
      int count = countMap.get(editorName);
      float avg = (count > 0) ? (float) (sumMap.get(editorName) / (double) count) : 0.0f;
      avgMap.put(editorName, avg);
    }

    return avgMap;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Counts how many documents have a creation date later than the supplied date.
   * Algorithm:
   *   1. Validate that the argument `date` is not null.
   *   2. Initialise count ← 0.
   *   3. FOR each doc IN getDocuments() DO
   *        IF doc.createDate > date THEN
   *            count ← count + 1
   *        END IF
   *      END FOR
   *   4. RETURN count.
   * Input:
   *   - date : EDate
   *       The reference date. Must represent a valid calendar date.
   * Output:
   *   - count : int
   *       Number of documents whose createDate is after `date`. Guarantees count ≥ 0.
   * Pre-condition:
   *   - `date` is a valid, non‑null EDate instance.
   *   - documents list is initialized.
   * Post-condition:
   *   - The returned count equals the cardinality of { d ∈ documents | d.createDate > date }.
   *   - The file system remains unchanged.
   * <!-- end-model-doc -->
   * @model dateRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int countDocumentsAfterDate(final Date date)
  {
    if (date == null) {
      throw new IllegalArgumentException("date must not be null");
    }

    int count = 0;
    for (Document doc : getDocuments()) {
      Date createDate = doc.getCreateDate();
      if (createDate != null && createDate.after(date)) {
        count++;
      }
    }
    return count;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves a list of distinct author names whose documents are edited with the
   *   specified editor.
   * Algorithm:
   *   1. Validate that `editor` is not null and belongs to editors.
   *   2. CREATE authorSet ← empty Set<String>.
   *   3. FOR each doc IN getDocuments() DO
   *        IF doc.editor == editor THEN
   *            authorSet.add(doc.author)
   *        END IF
   *      END FOR
   *   4. CONVERT authorSet to a List<String> preserving any desired ordering (e.g., alphabetical).
   *   5. RETURN the list.
   * Input:
   *   - editor : Editor
   *       The concrete editor instance (TextEditor, ImageEditor or VideoEditor) for which authors are requested.
   * Output:
   *   - authors : List<String>
   *       A list of unique author names (strings). May be empty if no document uses the given editor.
   * Pre-condition:
   *   - `editor` is a non‑null reference to an Editor object that exists in editors.
   *   - documents and editors lists are initialized.
   * Post-condition:
   *   - The returned list contains exactly the distinct values of doc.author for all documents
   *     where doc.editor equals the supplied `editor`.
   *   - No modification of any Document, Editor, or the FileSystem occurs.
   * <!-- end-model-doc -->
   * @model editorRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> getAuthorsByEditor(final Editor editor)
  {
    if (editor == null) {
      throw new IllegalArgumentException("editor must not be null");
    }
    if (!getEditors().contains(editor)) {
      throw new IllegalArgumentException("editor does not belong to this FileSystem");
    }

    Set<String> authorSet = new HashSet<>();
    for (Document doc : getDocuments()) {
      if (editor.equals(doc.getEditor())) {
        String author = doc.getAuthor();
        if (author != null) {
          authorSet.add(author);
        }
      }
    }

    List<String> authorList = new ArrayList<>(authorSet);
    Collections.sort(authorList);
    return new BasicEList<>(authorList);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Provides a mapping from each editor type (TextEditor, ImageEditor, VideoEditor)
   *   to the number of documents that use that editor.
   * Algorithm:
   *   1. CREATE resultMap ← empty map<String, int>.
   *   2. FOR each editorType IN {"TextEditor","ImageEditor","VideoEditor"} DO
   *        resultMap[editorType] ← 0
   *      END FOR
   *   3. FOR each doc IN getDocuments() DO
   *        editorName ← doc.editor.getClass().getSimpleName()
   *        IF resultMap contains editorName THEN
   *            resultMap[editorName] ← resultMap[editorName] + 1
   *        END IF
   *      END FOR
   *   4. RETURN resultMap.
   * Input:
   *   - (none)
   * Output:
   *   - resultMap : EMap<String, int>
   *       Keys are exactly "TextEditor", "ImageEditor", "VideoEditor".
   *       Values are non‑negative integers indicating document counts.
   * Pre-condition:
   *   - documents list is initialized.
   * Post-condition:
   *   - For each editor type e, resultMap[e] equals the number of documents whose
   *     doc.editor is an instance of the corresponding concrete editor class.
   *   - No mutation of the file system occurs.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Map<String, Integer> countDocumentsPerEditorType()
  {
    Map<String, Integer> resultMap = new HashMap<>();
    String[] editorTypes = { "TextEditor", "ImageEditor", "VideoEditor" };
    for (String type : editorTypes) {
      resultMap.put(type, 0);
    }

    for (Document doc : getDocuments()) {
      Editor editor = doc.getEditor();
      if (editor != null) {
        String editorName = editor.getClass().getSimpleName();
        if (resultMap.containsKey(editorName)) {
          resultMap.put(editorName, resultMap.get(editorName) + 1);
        }
      }
    }

    return resultMap;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        return ((InternalEList<?>)getDocuments()).basicRemove(otherEnd, msgs);
      case FsPackage.FILE_SYSTEM__EDITORS:
        return ((InternalEList<?>)getEditors()).basicRemove(otherEnd, msgs);
    }
    return super.eInverseRemove(otherEnd, featureID, msgs);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        return getDocuments();
      case FsPackage.FILE_SYSTEM__EDITORS:
        return getEditors();
    }
    return super.eGet(featureID, resolve, coreType);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        getDocuments().clear();
        getDocuments().addAll((Collection<? extends Document>)newValue);
        return;
      case FsPackage.FILE_SYSTEM__EDITORS:
        getEditors().clear();
        getEditors().addAll((Collection<? extends Editor>)newValue);
        return;
    }
    super.eSet(featureID, newValue);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public void eUnset(int featureID)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        getDocuments().clear();
        return;
      case FsPackage.FILE_SYSTEM__EDITORS:
        getEditors().clear();
        return;
    }
    super.eUnset(featureID);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public boolean eIsSet(int featureID)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        return documents != null && !documents.isEmpty();
      case FsPackage.FILE_SYSTEM__EDITORS:
        return editors != null && !editors.isEmpty();
    }
    return super.eIsSet(featureID);
  }

} // FileSystem

/**
 * generated by Enhanced EcoreGen
 */
package edu.fs;

import java.util.Collection;
import java.util.Date;
import java.util.Map;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;
import org.eclipse.emf.common.util.BasicEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>File System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.fs.FileSystem#getDocuments <em>Documents</em>}</li>
 *   <li>{@link edu.fs.FileSystem#getEditors <em>Editors</em>}</li>
 * </ul>
 *
 * @see edu.fs.FsPackage#getFileSystem()
 * @model kind="class"
 * @generated
 */
public class FileSystem extends MinimalEObjectImpl.Container implements EObject
{
  /**
   * The cached value of the '{@link #getDocuments() <em>Documents</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getDocuments()
   * @generated
   * @ordered
   */
  protected EList<Document> documents;

  /**
   * The cached value of the '{@link #getEditors() <em>Editors</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getEditors()
   * @generated
   * @ordered
   */
  protected EList<Editor> editors;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected FileSystem()
  {
    super();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  protected EClass eStaticClass()
  {
    return FsPackage.Literals.FILE_SYSTEM;
  }

  /**
   * Returns the value of the '<em><b>Documents</b></em>' containment reference list.
   * The list contents are of type {@link edu.fs.Document}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Documents</em>' containment reference list.
   * @see edu.fs.FsPackage#getFileSystem_Documents()
   * @model containment="true"
   * @generated
   */
  public EList<Document> getDocuments()
  {
    if (documents == null)
    {
      documents = new EObjectContainmentEList<Document>(Document.class, this, FsPackage.FILE_SYSTEM__DOCUMENTS);
    }
    return documents;
  }

  /**
   * Returns the value of the '<em><b>Editors</b></em>' containment reference list.
   * The list contents are of type {@link edu.fs.Editor}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Editors</em>' containment reference list.
   * @see edu.fs.FsPackage#getFileSystem_Editors()
   * @model containment="true"
   * @generated
   */
  public EList<Editor> getEditors()
  {
    if (editors == null)
    {
      editors = new EObjectContainmentEList<Editor>(Editor.class, this, FsPackage.FILE_SYSTEM__EDITORS);
    }
    return editors;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes the total size (in bytes) of all documents stored in the file system.
   * Algorithm:
   *   1. Initialize totalSize ← 0.
   *   2. For each Document d in this.documents do
   *        totalSize ← totalSize + d.size
   *   3. Return totalSize.
   * Input:
   *   None.
   * Output:
   *   int – the sum of the `size` field of all Document objects.
   *   If the file system contains no documents, the returned value is 0.
   * Pre-condition:
   *   - The FileSystem instance exists and its `documents` collection is initialized (may be empty).
   * Post-condition:
   *   - The returned integer equals Σ d.size for all d ∈ documents.
   *   - The internal state of the FileSystem is unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateTotalDocumentSize()
  {
    int totalSize = 0;
    for (Document d : getDocuments()) {
      totalSize += d.getSize();
    }
    return totalSize;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Calculates the average size of documents for each editor type (Text, Image, Video).
   * Algorithm:
   *   1. Create two auxiliary maps:
   *        sumMap   : Map<String, Long>   // cumulative size per editor
   *        countMap : Map<String, Integer>// document count per editor
   *   2. Initialise both maps with keys for all editors and values 0.
   *   3. For each Document d in this.documents do
   *        editorName ← d.editor.name
   *        sumMap[editorName]   ← sumMap[editorName] + d.size
   *        countMap[editorName] ← countMap[editorName] + 1
   *   4. Create resultMap : Map<String, Double>.
   *   5. For each editorName in sumMap.keys do
   *        if countMap[editorName] == 0 then
   *            resultMap[editorName] ← 0.0
   *        else
   *            resultMap[editorName] ← sumMap[editorName] / countMap[editorName] as double
   *   6. Return resultMap.
   * Input:
   *   None.
   * Output:
   *   EMap (implemented as Map<String, Double>) – each key is an editor name
   *   ("TextEditor", "ImageEditor", "VideoEditor") and the value is the average
   *   document size for that editor. If an editor has no documents, its average is 0.0.
   * Pre-condition:
   *   - The FileSystem’s `documents` list is initialized.
   *   - Each Document has a valid, non‑null `editor` with a name matching one of the three editors.
   * Post-condition:
   *   - For every editor e: resultMap[e] =
   *        ( Σ d.size for d ∈ documents where d.editor.name = e ) / (count of such documents),
   *     or 0.0 if the count is zero.
   *   - No modifications are made to any Document or the FileSystem.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Map<String, Float> findAverageSizePerEditor()
  {
    Map<String, Long> sumMap = new HashMap<>();
    Map<String, Integer> countMap = new HashMap<>();

    // initialise maps with all editor names present in the system
    for (Editor editor : getEditors()) {
      String name = editor.getName();
      sumMap.put(name, 0L);
      countMap.put(name, 0);
    }

    // aggregate sizes and counts
    for (Document d : getDocuments()) {
      Editor editor = d.getEditor();
      if (editor == null) {
        continue; // safeguard, though model states non‑null
      }
      String editorName = editor.getName();
      // ensure the maps contain the key (in case a document references an editor not in editors list)
      sumMap.putIfAbsent(editorName, 0L);
      countMap.putIfAbsent(editorName, 0);

      sumMap.put(editorName, sumMap.get(editorName) + d.getSize());
      countMap.put(editorName, countMap.get(editorName) + 1);
    }

    Map<String, Float> resultMap = new HashMap<>();
    for (String editorName : sumMap.keySet()) {
      int count = countMap.get(editorName);
      if (count == 0) {
        resultMap.put(editorName, 0.0f);
      } else {
        float avg = (float) (sumMap.get(editorName) / (double) count);
        resultMap.put(editorName, avg);
      }
    }
    return resultMap;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Counts how many documents have a creation date later than a specified date.
   * Algorithm:
   *   1. Validate that `date` is not null; otherwise throw IllegalArgumentException.
   *   2. Initialize counter ← 0.
   *   3. For each Document d in this.documents do
   *        if d.createDate.isAfter(date) then
   *            counter ← counter + 1
   *   4. Return counter.
   * Input:
   *   - date : EDate – the reference date. Must be a valid EDate instance.
   * Output:
   *   int – number of documents whose `createDate` is strictly after the supplied `date`.
   * Pre-condition:
   *   - `date` is a non‑null EDate object.
   * Post-condition:
   *   - Returned value equals |{ d ∈ documents | d.createDate > date }|.
   *   - No modification to any Document or the FileSystem.
   * <!-- end-model-doc -->
   * @model dateRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int countDocumentsAfterDate(final Date date)
  {
    if (date == null) {
      throw new IllegalArgumentException("Parameter 'date' must not be null.");
    }
    int counter = 0;
    for (Document d : getDocuments()) {
      Date docDate = d.getCreateDate();
      if (docDate != null && docDate.after(date)) {
        counter++;
      }
    }
    return counter;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves a list of distinct author names whose documents are associated with a given editor.
   * Algorithm:
   *   1. Validate that `editor` is not null; otherwise throw IllegalArgumentException.
   *   2. Initialise an empty Set<String> authorSet.
   *   3. For each Document d in this.documents do
   *        if d.editor == editor then
   *            authorSet.add(d.author)
   *   4. Convert authorSet to a List<String> preserving any order (e.g., insertion order).
   *   5. Return the list.
   * Input:
   *   - editor : Editor – the editor whose authors are to be retrieved. Must be an instance
   *     of one of the concrete editor classes (TextEditor, ImageEditor, VideoEditor).
   * Output:
   *   List<String> – a collection of unique author names (no duplicates) whose documents use the
   *   specified editor. If no such documents exist, the list is empty.
   * Pre-condition:
   *   - `editor` is a non‑null reference to a concrete Editor object that exists in this.editors
   *     (or at least matches the reference used inside Document objects).
   * Post-condition:
   *   - Returned list contains exactly the set { d.author | d ∈ documents ∧ d.editor == editor }.
   *   - The internal state of the FileSystem and its Documents remains unchanged.
   * <!-- end-model-doc -->
   * @model editorRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> getAuthorsByEditor(final Editor editor)
  {
    if (editor == null) {
      throw new IllegalArgumentException("Parameter 'editor' must not be null.");
    }
    Set<String> authorSet = new HashSet<>();
    for (Document d : getDocuments()) {
      if (editor.equals(d.getEditor())) {
        String author = d.getAuthor();
        if (author != null) {
          authorSet.add(author);
        }
      }
    }
    // BasicEList has a constructor that accepts a Collection
    return new BasicEList<>(authorSet);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Produces a mapping from each editor type (Text, Image, Video) to the count of documents
   *   that are assigned to that editor.
   * Algorithm:
   *   1. Create an empty map resultMap : Map<String, Integer>.
   *   2. Initialise resultMap entries for all known editor types with 0:
   *        resultMap["TextEditor"]  ← 0
   *        resultMap["ImageEditor"] ← 0
   *        resultMap["VideoEditor"] ← 0
   *   3. For each Document d in this.documents do
   *        editorName ← d.editor.name   // assumed to be one of the three names above
   *        current ← resultMap[editorName]
   *        resultMap[editorName] ← current + 1
   *   4. Return resultMap.
   * Input:
   *   None.
   * Output:
   *   EMap (implemented as Map<String, Integer>) – keys are editor class names
   *   ("TextEditor", "ImageEditor", "VideoEditor") and values are the corresponding
   *   document counts (≥ 0). If no documents exist for a type, its count is 0.
   * Pre-condition:
   *   - The FileSystem instance has its `documents` list initialized.
   *   - Each Document in the list has a non‑null `editor` reference whose `name`
   *     matches one of the three supported editor names.
   * Post-condition:
   *   - Returned map reflects the exact distribution of documents across editor types.
   *   - The FileSystem state remains unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Map<String, Integer> countDocumentsPerEditorType()
  {
    Map<String, Integer> resultMap = new HashMap<>();
    // initialise known editor types
    resultMap.put("TextEditor", 0);
    resultMap.put("ImageEditor", 0);
    resultMap.put("VideoEditor", 0);

    for (Document d : getDocuments()) {
      Editor editor = d.getEditor();
      if (editor == null) {
        continue; // safety, though model says non‑null
      }
      String name = editor.getName();
      // only consider known types; unknown types are ignored
      if (resultMap.containsKey(name)) {
        resultMap.put(name, resultMap.get(name) + 1);
      }
    }
    return resultMap;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        return ((InternalEList<?>)getDocuments()).basicRemove(otherEnd, msgs);
      case FsPackage.FILE_SYSTEM__EDITORS:
        return ((InternalEList<?>)getEditors()).basicRemove(otherEnd, msgs);
    }
    return super.eInverseRemove(otherEnd, featureID, msgs);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        return getDocuments();
      case FsPackage.FILE_SYSTEM__EDITORS:
        return getEditors();
    }
    return super.eGet(featureID, resolve, coreType);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        getDocuments().clear();
        getDocuments().addAll((Collection<? extends Document>)newValue);
        return;
      case FsPackage.FILE_SYSTEM__EDITORS:
        getEditors().clear();
        getEditors().addAll((Collection<? extends Editor>)newValue);
        return;
    }
    super.eSet(featureID, newValue);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public void eUnset(int featureID)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        getDocuments().clear();
        return;
      case FsPackage.FILE_SYSTEM__EDITORS:
        getEditors().clear();
        return;
    }
    super.eUnset(featureID);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public boolean eIsSet(int featureID)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        return documents != null && !documents.isEmpty();
      case FsPackage.FILE_SYSTEM__EDITORS:
        return editors != null && !editors.isEmpty();
    }
    return super.eIsSet(featureID);
  }

} // FileSystem

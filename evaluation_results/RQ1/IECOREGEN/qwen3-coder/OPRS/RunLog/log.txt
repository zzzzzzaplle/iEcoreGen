   *   6. If all reviews have the same grade (either ACCEPT or REJECT), return true.
   * Input: None
   * Output: A boolean value. True if all reviews are either exclusively ACCEPT or exclusively REJECT, false otherwise.
   * Pre-condition: The paper's reviews list is initialized (can be empty).
   * Post-condition: Returns the evaluation result without modifying the system state.
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean isAllReviewsPositive()
  {
    EList<ReviewAssignment> reviewList = getReviews();
    if (reviewList.isEmpty()) {
      return false;
    }
    
    Grade firstGrade = reviewList.get(0).getGrade();
    if (firstGrade == Grade.UNDECIDED) {
      return false;
    }
    
    for (ReviewAssignment review : reviewList) {
      if (review.getGrade() != firstGrade || review.getGrade() == Grade.UNDECIDED) {
        return false;
      }
    }
    
    return true;
  }

  public double calculateAcceptanceRate()
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Paper
48745 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../OPRS/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../OPRS/src-gen/edu/conference/
49446 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
49446 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
49446 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
49447 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
49453 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample1.mwe2 启动完成
正在拷贝 src-gen/edu/conference 到 qwen3-coder/conference1...
拷贝完成！

======================================
正在启动 sample2.mwe2...
======================================
49734 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
49807 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project OPRS at 'file:/D:/EclipseWorkspace/OPRS/'
49810 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
49816 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@4c79ca55
49816 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
49818 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
49819 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
To help the program chair, we are planning to develop a computer-assisted review system. The system will be available to users who can be authors, reviewers, and co-chairs. Each user has a name. Papers are known by the title and whether they are research papers or experience report papers. The paper is reviewed by at least three reviewers. On the other side, the authors can submit as many papers as they want. When a reviewer logs in, she can consult the list of papers that have been assigned to her for review, and submit reviews for each of those papers. Each review has feedback as well as grade that can be Accept or Reject. A final decision is made by the chair for each paper.
functional requirement：
+ Calculate the number of unsubmitted reviews for a given reviewer. Return 0 if all reviews are submitted by the reviewer.

+ Before the chair makes the final decision, check if all reviews for a paper are either exclusively Accept or exclusively Reject. Return a boolean value.

+ Count the total number of papers submitted by an author.

+ Calculate the acceptance rate of papers for an author. Example: If an author submitted 10 papers with 6 accepted, return 0.60.

+ Convert a reviewer's historical grades (Accept = 1, Reject = 0) into a numerical average score between 0.0 and 1.0. Example: 
```

# Class Diagram
```plantuml
@startuml

title conference Model

class Author {
    papers : List<Paper>
    calculateAcceptanceRate() : double
    countSubmittedPapers() : int
    findAuthorsWithPositiveReviews() : List<Author>
    submitPaper(paper : Paper) : void
}
class CoChair {
    makeFinalDecision(paper : Paper, decision : Grade) : int
}
class Paper {
    decision : Grade
    title : String
    type : PaperType
    reviews : List<ReviewAssignment>
    calculateAcceptanceRate() : double
    isAllReviewsPositive() : boolean
}
class ReviewAssignment {
    feedback : String
    grade : Grade
    paper : Paper
}
class Reviewer {
    assignments : List<ReviewAssignment>
    calculateAcceptanceProportion() : double
    calculateUnsubmittedReviews() : int
}
class User {
    name : String
    roles : List<UserRole>
}
abstract class UserRole {
}
enum Grade {
    UNDECIDED
    ACCEPT
    REJECT
}
enum PaperType {
    RESEARCH
    EXPERIENCE
}

Author --|> UserRole
Author --> "*" Paper : papers
CoChair --|> UserRole
Paper --> "*" ReviewAssignment : reviews  'opposite: paper
ReviewAssignment --> Paper : paper  'opposite: reviews
Reviewer --|> UserRole
Reviewer --> "*" ReviewAssignment : assignments
User *-- "*" UserRole : roles
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

59154 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@c6c84fa (name: calculateAcceptanceRate) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates the acceptance rate of papers for this author.
Algorithm:
  1. Initialize counters: totalPapers = 0, acceptedPapers = 0.
  2. For each paper in the papers list:
     a. Increment totalPapers.
     b. If the paper's decision is ACCEPT, increment acceptedPapers.
  3. If totalPapers is 0, return 0.0.
  4. Otherwise, return acceptedPapers / totalPapers as a double rounded to two decimal places.
Input: None
Output: A double representing the acceptance rate, formatted to two decimal places. Value range: [0.00, 1.00]
Pre-condition: The author exists and may have submitted papers.
Post-condition: Returns the proportion of accepted papers, or 0.0 if no papers were submitted., org.eclipse.emf.ecore.impl.EOperationImpl@12a0d249 (name: isAllReviewsPositive) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Checks whether all reviews for this paper are either exclusively Accept or exclusively Reject.
Algorithm:
  1. If there are no reviews, return false.
  2. Retrieve the first review's grade.
  3. If the first grade is UNDECIDED, return false.
  4. Iterate over all reviews and compare each grade with the first grade.
  5. If any grade differs, return false.
  6. Return true if all grades match the first one and are not UNDECIDED.
Input: None
Output: A boolean indicating whether all reviews are exclusively Accept or Reject.
Pre-condition: The paper exists and may have associated reviews.
Post-condition: Returns true if all non-undecided reviews are either all Accept or all Reject; otherwise false., org.eclipse.emf.ecore.impl.EOperationImpl@70ce2fb2 (name: calculateAcceptanceProportion) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Converts a reviewer's historical grades into a numerical average score between 0.0 and 1.0.
Algorithm:
  1. Initialize variables sum = 0 and count = 0.
  2. Iterate over each ReviewAssignment in assignments:
     a. If grade is ACCEPT, add 1 to sum.
     b. If grade is REJECT, add 0 to sum.
     c. Increment count for each non-UNDECIDED grade.
  3. If count is zero, return 0.0.
  4. Otherwise, return sum / count as a double, rounded to two decimal places.
Input: None
Output: A double value between 0.0 and 1.0 indicating the average score. Value range: [0.00, 1.00]
Pre-condition: The reviewer exists and may have review assignments.
Post-condition: Returns the average of the reviewer's historical grades (Accept = 1, Reject = 0), or 0.0 if no valid grades., org.eclipse.emf.ecore.impl.EOperationImpl@33fec21 (name: calculateUnsubmittedReviews) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates the number of unsubmitted reviews for a given reviewer. Returns 0 if all reviews are submitted.
Algorithm:
  1. Initialize a counter unsubmittedCount to 0.
  2. Iterate through each ReviewAssignment in the assignments list.
  3. If the grade of the ReviewAssignment is UNDECIDED, increment unsubmittedCount.
  4. Return unsubmittedCount.
Input: None
Output: An integer representing the number of unsubmitted reviews. Value range: [0, n], where n is the total number of assigned reviews.
Pre-condition: The reviewer exists and has review assignments.
Post-condition: The method returns a non-negative integer indicating the count of unsubmitted reviews., org.eclipse.emf.ecore.impl.EOperationImpl@3c62be3c (name: countSubmittedPapers) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Counts the total number of papers submitted by this author.
Algorithm:
  1. Return the size of the papers list.
Input: None
Output: An integer representing the total number of submitted papers. Value range: [0, ∞)
Pre-condition: The author exists.
Post-condition: The number of papers authored by this author is returned.}
59157 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
59190 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../OPRS/src-gen/edu/conference
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.conference;

import java.util.Collection;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.util.EObjectResolvingEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Author</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.conference.Author#getPapers <em>Papers</em>}</li>
 * </ul>
 *
 * @see edu.conference.ConferencePackage#getAuthor()
 * @model kind="class"
 * @generated
 */
public class Author extends UserRole
{
  protected EList<Paper> papers;

  protected Author()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Paper> getPapers()
  { ... /* omitted */ }

  public void submitPaper(Paper paper)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the total number of papers submitted by this author.
   * Algorithm:
   *   1. Return the size of the papers list.
   * Input: None
   * Output: An integer representing the total number of submitted papers. Value range: [0, ∞)
   * Pre-condition: The author exists.
   * Post-condition: The number of papers authored by this author is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int countSubmittedPapers()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the acceptance rate of papers for this author.
   * Algorithm:
   *   1. Initialize counters: totalPapers = 0, acceptedPapers = 0.
   *   2. For each paper in the papers list:
   *      a. Increment totalPapers.
   *      b. If the paper's decision is ACCEPT, increment acceptedPapers.
   *   3. If totalPapers is 0, return 0.0.
   *   4. Otherwise, return acceptedPapers / totalPapers as a double rounded to two decimal places.
   * Input: None
   * Output: A double representing the acceptance rate, formatted to two decimal places. Value range: [0.00, 1.00]
   * Pre-condition: The author exists and may have submitted papers.
   * Post-condition: Returns the proportion of accepted papers, or 0.0 if no papers were submitted.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateAcceptanceRate()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  public EList<Author> findAuthorsWithPositiveReviews()
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Author
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `UserRole` contains the following methods.
  + Instance creation: Can only be used as an abstract type
- Class `Paper` contains the following methods.
  + Instance creation: Use `ConferenceFactory.eINSTANCE.createPaper()`
  + Public methods: public boolean isAllReviewsPositive(), public double calculateAcceptanceRate()
  + Getter methods: public String getTitle(), public PaperType getType(), public Grade getDecision(), public EList<ReviewAssignment> getReviews()
  + Setter methods: public void setTitle(String newTitle), public void setType(PaperType newType), public void setDecision(Grade newDecision)
- Class `Author` contains the following methods.
  + Instance creation: Use `ConferenceFactory.eINSTANCE.createAuthor()`
  + Public methods: public void submitPaper(Paper paper), public int countSubmittedPapers(), public double calculateAcceptanceRate(), public EList<Author> findAuthorsWithPositiveReviews()
  + Getter methods: public EList<Paper> getPapers()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.conference;

import java.text.DecimalFormat;
import java.util.Collection;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.util.EObjectResolvingEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Author</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.conference.Author#getPapers <em>Papers</em>}</li>
 * </ul>
 *
 * @see edu.conference.ConferencePackage#getAuthor()
 * @model kind="class"
 * @generated
 */
public class Author extends UserRole
{
  protected EList<Paper> papers;

  protected Author()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Paper> getPapers()
  { ... /* omitted */ }

  public void submitPaper(Paper paper)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the total number of papers submitted by this author.
   * Algorithm:
   *   1. Return the size of the papers list.
   * Input: None
   * Output: An integer representing the total number of submitted papers. Value range: [0, ∞)
   * Pre-condition: The author exists.
   * Post-condition: The number of papers authored by this author is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int countSubmittedPapers()
  {
    return getPapers().size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the acceptance rate of papers for this author.
   * Algorithm:
   *   1. Initialize counters: totalPapers = 0, acceptedPapers = 0.
   *   2. For each paper in the papers list:
   *      a. Increment totalPapers.
   *      b. If the paper's decision is ACCEPT, increment acceptedPapers.
   *   3. If totalPapers is 0, return 0.0.
   *   4. Otherwise, return acceptedPapers / totalPapers as a double rounded to two decimal places.
   * Input: None
   * Output: A double representing the acceptance rate, formatted to two decimal places. Value range: [0.00, 1.00]
   * Pre-condition: The author exists and may have submitted papers.
   * Post-condition: Returns the proportion of accepted papers, or 0.0 if no papers were submitted.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateAcceptanceRate()
  {
    int totalPapers = 0;
    int acceptedPapers = 0;
    
    for (Paper paper : getPapers()) {
      totalPapers++;
      if (paper.getDecision() != null && paper.getDecision().getName().equals("ACCEPT")) {
        acceptedPapers++;
      }
    }
    
    if (totalPapers == 0) {
      return 0.0;
    }
    
    double rate = (double) acceptedPapers / totalPapers;
    // Round to two decimal places
    rate = Math.round(rate * 100.0) / 100.0;
    return rate;
  }

  public EList<Author> findAuthorsWithPositiveReviews()
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Author
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.conference;

import java.util.Collection;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.util.EObjectResolvingEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Reviewer</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.conference.Reviewer#getAssignments <em>Assignments</em>}</li>
 * </ul>
 *
 * @see edu.conference.ConferencePackage#getReviewer()
 * @model kind="class"
 * @generated
 */
public class Reviewer extends UserRole
{
  protected EList<ReviewAssignment> assignments;

  protected Reviewer()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<ReviewAssignment> getAssignments()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the number of unsubmitted reviews for a given reviewer. Returns 0 if all reviews are submitted.
   * Algorithm:
   *   1. Initialize a counter unsubmittedCount to 0.
   *   2. Iterate through each ReviewAssignment in the assignments list.
   *   3. If the grade of the ReviewAssignment is UNDECIDED, increment unsubmittedCount.
   *   4. Return unsubmittedCount.
   * Input: None
   * Output: An integer representing the number of unsubmitted reviews. Value range: [0, n], where n is the total number of assigned reviews.
   * Pre-condition: The reviewer exists and has review assignments.
   * Post-condition: The method returns a non-negative integer indicating the count of unsubmitted reviews.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int calculateUnsubmittedReviews()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Converts a reviewer's historical grades into a numerical average score between 0.0 and 1.0.
   * Algorithm:
   *   1. Initialize variables sum = 0 and count = 0.
   *   2. Iterate over each ReviewAssignment in assignments:
   *      a. If grade is ACCEPT, add 1 to sum.
   *      b. If grade is REJECT, add 0 to sum.
   *      c. Increment count for each non-UNDECIDED grade.
   *   3. If count is zero, return 0.0.
   *   4. Otherwise, return sum / count as a double, rounded to two decimal places.
   * Input: None
   * Output: A double value between 0.0 and 1.0 indicating the average score. Value range: [0.00, 1.00]
   * Pre-condition: The reviewer exists and may have review assignments.
   * Post-condition: Returns the average of the reviewer's historical grades (Accept = 1, Reject = 0), or 0.0 if no valid grades.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateAcceptanceProportion()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Reviewer
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `UserRole` contains the following methods.
  + Instance creation: Can only be used as an abstract type
- Class `ReviewAssignment` contains the following methods.
  + Instance creation: Use `ConferenceFactory.eINSTANCE.createReviewAssignment()`
  + Getter methods: public String getFeedback(), public Grade getGrade(), public Paper getPaper()
  + Setter methods: public void setFeedback(String newFeedback), public void setGrade(Grade newGrade), public void setPaper(Paper newPaper)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.conference;

import java.text.DecimalFormat;
import java.util.Collection;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.util.EObjectResolvingEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Reviewer</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.conference.Reviewer#getAssignments <em>Assignments</em>}</li>
 * </ul>
 *
 * @see edu.conference.ConferencePackage#getReviewer()
 * @model kind="class"
 * @generated
 */
public class Reviewer extends UserRole
{
  protected EList<ReviewAssignment> assignments;

  protected Reviewer()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<ReviewAssignment> getAssignments()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the number of unsubmitted reviews for a given reviewer. Returns 0 if all reviews are submitted.
   * Algorithm:
   *   1. Initialize a counter unsubmittedCount to 0.
   *   2. Iterate through each ReviewAssignment in the assignments list.
   *   3. If the grade of the ReviewAssignment is UNDECIDED, increment unsubmittedCount.
   *   4. Return unsubmittedCount.
   * Input: None
   * Output: An integer representing the number of unsubmitted reviews. Value range: [0, n], where n is the total number of assigned reviews.
   * Pre-condition: The reviewer exists and has review assignments.
   * Post-condition: The method returns a non-negative integer indicating the count of unsubmitted reviews.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateUnsubmittedReviews()
  {
    int unsubmittedCount = 0;
    for (ReviewAssignment assignment : getAssignments()) {
      if (assignment.getGrade() == Grade.UNDECIDED) {
        unsubmittedCount++;
      }
    }
    return unsubmittedCount;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Converts a reviewer's historical grades into a numerical average score between 0.0 and 1.0.
   * Algorithm:
   *   1. Initialize variables sum = 0 and count = 0.
   *   2. Iterate over each ReviewAssignment in assignments:
   *      a. If grade is ACCEPT, add 1 to sum.
   *      b. If grade is REJECT, add 0 to sum.
   *      c. Increment count for each non-UNDECIDED grade.
   *   3. If count is zero, return 0.0.
   *   4. Otherwise, return sum / count as a double, rounded to two decimal places.
   * Input: None
   * Output: A double value between 0.0 and 1.0 indicating the average score. Value range: [0.00, 1.00]
   * Pre-condition: The reviewer exists and may have review assignments.
   * Post-condition: Returns the average of the reviewer's historical grades (Accept = 1, Reject = 0), or 0.0 if no valid grades.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateAcceptanceProportion()
  {
    int sum = 0;
    int count = 0;
    
    for (ReviewAssignment assignment : getAssignments()) {
      Grade grade = assignment.getGrade();
      if (grade != Grade.UNDECIDED) {
        if (grade == Grade.ACCEPT) {
          sum += 1;
        } else if (grade == Grade.REJECT) {
          sum += 0;
        }
        count++;
      }
    }
    
    if (count == 0) {
      return 0.0;
    }
    
    double average = (double) sum / count;
    // Round to two decimal places
    return Math.round(average * 100.0) / 100.0;
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Reviewer
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.conference;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectWithInverseResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Paper</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.conference.Paper#getTitle <em>Title</em>}</li>
 *   <li>{@link edu.conference.Paper#getType <em>Type</em>}</li>
 *   <li>{@link edu.conference.Paper#getDecision <em>Decision</em>}</li>
 *   <li>{@link edu.conference.Paper#getReviews <em>Reviews</em>}</li>
 * </ul>
 *
 * @see edu.conference.ConferencePackage#getPaper()
 * @model kind="class"
 * @generated
 */
public class Paper extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String TITLE_EDEFAULT = null;

  protected String title = TITLE_EDEFAULT;

  protected static final PaperType TYPE_EDEFAULT = PaperType.RESEARCH;

  protected PaperType type = TYPE_EDEFAULT;

  protected static final Grade DECISION_EDEFAULT = Grade.UNDECIDED;

  protected Grade decision = DECISION_EDEFAULT;

  protected EList<ReviewAssignment> reviews;

  protected Paper()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getTitle()
  { ... /* omitted */ }

  public void setTitle(String newTitle)
  { ... /* omitted */ }

  public PaperType getType()
  { ... /* omitted */ }

  public void setType(PaperType newType)
  { ... /* omitted */ }

  public Grade getDecision()
  { ... /* omitted */ }

  public void setDecision(Grade newDecision)
  { ... /* omitted */ }

  public EList<ReviewAssignment> getReviews()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Checks whether all reviews for this paper are either exclusively Accept or exclusively Reject.
   * Algorithm:
   *   1. If there are no reviews, return false.
   *   2. Retrieve the first review's grade.
   *   3. If the first grade is UNDECIDED, return false.
   *   4. Iterate over all reviews and compare each grade with the first grade.
   *   5. If any grade differs, return false.
   *   6. Return true if all grades match the first one and are not UNDECIDED.
   * Input: None
   * Output: A boolean indicating whether all reviews are exclusively Accept or Reject.
   * Pre-condition: The paper exists and may have associated reviews.
   * Post-condition: Returns true if all non-undecided reviews are either all Accept or all Reject; otherwise false.
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean isAllReviewsPositive()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  public double calculateAcceptanceRate()
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Paper
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `ReviewAssignment` contains the following methods.
  + Instance creation: Use `ConferenceFactory.eINSTANCE.createReviewAssignment()`
  + Getter methods: public String getFeedback(), public Grade getGrade(), public Paper getPaper()
  + Setter methods: public void setFeedback(String newFeedback), public void setGrade(Grade newGrade), public void setPaper(Paper newPaper)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.conference;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectWithInverseResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Paper</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.conference.Paper#getTitle <em>Title</em>}</li>
 *   <li>{@link edu.conference.Paper#getType <em>Type</em>}</li>
 *   <li>{@link edu.conference.Paper#getDecision <em>Decision</em>}</li>
 *   <li>{@link edu.conference.Paper#getReviews <em>Reviews</em>}</li>
 * </ul>
 *
 * @see edu.conference.ConferencePackage#getPaper()
 * @model kind="class"
 * @generated
 */
public class Paper extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String TITLE_EDEFAULT = null;

  protected String title = TITLE_EDEFAULT;

  protected static final PaperType TYPE_EDEFAULT = PaperType.RESEARCH;

  protected PaperType type = TYPE_EDEFAULT;

  protected static final Grade DECISION_EDEFAULT = Grade.UNDECIDED;

  protected Grade decision = DECISION_EDEFAULT;

  protected EList<ReviewAssignment> reviews;

  protected Paper()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getTitle()
  { ... /* omitted */ }

  public void setTitle(String newTitle)
  { ... /* omitted */ }

  public PaperType getType()
  { ... /* omitted */ }

  public void setType(PaperType newType)
  { ... /* omitted */ }

  public Grade getDecision()
  { ... /* omitted */ }

  public void setDecision(Grade newDecision)
  { ... /* omitted */ }

  public EList<ReviewAssignment> getReviews()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Checks whether all reviews for this paper are either exclusively Accept or exclusively Reject.
   * Algorithm:
   *   1. If there are no reviews, return false.
   *   2. Retrieve the first review's grade.
   *   3. If the first grade is UNDECIDED, return false.
   *   4. Iterate over all reviews and compare each grade with the first grade.
   *   5. If any grade differs, return false.
   *   6. Return true if all grades match the first one and are not UNDECIDED.
   * Input: None
   * Output: A boolean indicating whether all reviews are exclusively Accept or Reject.
   * Pre-condition: The paper exists and may have associated reviews.
   * Post-condition: Returns true if all non-undecided reviews are either all Accept or all Reject; otherwise false.
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean isAllReviewsPositive()
  {
    EList<ReviewAssignment> reviewList = getReviews();
    if (reviewList.isEmpty()) {
      return false;
    }

    Grade firstGrade = reviewList.get(0).getGrade();
    if (firstGrade == Grade.UNDECIDED) {
      return false;
    }

    for (ReviewAssignment review : reviewList) {
      if (review.getGrade() != firstGrade) {
        return false;
      }
    }

    return true;
  }

  public double calculateAcceptanceRate()
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Paper
95184 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../OPRS/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../OPRS/src-gen/edu/conference/
95445 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
95445 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - ----------
1. WARNING in D:\EclipseWorkspace\OPRS\src-gen\edu\conference\Author.java (at line 13)
	import java.text.DecimalFormat;
	       ^^^^^^^^^^^^^^^^^^^^^^^
The import java.text.DecimalFormat is never used
----------
----------
2. WARNING in D:\EclipseWorkspace\OPRS\src-gen\edu\conference\Paper.java (at line 22)
	import org.eclipse.emf.common.util.BasicEList;
	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The import org.eclipse.emf.common.util.BasicEList is never used
----------
----------
3. WARNING in D:\EclipseWorkspace\OPRS\src-gen\edu\conference\Reviewer.java (at line 13)
	import java.text.DecimalFormat;
	       ^^^^^^^^^^^^^^^^^^^^^^^
The import java.text.DecimalFormat is never used
----------
3 problems (3 warnings)

95445 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
95445 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
95448 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample2.mwe2 启动完成
正在拷贝 src-gen/edu/conference 到 qwen3-coder/conference2...
拷贝完成！

======================================
正在启动 sample3.mwe2...
======================================
95775 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
95867 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project OPRS at 'file:/D:/EclipseWorkspace/OPRS/'
95871 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
95881 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@7683ea43
95881 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
95883 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
95884 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
To help the program chair, we are planning to develop a computer-assisted review system. The system will be available to users who can be authors, reviewers, and co-chairs. Each user has a name. Papers are known by the title and whether they are research papers or experience report papers. The paper is reviewed by at least three reviewers. On the other side, the authors can submit as many papers as they want. When a reviewer logs in, she can consult the list of papers that have been assigned to her for review, and submit reviews for each of those papers. Each review has feedback as well as grade that can be Accept or Reject. A final decision is made by the chair for each paper.
functional requirement：
+ Calculate the number of unsubmitted reviews for a given reviewer. Return 0 if all reviews are submitted by the reviewer.

+ Before the chair makes the final decision, check if all reviews for a paper are either exclusively Accept or exclusively Reject. Return a boolean value.

+ Count the total number of papers submitted by an author.

+ Calculate the acceptance rate of papers for an author. Example: If an author submitted 10 papers with 6 accepted, return 0.60.

+ Convert a reviewer's historical grades (Accept = 1, Reject = 0) into a numerical average score between 0.0 and 1.0. Example: 
```

# Class Diagram
```plantuml
@startuml

title conference Model

class Author {
    papers : List<Paper>
    calculateAcceptanceRate() : double
    countSubmittedPapers() : int
    findAuthorsWithPositiveReviews() : List<Author>
    submitPaper(paper : Paper) : void
}
class CoChair {
    makeFinalDecision(paper : Paper, decision : Grade) : int
}
class Paper {
    decision : Grade
    title : String
    type : PaperType
    reviews : List<ReviewAssignment>
    calculateAcceptanceRate() : double
    isAllReviewsPositive() : boolean
}
class ReviewAssignment {
    feedback : String
    grade : Grade
    paper : Paper
}
class Reviewer {
    assignments : List<ReviewAssignment>
    calculateAcceptanceProportion() : double
    calculateUnsubmittedReviews() : int
}
class User {
    name : String
    roles : List<UserRole>
}
abstract class UserRole {
}
enum Grade {
    UNDECIDED
    ACCEPT
    REJECT
}
enum PaperType {
    RESEARCH
    EXPERIENCE
}

Author --|> UserRole
Author --> "*" Paper : papers
CoChair --|> UserRole
Paper --> "*" ReviewAssignment : reviews  'opposite: paper
ReviewAssignment --> Paper : paper  'opposite: reviews
Reviewer --|> UserRole
Reviewer --> "*" ReviewAssignment : assignments
User *-- "*" UserRole : roles
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

113918 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@6167a456 (name: countSubmittedPapers) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Counts the total number of papers submitted by an author.
Algorithm:
1. Return the size of the papers list associated with the author.
2. If the papers list is null, return 0.
Input: None
Output: An integer representing the total number of submitted papers.
Pre-condition: The author exists and may or may not have submitted papers.
Post-condition: The returned count is a non-negative integer representing the number of papers submitted., org.eclipse.emf.ecore.impl.EOperationImpl@6d01f2e5 (name: calculateAcceptanceProportion) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Converts a reviewer's historical grades into a numerical average score (Accept = 1, Reject = 0).
Algorithm:
1. Initialize sum = 0 and count = 0.
2. For each ReviewAssignment assigned to the reviewer:
   - If grade is ACCEPT, add 1 to sum; else if grade is REJECT, add 0 to sum.
   - Increment count.
3. If count is 0, return 0.0.
4. Else, return sum / count, rounded to two decimal places.
Input: None
Output: A double between 0.0 and 1.0 representing the average acceptance score.
Pre-condition: The reviewer exists and may or may not have completed reviews.
Post-condition: A value between 0.0 and 1.0 is returned, where 1.0 means all grades were Accept, and 0.0 means all were Reject or no reviews., org.eclipse.emf.ecore.impl.EOperationImpl@257708e (name: calculateUnsubmittedReviews) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates the number of unsubmitted reviews for a given reviewer. Returns 0 if all reviews have been submitted.
Algorithm:
1. Initialize a counter to zero.
2. Iterate through each ReviewAssignment in the reviewer's assignments.
3. If the ReviewAssignment has no grade (i.e., grade is UNDECIDED), increment the counter.
4. Return the counter.
Input: None
Output: An integer representing the number of unsubmitted reviews.
Pre-condition: The reviewer must have at least one assignment.
Post-condition: The returned value is a non-negative integer indicating how many reviews are not yet submitted., org.eclipse.emf.ecore.impl.EOperationImpl@18c26588 (name: isAllReviewsPositive) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Checks if all reviews for a paper are either exclusively Accept or exclusively Reject.
Algorithm:
1. If there are no reviews, return false.
2. Check if all review grades are ACCEPT, return true if so.
3. Check if all review grades are REJECT, return true if so.
4. Otherwise, return false.
Input: None
Output: A boolean value indicating whether all reviews are the same and either all Accept or all Reject.
Pre-condition: The paper must have at least one review.
Post-condition: Returns true only if all reviews share the same grade and it is either all Accept or all Reject; otherwise, returns false., org.eclipse.emf.ecore.impl.EOperationImpl@54eb2bf6 (name: calculateAcceptanceRate) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates the acceptance rate of papers for an author (papers accepted / total papers submitted).
Algorithm:
1. Initialize counters for total and accepted papers.
2. Iterate over each paper in the author’s papers list.
3. Increment the total paper count.
4. If the paper's decision is ACCEPT, increment the accepted paper count.
5. Return the ratio of accepted to total papers, rounded to two decimal places.
Input: None
Output: A double value between 0.0 and 1.0 representing the acceptance rate.
Pre-condition: The author must exist and may have zero or more papers.
Post-condition: If there are no papers, return 0.0; otherwise, returns a value between 0.0 and 1.0.}
113920 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
114007 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../OPRS/src-gen/edu/conference
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.conference;

import java.util.Collection;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.util.EObjectResolvingEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Author</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.conference.Author#getPapers <em>Papers</em>}</li>
 * </ul>
 *
 * @see edu.conference.ConferencePackage#getAuthor()
 * @model kind="class"
 * @generated
 */
public class Author extends UserRole
{
  protected EList<Paper> papers;

  protected Author()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Paper> getPapers()
  { ... /* omitted */ }

  public void submitPaper(Paper paper)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the total number of papers submitted by an author.
   * Algorithm:
   * 1. Return the size of the papers list associated with the author.
   * 2. If the papers list is null, return 0.
   * Input: None
   * Output: An integer representing the total number of submitted papers.
   * Pre-condition: The author exists and may or may not have submitted papers.
   * Post-condition: The returned count is a non-negative integer representing the number of papers submitted.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int countSubmittedPapers()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the acceptance rate of papers for an author (papers accepted / total papers submitted).
   * Algorithm:
   * 1. Initialize counters for total and accepted papers.
   * 2. Iterate over each paper in the author’s papers list.
   * 3. Increment the total paper count.
   * 4. If the paper's decision is ACCEPT, increment the accepted paper count.
   * 5. Return the ratio of accepted to total papers, rounded to two decimal places.
   * Input: None
   * Output: A double value between 0.0 and 1.0 representing the acceptance rate.
   * Pre-condition: The author must exist and may have zero or more papers.
   * Post-condition: If there are no papers, return 0.0; otherwise, returns a value between 0.0 and 1.0.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateAcceptanceRate()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  public EList<Author> findAuthorsWithPositiveReviews()
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Author
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `UserRole` contains the following methods.
  + Instance creation: Can only be used as an abstract type
- Class `Paper` contains the following methods.
  + Instance creation: Use `ConferenceFactory.eINSTANCE.createPaper()`
  + Public methods: public boolean isAllReviewsPositive(), public double calculateAcceptanceRate()
  + Getter methods: public String getTitle(), public PaperType getType(), public Grade getDecision(), public EList<ReviewAssignment> getReviews()
  + Setter methods: public void setTitle(String newTitle), public void setType(PaperType newType), public void setDecision(Grade newDecision)
- Class `Author` contains the following methods.
  + Instance creation: Use `ConferenceFactory.eINSTANCE.createAuthor()`
  + Public methods: public void submitPaper(Paper paper), public int countSubmittedPapers(), public double calculateAcceptanceRate(), public EList<Author> findAuthorsWithPositiveReviews()
  + Getter methods: public EList<Paper> getPapers()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.conference;

import java.util.Collection;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.util.EObjectResolvingEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Author</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.conference.Author#getPapers <em>Papers</em>}</li>
 * </ul>
 *
 * @see edu.conference.ConferencePackage#getAuthor()
 * @model kind="class"
 * @generated
 */
public class Author extends UserRole
{
  protected EList<Paper> papers;

  protected Author()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Paper> getPapers()
  { ... /* omitted */ }

  public void submitPaper(Paper paper)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the total number of papers submitted by an author.
   * Algorithm:
   * 1. Return the size of the papers list associated with the author.
   * 2. If the papers list is null, return 0.
   * Input: None
   * Output: An integer representing the total number of submitted papers.
   * Pre-condition: The author exists and may or may not have submitted papers.
   * Post-condition: The returned count is a non-negative integer representing the number of papers submitted.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int countSubmittedPapers()
  {
    if (papers == null) {
      return 0;
    }
    return papers.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the acceptance rate of papers for an author (papers accepted / total papers submitted).
   * Algorithm:
   * 1. Initialize counters for total and accepted papers.
   * 2. Iterate over each paper in the author’s papers list.
   * 3. Increment the total paper count.
   * 4. If the paper's decision is ACCEPT, increment the accepted paper count.
   * 5. Return the ratio of accepted to total papers, rounded to two decimal places.
   * Input: None
   * Output: A double value between 0.0 and 1.0 representing the acceptance rate.
   * Pre-condition: The author must exist and may have zero or more papers.
   * Post-condition: If there are no papers, return 0.0; otherwise, returns a value between 0.0 and 1.0.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateAcceptanceRate()
  {
    if (papers == null || papers.isEmpty()) {
      return 0.0;
    }

    int totalPapers = 0;
    int acceptedPapers = 0;

    for (Paper paper : papers) {
      totalPapers++;
      if (paper.getDecision() != null && paper.getDecision().equals(Grade.ACCEPT)) {
        acceptedPapers++;
      }
    }

    if (totalPapers == 0) {
      return 0.0;
    }

    return Math.round((double) acceptedPapers / totalPapers * 100.0) / 100.0;
  }

  public EList<Author> findAuthorsWithPositiveReviews()
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Author
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.conference;

import java.util.Collection;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.util.EObjectResolvingEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Reviewer</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.conference.Reviewer#getAssignments <em>Assignments</em>}</li>
 * </ul>
 *
 * @see edu.conference.ConferencePackage#getReviewer()
 * @model kind="class"
 * @generated
 */
public class Reviewer extends UserRole
{
  protected EList<ReviewAssignment> assignments;

  protected Reviewer()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<ReviewAssignment> getAssignments()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the number of unsubmitted reviews for a given reviewer. Returns 0 if all reviews have been submitted.
   * Algorithm:
   * 1. Initialize a counter to zero.
   * 2. Iterate through each ReviewAssignment in the reviewer's assignments.
   * 3. If the ReviewAssignment has no grade (i.e., grade is UNDECIDED), increment the counter.
   * 4. Return the counter.
   * Input: None
   * Output: An integer representing the number of unsubmitted reviews.
   * Pre-condition: The reviewer must have at least one assignment.
   * Post-condition: The returned value is a non-negative integer indicating how many reviews are not yet submitted.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int calculateUnsubmittedReviews()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Converts a reviewer's historical grades into a numerical average score (Accept = 1, Reject = 0).
   * Algorithm:
   * 1. Initialize sum = 0 and count = 0.
   * 2. For each ReviewAssignment assigned to the reviewer:
   *    - If grade is ACCEPT, add 1 to sum; else if grade is REJECT, add 0 to sum.
   *    - Increment count.
   * 3. If count is 0, return 0.0.
   * 4. Else, return sum / count, rounded to two decimal places.
   * Input: None
   * Output: A double between 0.0 and 1.0 representing the average acceptance score.
   * Pre-condition: The reviewer exists and may or may not have completed reviews.
   * Post-condition: A value between 0.0 and 1.0 is returned, where 1.0 means all grades were Accept, and 0.0 means all were Reject or no reviews.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateAcceptanceProportion()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Reviewer
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `UserRole` contains the following methods.
  + Instance creation: Can only be used as an abstract type
- Class `ReviewAssignment` contains the following methods.
  + Instance creation: Use `ConferenceFactory.eINSTANCE.createReviewAssignment()`
  + Getter methods: public String getFeedback(), public Grade getGrade(), public Paper getPaper()
  + Setter methods: public void setFeedback(String newFeedback), public void setGrade(Grade newGrade), public void setPaper(Paper newPaper)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.conference;

import java.util.Collection;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.util.EObjectResolvingEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Reviewer</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.conference.Reviewer#getAssignments <em>Assignments</em>}</li>
 * </ul>
 *
 * @see edu.conference.ConferencePackage#getReviewer()
 * @model kind="class"
 * @generated
 */
public class Reviewer extends UserRole
{
  protected EList<ReviewAssignment> assignments;

  protected Reviewer()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<ReviewAssignment> getAssignments()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the number of unsubmitted reviews for a given reviewer. Returns 0 if all reviews have been submitted.
   * Algorithm:
   * 1. Initialize a counter to zero.
   * 2. Iterate through each ReviewAssignment in the reviewer's assignments.
   * 3. If the ReviewAssignment has no grade (i.e., grade is UNDECIDED), increment the counter.
   * 4. Return the counter.
   * Input: None
   * Output: An integer representing the number of unsubmitted reviews.
   * Pre-condition: The reviewer must have at least one assignment.
   * Post-condition: The returned value is a non-negative integer indicating how many reviews are not yet submitted.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateUnsubmittedReviews()
  {
    int counter = 0;
    for (ReviewAssignment assignment : getAssignments()) {
      if (assignment.getGrade() == null || assignment.getGrade() == Grade.UNDECIDED) {
        counter++;
      }
    }
    return counter;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Converts a reviewer's historical grades into a numerical average score (Accept = 1, Reject = 0).
   * Algorithm:
   * 1. Initialize sum = 0 and count = 0.
   * 2. For each ReviewAssignment assigned to the reviewer:
   *    - If grade is ACCEPT, add 1 to sum; else if grade is REJECT, add 0 to sum.
   *    - Increment count.
   * 3. If count is 0, return 0.0.
   * 4. Else, return sum / count, rounded to two decimal places.
   * Input: None
   * Output: A double between 0.0 and 1.0 representing the average acceptance score.
   * Pre-condition: The reviewer exists and may or may not have completed reviews.
   * Post-condition: A value between 0.0 and 1.0 is returned, where 1.0 means all grades were Accept, and 0.0 means all were Reject or no reviews.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateAcceptanceProportion()
  {
    int sum = 0;
    int count = 0;
    
    for (ReviewAssignment assignment : getAssignments()) {
      if (assignment.getGrade() != null) {
        if (assignment.getGrade() == Grade.ACCEPT) {
          sum += 1;
        } else if (assignment.getGrade() == Grade.REJECT) {
          sum += 0;
        }
        count++;
      }
    }
    
    if (count == 0) {
      return 0.0;
    }
    
    return Math.round((double) sum / count * 100.0) / 100.0;
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Reviewer
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.conference;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectWithInverseResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Paper</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.conference.Paper#getTitle <em>Title</em>}</li>
 *   <li>{@link edu.conference.Paper#getType <em>Type</em>}</li>
 *   <li>{@link edu.conference.Paper#getDecision <em>Decision</em>}</li>
 *   <li>{@link edu.conference.Paper#getReviews <em>Reviews</em>}</li>
 * </ul>
 *
 * @see edu.conference.ConferencePackage#getPaper()
 * @model kind="class"
 * @generated
 */
public class Paper extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String TITLE_EDEFAULT = null;

  protected String title = TITLE_EDEFAULT;

  protected static final PaperType TYPE_EDEFAULT = PaperType.RESEARCH;

  protected PaperType type = TYPE_EDEFAULT;

  protected static final Grade DECISION_EDEFAULT = Grade.UNDECIDED;

  protected Grade decision = DECISION_EDEFAULT;

  protected EList<ReviewAssignment> reviews;

  protected Paper()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getTitle()
  { ... /* omitted */ }

  public void setTitle(String newTitle)
  { ... /* omitted */ }

  public PaperType getType()
  { ... /* omitted */ }

  public void setType(PaperType newType)
  { ... /* omitted */ }

  public Grade getDecision()
  { ... /* omitted */ }

  public void setDecision(Grade newDecision)
  { ... /* omitted */ }

  public EList<ReviewAssignment> getReviews()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Checks if all reviews for a paper are either exclusively Accept or exclusively Reject.
   * Algorithm:
   * 1. If there are no reviews, return false.
   * 2. Check if all review grades are ACCEPT, return true if so.
   * 3. Check if all review grades are REJECT, return true if so.
   * 4. Otherwise, return false.
   * Input: None
   * Output: A boolean value indicating whether all reviews are the same and either all Accept or all Reject.
   * Pre-condition: The paper must have at least one review.
   * Post-condition: Returns true only if all reviews share the same grade and it is either all Accept or all Reject; otherwise, returns false.
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean isAllReviewsPositive()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  public double calculateAcceptanceRate()
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Paper
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `ReviewAssignment` contains the following methods.
  + Instance creation: Use `ConferenceFactory.eINSTANCE.createReviewAssignment()`
  + Getter methods: public String getFeedback(), public Grade getGrade(), public Paper getPaper()
  + Setter methods: public void setFeedback(String newFeedback), public void setGrade(Grade newGrade), public void setPaper(Paper newPaper)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.conference;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectWithInverseResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Paper</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.conference.Paper#getTitle <em>Title</em>}</li>
 *   <li>{@link edu.conference.Paper#getType <em>Type</em>}</li>
 *   <li>{@link edu.conference.Paper#getDecision <em>Decision</em>}</li>
 *   <li>{@link edu.conference.Paper#getReviews <em>Reviews</em>}</li>
 * </ul>
 *
 * @see edu.conference.ConferencePackage#getPaper()
 * @model kind="class"
 * @generated
 */
public class Paper extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String TITLE_EDEFAULT = null;

  protected String title = TITLE_EDEFAULT;

  protected static final PaperType TYPE_EDEFAULT = PaperType.RESEARCH;

  protected PaperType type = TYPE_EDEFAULT;

  protected static final Grade DECISION_EDEFAULT = Grade.UNDECIDED;

  protected Grade decision = DECISION_EDEFAULT;

  protected EList<ReviewAssignment> reviews;

  protected Paper()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getTitle()
  { ... /* omitted */ }

  public void setTitle(String newTitle)
  { ... /* omitted */ }

  public PaperType getType()
  { ... /* omitted */ }

  public void setType(PaperType newType)
  { ... /* omitted */ }

  public Grade getDecision()
  { ... /* omitted */ }

  public void setDecision(Grade newDecision)
  { ... /* omitted */ }

  public EList<ReviewAssignment> getReviews()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Checks if all reviews for a paper are either exclusively Accept or exclusively Reject.
   * Algorithm:
   * 1. If there are no reviews, return false.
   * 2. Check if all review grades are ACCEPT, return true if so.
   * 3. Check if all review grades are REJECT, return true if so.
   * 4. Otherwise, return false.
   * Input: None
   * Output: A boolean value indicating whether all reviews are the same and either all Accept or all Reject.
   * Pre-condition: The paper must have at least one review.
   * Post-condition: Returns true only if all reviews share the same grade and it is either all Accept or all Reject; otherwise, returns false.
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean isAllReviewsPositive()
  {
    EList<ReviewAssignment> reviewList = getReviews();
    if (reviewList.isEmpty()) {
      return false;
    }

    boolean allAccept = true;
    boolean allReject = true;

    for (ReviewAssignment review : reviewList) {
      Grade grade = review.getGrade();
      if (grade != Grade.ACCEPT) {
        allAccept = false;
      }
      if (grade != Grade.REJECT) {
        allReject = false;
      }
    }

    return allAccept || allReject;
  }

  public double calculateAcceptanceRate()
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Paper
185719 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../OPRS/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../OPRS/src-gen/edu/conference/
185882 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
185882 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
185882 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
185883 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
185884 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample3.mwe2 启动完成
正在拷贝 src-gen/edu/conference 到 qwen3-coder/conference3...
拷贝完成！

======================================
正在启动 sample4.mwe2...
======================================
186129 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
186195 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project OPRS at 'file:/D:/EclipseWorkspace/OPRS/'
186198 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
186207 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@1b4ade78
186207 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
186210 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
186211 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
To help the program chair, we are planning to develop a computer-assisted review system. The system will be available to users who can be authors, reviewers, and co-chairs. Each user has a name. Papers are known by the title and whether they are research papers or experience report papers. The paper is reviewed by at least three reviewers. On the other side, the authors can submit as many papers as they want. When a reviewer logs in, she can consult the list of papers that have been assigned to her for review, and submit reviews for each of those papers. Each review has feedback as well as grade that can be Accept or Reject. A final decision is made by the chair for each paper.
functional requirement：
+ Calculate the number of unsubmitted reviews for a given reviewer. Return 0 if all reviews are submitted by the reviewer.

+ Before the chair makes the final decision, check if all reviews for a paper are either exclusively Accept or exclusively Reject. Return a boolean value.

+ Count the total number of papers submitted by an author.

+ Calculate the acceptance rate of papers for an author. Example: If an author submitted 10 papers with 6 accepted, return 0.60.

+ Convert a reviewer's historical grades (Accept = 1, Reject = 0) into a numerical average score between 0.0 and 1.0. Example: 
```

# Class Diagram
```plantuml
@startuml

title conference Model

class Author {
    papers : List<Paper>
    calculateAcceptanceRate() : double
    countSubmittedPapers() : int
    findAuthorsWithPositiveReviews() : List<Author>
    submitPaper(paper : Paper) : void
}
class CoChair {
    makeFinalDecision(paper : Paper, decision : Grade) : int
}
class Paper {
    decision : Grade
    title : String
    type : PaperType
    reviews : List<ReviewAssignment>
    calculateAcceptanceRate() : double
    isAllReviewsPositive() : boolean
}
class ReviewAssignment {
    feedback : String
    grade : Grade
    paper : Paper
}
class Reviewer {
    assignments : List<ReviewAssignment>
    calculateAcceptanceProportion() : double
    calculateUnsubmittedReviews() : int
}
class User {
    name : String
    roles : List<UserRole>
}
abstract class UserRole {
}
enum Grade {
    UNDECIDED
    ACCEPT
    REJECT
}
enum PaperType {
    RESEARCH
    EXPERIENCE
}

Author --|> UserRole
Author --> "*" Paper : papers
CoChair --|> UserRole
Paper --> "*" ReviewAssignment : reviews  'opposite: paper
ReviewAssignment --> Paper : paper  'opposite: reviews
Reviewer --|> UserRole
Reviewer --> "*" ReviewAssignment : assignments
User *-- "*" UserRole : roles
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```


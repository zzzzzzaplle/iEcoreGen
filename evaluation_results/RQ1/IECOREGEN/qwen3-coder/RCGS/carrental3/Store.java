/**
 * generated by Enhanced EcoreGen
 */
package edu.carrental;

import java.util.Collection;
import java.util.Date;
import java.util.Map;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.HashMap;
import org.eclipse.emf.common.util.BasicEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Store</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.carrental.Store#getCars <em>Cars</em>}</li>
 *   <li>{@link edu.carrental.Store#getRentals <em>Rentals</em>}</li>
 *   <li>{@link edu.carrental.Store#getNotices <em>Notices</em>}</li>
 * </ul>
 *
 * @see edu.carrental.CarrentalPackage#getStore()
 * @model kind="class"
 * @generated
 */
public class Store extends MinimalEObjectImpl.Container implements EObject
{
  /**
   * The cached value of the '{@link #getCars() <em>Cars</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getCars()
   * @generated
   * @ordered
   */
  protected EList<Car> cars;

  /**
   * The cached value of the '{@link #getRentals() <em>Rentals</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getRentals()
   * @generated
   * @ordered
   */
  protected EList<Rental> rentals;

  /**
   * The cached value of the '{@link #getNotices() <em>Notices</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getNotices()
   * @generated
   * @ordered
   */
  protected EList<OverdueNotice> notices;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected Store()
  {
    super();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  protected EClass eStaticClass()
  {
    return CarrentalPackage.Literals.STORE;
  }

  /**
   * Returns the value of the '<em><b>Cars</b></em>' containment reference list.
   * The list contents are of type {@link edu.carrental.Car}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Cars</em>' containment reference list.
   * @see edu.carrental.CarrentalPackage#getStore_Cars()
   * @model containment="true"
   * @generated
   */
  public EList<Car> getCars()
  {
    if (cars == null)
    {
      cars = new EObjectContainmentEList<Car>(Car.class, this, CarrentalPackage.STORE__CARS);
    }
    return cars;
  }

  /**
   * Returns the value of the '<em><b>Rentals</b></em>' containment reference list.
   * The list contents are of type {@link edu.carrental.Rental}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Rentals</em>' containment reference list.
   * @see edu.carrental.CarrentalPackage#getStore_Rentals()
   * @model containment="true"
   * @generated
   */
  public EList<Rental> getRentals()
  {
    if (rentals == null)
    {
      rentals = new EObjectContainmentEList<Rental>(Rental.class, this, CarrentalPackage.STORE__RENTALS);
    }
    return rentals;
  }

  /**
   * Returns the value of the '<em><b>Notices</b></em>' containment reference list.
   * The list contents are of type {@link edu.carrental.OverdueNotice}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Notices</em>' containment reference list.
   * @see edu.carrental.CarrentalPackage#getStore_Notices()
   * @model containment="true"
   * @generated
   */
  public EList<OverdueNotice> getNotices()
  {
    if (notices == null)
    {
      notices = new EObjectContainmentEList<OverdueNotice>(OverdueNotice.class, this, CarrentalPackage.STORE__NOTICES);
    }
    return notices;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Identifies and returns a list of available cars in the store.
   * Algorithm:
   * 1. Initialize an empty list (availableCars).
   * 2. Create a set of rented car plates by iterating over rentals where backDate is null.
   * 3. Iterate through each Car in the cars list.
   * 4. If the Carâ€™s plate is NOT in the rented car plate set:
   *    - Add the Car to availableCars.
   * 5. Sort availableCars by dailyPrice in ascending order.
   * 6. Return the sorted list.
   * Input: None
   * Output: A list of Car objects that are available, sorted by dailyPrice ascending. Returns an empty list if no cars are available.
   * Pre-condition: The cars and rentals lists are initialized.
   * Post-condition: Available cars are identified, sorted, and returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Car> identifyAvailableCars()
  {
    EList<Car> availableCars = new BasicEList<Car>();
    Set<String> rentedCarPlates = new HashSet<String>();
    
    // Step 2: Collect plates of rented cars (where backDate is null)
    for (Rental rental : getRentals()) {
        if (rental.getBackDate() == null) {
            Car car = rental.getCar();
            if (car != null) {
                rentedCarPlates.add(car.getPlate());
            }
        }
    }
    
    // Step 3-4: Add non-rented cars to availableCars
    for (Car car : getCars()) {
        if (!rentedCarPlates.contains(car.getPlate())) {
            availableCars.add(car);
        }
    }
    
    // Step 5: Sort by dailyPrice ascending
    Collections.sort(availableCars, (c1, c2) -> Double.compare(c1.getDailyPrice(), c2.getDailyPrice()));
    
    // Step 6: Return the result
    return availableCars;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total revenue generated by all rentals in the store.
   * Algorithm:
   * 1. Initialize a variable totalRevenue to 0.0.
   * 2. Iterate through each Rental object in the rentals list.
   * 3. For each Rental, add its totalPrice to totalRevenue.
   * 4. Return the final value of totalRevenue.
   * Input: None
   * Output: A double representing the total revenue from all rentals. If there are no rentals, returns 0.0.
   * Pre-condition: The rentals list is initialized.
   * Post-condition: The total revenue is computed and returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateTotalRevenue()
  {
    double totalRevenue = 0.0;
    
    // Iterate through each Rental and sum up totalPrice
    for (Rental rental : getRentals()) {
        totalRevenue += rental.getTotalPrice();
    }
    
    return totalRevenue;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Identifies customers who have overdue rentals based on the current date.
   * Algorithm:
   * 1. Initialize an empty list (overdueCustomers).
   * 2. Iterate through each Rental in the rentals list.
   * 3. For each Rental:
   *    - If backDate is null AND currentDate is after dueDate:
   *        - Add the Rental's associated Customer to overdueCustomers.
   * 4. Return the overdueCustomers list.
   * Input:
   *   - currentDate: EDate (format: yyyy-MM-dd) representing the reference date to check against due dates.
   * Output: A list of Customer objects who have overdue rentals. Returns an empty list if none are overdue.
   * Pre-condition: The rentals list is initialized and contains valid Rental objects with proper dueDate/backDate fields.
   * Post-condition: A list of overdue customers is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Customer> findCustomersWithOverdueRentals(final Date currentDate)
  {
    EList<Customer> overdueCustomers = new BasicEList<Customer>();
    
    // Iterate through each Rental
    for (Rental rental : getRentals()) {
        // Check if backDate is null and currentDate is after dueDate
        if (rental.getBackDate() == null && currentDate != null && rental.getDueDate() != null && currentDate.after(rental.getDueDate())) {
            Customer customer = rental.getCustomer();
            if (customer != null && !overdueCustomers.contains(customer)) {
                overdueCustomers.add(customer);
            }
        }
    }
    
    return overdueCustomers;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Determines the average daily price of all cars in the store.
   * Algorithm:
   * 1. If the cars list is empty, return 0.0 immediately.
   * 2. Otherwise, sum up the daily prices of all Car objects in the cars list.
   * 3. Divide the sum by the total number of cars.
   * 4. Return the result as a double.
   * Input: None
   * Output: A double representing the average daily price. Returns 0.0 if there are no cars.
   * Pre-condition: The cars list is initialized.
   * Post-condition: The average daily price is computed and returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double determineAverageDailyPrice()
  {
    EList<Car> carsList = getCars();
    int size = carsList.size();
    
    // If no cars, return 0.0
    if (size == 0) {
        return 0.0;
    }
    
    double sum = 0.0;
    // Sum up all daily prices
    for (Car car : carsList) {
        sum += car.getDailyPrice();
    }
    
    // Divide by number of cars and return
    return sum / size;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the number of cars rented per customer.
   * Algorithm:
   * 1. Initialize an empty map (customerCountMap).
   * 2. Iterate through each Rental in the rentals list.
   * 3. For each Rental, get the associated customer.
   * 4. Update the count for that customer in the map (increment if exists, set to 1 if not).
   * 5. Return the populated map.
   * Input: None
   * Output: A map where keys are Customers and values are integers representing the number of rentals per customer. Returns an empty map if no rentals exist.
   * Pre-condition: The rentals list is initialized.
   * Post-condition: A map containing customer-rental count pairs is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Map<Customer, Integer>> countCarsRentedPerCustomer()
  {
    Map<Customer, Integer> customerCountMap = new HashMap<Customer, Integer>();
    
    // Iterate through each Rental
    for (Rental rental : getRentals()) {
        Customer customer = rental.getCustomer();
        if (customer != null) {
            // Update count for customer
            Integer count = customerCountMap.get(customer);
            if (count == null) {
                customerCountMap.put(customer, 1);
            } else {
                customerCountMap.put(customer, count + 1);
            }
        }
    }
    
    // Create result list containing the single map
    EList<Map<Customer, Integer>> result = new BasicEList<Map<Customer, Integer>>();
    result.add(customerCountMap);
    return result;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  {
    switch (featureID)
    {
      case CarrentalPackage.STORE__CARS:
        return ((InternalEList<?>)getCars()).basicRemove(otherEnd, msgs);
      case CarrentalPackage.STORE__RENTALS:
        return ((InternalEList<?>)getRentals()).basicRemove(otherEnd, msgs);
      case CarrentalPackage.STORE__NOTICES:
        return ((InternalEList<?>)getNotices()).basicRemove(otherEnd, msgs);
    }
    return super.eInverseRemove(otherEnd, featureID, msgs);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  {
    switch (featureID)
    {
      case CarrentalPackage.STORE__CARS:
        return getCars();
      case CarrentalPackage.STORE__RENTALS:
        return getRentals();
      case CarrentalPackage.STORE__NOTICES:
        return getNotices();
    }
    return super.eGet(featureID, resolve, coreType);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  {
    switch (featureID)
    {
      case CarrentalPackage.STORE__CARS:
        getCars().clear();
        getCars().addAll((Collection<? extends Car>)newValue);
        return;
      case CarrentalPackage.STORE__RENTALS:
        getRentals().clear();
        getRentals().addAll((Collection<? extends Rental>)newValue);
        return;
      case CarrentalPackage.STORE__NOTICES:
        getNotices().clear();
        getNotices().addAll((Collection<? extends OverdueNotice>)newValue);
        return;
    }
    super.eSet(featureID, newValue);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public void eUnset(int featureID)
  {
    switch (featureID)
    {
      case CarrentalPackage.STORE__CARS:
        getCars().clear();
        return;
      case CarrentalPackage.STORE__RENTALS:
        getRentals().clear();
        return;
      case CarrentalPackage.STORE__NOTICES:
        getNotices().clear();
        return;
    }
    super.eUnset(featureID);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public boolean eIsSet(int featureID)
  {
    switch (featureID)
    {
      case CarrentalPackage.STORE__CARS:
        return cars != null && !cars.isEmpty();
      case CarrentalPackage.STORE__RENTALS:
        return rentals != null && !rentals.isEmpty();
      case CarrentalPackage.STORE__NOTICES:
        return notices != null && !notices.isEmpty();
    }
    return super.eIsSet(featureID);
  }

} // Store

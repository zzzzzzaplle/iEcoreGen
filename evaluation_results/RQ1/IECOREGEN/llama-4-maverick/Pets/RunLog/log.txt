    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `House` contains the following methods.
  + Instance creation: Use `PetsFactory.eINSTANCE.createHouse()`
  + Public methods: public EList<String> retrievePetNames(), public boolean addPet(final Pet pet), public void removePet(final Pet pet), public EList<Pet> getPetsByType(final String type), public int getPetCount(final String type)
  + Getter methods: public EList<Pet> getLived()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { /* omitted */ }

  public String getName()
  { /* omitted */ }

  public void setName(String newName)
  { /* omitted */ }

  public House getHouse()
  { /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { /* omitted */ }

  public void setHouse(House newHouse)
  { /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet make noise.
   * Algorithm: 
   * The actual implementation depends on the specific type of pet (Dog or Cat).
   * For Dog, it barks.
   * For Cat, it meows.
   * Input: None.
   * Output: void
   *     - Meaning: The pet makes its specific noise.
   *     - Format: Not applicable.
   *     - Value ranges: Not applicable.
   * Pre-condition: None.
   * Post-condition: The pet has made its noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public abstract void makeNoise();

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { /* omitted */ }

  @Override
  public String toString()
  { /* omitted */ }

} // Pet
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { /* omitted */ }

  public String getName()
  { /* omitted */ }

  public void setName(String newName)
  { /* omitted */ }

  public House getHouse()
  { /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { /* omitted */ }

  public void setHouse(House newHouse)
  { /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet make noise.
   * Algorithm: 
   * The actual implementation depends on the specific type of pet (Dog or Cat).
   * For Dog, it barks.
   * For Cat, it meows.
   * Input: None.
   * Output: void
   *     - Meaning: The pet makes its specific noise.
   *     - Format: Not applicable.
   *     - Value ranges: Not applicable.
   * Pre-condition: None.
   * Post-condition: The pet has made its noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public abstract void makeNoise();

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { /* omitted */ }

  @Override
  public String toString()
  { /* omitted */ }

} // Pet
557702 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public House getHouse()
  { ... /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { ... /* omitted */ }

  public void setHouse(House newHouse)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet make noise.
   * Algorithm: 
   * The actual implementation depends on the specific type of pet (Dog or Cat).
   * For Dog, it barks.
   * For Cat, it meows.
   * Input: None.
   * Output: void
   *     - Meaning: The pet makes its specific noise.
   *     - Format: Not applicable.
   *     - Value ranges: Not applicable.
   * Pre-condition: None.
   * Post-condition: The pet has made its noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void makeNoise()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `House` contains the following methods.
  + Instance creation: Use `PetsFactory.eINSTANCE.createHouse()`
  + Public methods: public EList<String> retrievePetNames(), public boolean addPet(final Pet pet), public void removePet(final Pet pet), public EList<Pet> getPetsByType(final String type), public int getPetCount(final String type)
  + Getter methods: public EList<Pet> getLived()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
public abstract void makeNoise();
public void makeNoise()
{
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
}
/**
 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
 * <!-- begin-model-doc -->
 * Summary: Makes the pet make noise.
 * Algorithm: 
 * The actual implementation depends on the specific type of pet (Dog or Cat).
 * For Dog, it barks.
 * For Cat, it meows.
 * Input: None.
 * Output: void
 *     - Meaning: The pet makes its specific noise.
 *     - Format: Not applicable.
 *     - Value ranges: Not applicable.
 * Pre-condition: None.
 * Post-condition: The pet has made its noise.
 * <!-- end-model-doc -->
 * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
 * @generated NOT
 */
public abstract void makeNoise();
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { /* omitted */ }

  public String getName()
  { /* omitted */ }

  public void setName(String newName)
  { /* omitted */ }

  public House getHouse()
  { /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { /* omitted */ }

  public void setHouse(House newHouse)
  { /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet make noise.
   * Algorithm: 
   * The actual implementation depends on the specific type of pet (Dog or Cat).
   * For Dog, it barks.
   * For Cat, it meows.
   * Input: None.
   * Output: void
   *     - Meaning: The pet makes its specific noise.
   *     - Format: Not applicable.
   *     - Value ranges: Not applicable.
   * Pre-condition: None.
   * Post-condition: The pet has made its noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public abstract void makeNoise();

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { /* omitted */ }

  @Override
  public String toString()
  { /* omitted */ }

} // Pet
570211 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
570211 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - Failed after maximum retry
570211 [main] ERROR .sei.mde.mwe2.EMFGeneratorFragment2  - Failed to execute EMF generator
java.lang.RuntimeException: Failed after maximum retry
	at edu.ustb.sei.mde.mwe2.enhancement.CodewareEnhancement.doEnhancementWithRetry(CodewareEnhancement.java:75)
	at edu.ustb.sei.mde.mwe2.enhancement.CodewareEnhancement.lambda$1(CodewareEnhancement.java:40)
	at com.google.common.collect.Iterables$4.lambda$forEach$0(Iterables.java:588)
	at com.google.common.collect.Iterables$4.lambda$forEach$0(Iterables.java:588)
	at java.base/java.lang.Iterable.forEach(Iterable.java:75)
	at com.google.common.collect.Iterables$4.forEach(Iterables.java:585)
	at com.google.common.collect.Iterables$4.forEach(Iterables.java:585)
	at edu.ustb.sei.mde.mwe2.enhancement.CodewareEnhancement.enhance(CodewareEnhancement.java:42)
	at edu.ustb.sei.mde.mwe2.enhancement.CompoundCodeEnhancement.enhance(CompoundCodeEnhancement.java:21)
	at edu.ustb.sei.mde.mwe2.EMFGeneratorFragment2.generate(EMFGeneratorFragment2.java:447)
	at org.eclipse.xtext.xtext.generator.CompositeGeneratorFragment2.generate(CompositeGeneratorFragment2.java:43)
	at edu.ustb.sei.mde.mwe2.EcoreGenerator.invokeInternal(EcoreGenerator.java:222)
	at org.eclipse.emf.mwe.core.lib.AbstractWorkflowComponent.invoke(AbstractWorkflowComponent.java:133)
	at org.eclipse.emf.mwe.core.lib.Mwe2Bridge.invoke(Mwe2Bridge.java:35)
	at org.eclipse.emf.mwe.core.lib.AbstractWorkflowComponent.invoke(AbstractWorkflowComponent.java:213)
	at org.eclipse.emf.mwe2.runtime.workflow.AbstractCompositeWorkflowComponent.invoke(AbstractCompositeWorkflowComponent.java:38)
	at org.eclipse.emf.mwe2.runtime.workflow.Workflow.run(Workflow.java:21)
	at org.eclipse.emf.mwe2.launch.runtime.Mwe2Runner.run(Mwe2Runner.java:103)
	at org.eclipse.emf.mwe2.launch.runtime.Mwe2Runner.run(Mwe2Runner.java:63)
	at org.eclipse.emf.mwe2.launch.runtime.Mwe2Runner.run(Mwe2Runner.java:53)
	at org.eclipse.emf.mwe2.launch.runtime.Mwe2Launcher.run(Mwe2Launcher.java:78)
	at MainCLI.main(MainCLI.java:25)
570211 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
570213 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample4.mwe2 启动完成
正在拷贝 src-gen/edu/pets 到 llama-4-maverick/pets4...
拷贝完成！

======================================
正在启动 sample5.mwe2...
======================================
570417 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
570472 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project Pets at 'file:/D:/EclipseWorkspace/Pets/'
570475 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
570484 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@6b5df313
570484 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
570486 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
570487 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
A house may have any number of pets living in it. The two possible types of pets that can live in a house are dogs and cats. Each dog or cat has a name. An animal’s house is its one and only home. You can tell an animal to make noise and it will do its thing.
Functional requirement：
+ Retrieve a list of all pet names (dogs and cats) living in a specified house. Return an empty list if there are no pets.

+ Add a pet to the house. Return false if the pet already belongs to any house (including this one) or the pet does have name; return true if the pet is added successfully.

+ Remove a specified pet from its current house. Return false if the pet does not belong to the given current house; return true if it is removed successfully.

+ Retrieve a list of pets of a specific input string ("dog" or "cat") that live in a particular house. Return an empty list if there are no pets.

+ Count the number of pets in a particular house. Return 0 if there are no pets.
```

# Class Diagram
```plantuml
@startuml

title pets Model

class Cat {
}
class Dog {
}
class House {
    lived : List<Pet>
    addPet(pet : Pet) : boolean
    getPetCount(type : String) : int
    getPetsByType(type : String) : List<Pet>
    removePet(pet : Pet) : void
    retrievePetNames() : List<String>
}
abstract class Pet {
    name : String
    house : House
    makeNoise() : void
}

Cat --|> Pet
Dog --|> Pet
House *-- "*" Pet : lived  'opposite: house
Pet --> House : house  'opposite: lived
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

577935 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@69bf351e (name: retrievePetNames) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary: Retrieves a list of names of all pets living in the house.
Algorithm: 
1. Iterate over the list of pets in the house.
2. Extract the name of each pet and add it to a list.
3. Return the list of pet names.
Input: 
 - None
Output: 
 - List<String>: A list of names of all pets living in the house. It should be a list of strings.
Pre-condition: 
 - None
Post-condition: 
 - None, org.eclipse.emf.ecore.impl.EOperationImpl@39ae0bff (name: makeNoise) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Makes the pet make a noise.
Algorithm: 
This is an abstract method and should be implemented by subclasses (Dog and Cat).
Input: 
 - None
Output: 
 - None (or possibly a sound representation, depending on the implementation)
Pre-condition: 
 - None
Post-condition: 
 - The pet makes its characteristic noise., org.eclipse.emf.ecore.impl.EOperationImpl@52d04234 (name: getPetCount) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Retrieves the number of pets in the house.
Algorithm: 
1. Return the size of the list of pets in the house.
Input: 
 - None
Output: 
 - int: The number of pets in the house. It should be a non-negative integer.
Pre-condition: 
 - None
Post-condition: 
 - None, org.eclipse.emf.ecore.impl.EOperationImpl@75f5293c (name: getPetsByType) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary: Retrieves a list of pets of a specific type living in the house.
Algorithm: 
1. Filter the list of pets in the house based on the type (either "dog" or "cat").
2. Return the filtered list of pets.
Input: 
 - type: The type of pets to be retrieved. It should be either "dog" or "cat".
Output: 
 - List<Pet>: A list of pets of the specified type living in the house. It should be a list of instances of either Dog or Cat.
Pre-condition: 
 - The type should be either "dog" or "cat".
Post-condition: 
 - None, org.eclipse.emf.ecore.impl.EOperationImpl@3f7e72a7 (name: removePet) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Removes a pet from the house.
Algorithm: 
1. Check if the pet is associated with the house.
2. If the pet is associated with the house, remove it from the house's list of pets and reset its house association.
3. Return true if the pet is removed successfully, false otherwise.
Input: 
 - pet: The pet to be removed from the house. It should be an instance of Pet (either Dog or Cat).
Output: 
 - boolean: True if the pet is removed successfully, false if the pet does not belong to the house.
Pre-condition: 
 - The pet should not be null.
Post-condition: 
 - If the operation returns true, the pet is removed from the house's list of pets and is no longer associated with the house., org.eclipse.emf.ecore.impl.EOperationImpl@ceb4f91 (name: addPet) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Adds a pet to the house.
Algorithm: 
1. Check if the pet is null or has no name.
2. Check if the pet is already associated with a house.
3. If the pet is not associated with any house and has a name, add it to the house's list of pets.
4. Return true if the pet is added successfully, false otherwise.
Input: 
 - pet: The pet to be added to the house. It should be an instance of Pet (either Dog or Cat).
        The pet should have a name and should not be associated with any house.
Output: 
 - boolean: True if the pet is added successfully, false if the pet is already associated with a house or has no name.
Pre-condition: 
 - The pet should not be null.
 - The pet should not be associated with any house.
 - The pet should have a name.
Post-condition: 
 - If the operation returns true, the pet is added to the house's list of pets and is associated with the house.}
577936 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
577952 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../Pets/src-gen/edu/pets
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getLived <em>Lived</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Pet> lived;

  protected House()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Pet> getLived()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of names of all pets living in the house.
   * Algorithm: 
   * 1. Iterate over the list of pets in the house.
   * 2. Extract the name of each pet and add it to a list.
   * 3. Return the list of pet names.
   * Input: 
   *  - None
   * Output: 
   *  - List<String>: A list of names of all pets living in the house. It should be a list of strings.
   * Pre-condition: 
   *  - None
   * Post-condition: 
   *  - None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<String> retrievePetNames()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Adds a pet to the house.
   * Algorithm: 
   * 1. Check if the pet is null or has no name.
   * 2. Check if the pet is already associated with a house.
   * 3. If the pet is not associated with any house and has a name, add it to the house's list of pets.
   * 4. Return true if the pet is added successfully, false otherwise.
   * Input: 
   *  - pet: The pet to be added to the house. It should be an instance of Pet (either Dog or Cat).
   *         The pet should have a name and should not be associated with any house.
   * Output: 
   *  - boolean: True if the pet is added successfully, false if the pet is already associated with a house or has no name.
   * Pre-condition: 
   *  - The pet should not be null.
   *  - The pet should not be associated with any house.
   *  - The pet should have a name.
   * Post-condition: 
   *  - If the operation returns true, the pet is added to the house's list of pets and is associated with the house.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean addPet(final Pet pet)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Removes a pet from the house.
   * Algorithm: 
   * 1. Check if the pet is associated with the house.
   * 2. If the pet is associated with the house, remove it from the house's list of pets and reset its house association.
   * 3. Return true if the pet is removed successfully, false otherwise.
   * Input: 
   *  - pet: The pet to be removed from the house. It should be an instance of Pet (either Dog or Cat).
   * Output: 
   *  - boolean: True if the pet is removed successfully, false if the pet does not belong to the house.
   * Pre-condition: 
   *  - The pet should not be null.
   * Post-condition: 
   *  - If the operation returns true, the pet is removed from the house's list of pets and is no longer associated with the house.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void removePet(final Pet pet)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of pets of a specific type living in the house.
   * Algorithm: 
   * 1. Filter the list of pets in the house based on the type (either "dog" or "cat").
   * 2. Return the filtered list of pets.
   * Input: 
   *  - type: The type of pets to be retrieved. It should be either "dog" or "cat".
   * Output: 
   *  - List<Pet>: A list of pets of the specified type living in the house. It should be a list of instances of either Dog or Cat.
   * Pre-condition: 
   *  - The type should be either "dog" or "cat".
   * Post-condition: 
   *  - None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<Pet> getPetsByType(final String type)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves the number of pets in the house.
   * Algorithm: 
   * 1. Return the size of the list of pets in the house.
   * Input: 
   *  - None
   * Output: 
   *  - int: The number of pets in the house. It should be a non-negative integer.
   * Pre-condition: 
   *  - None
   * Post-condition: 
   *  - None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int getPetCount(final String type)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // House
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Pet` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Public methods: public void makeNoise()
  + Getter methods: public String getName(), public House getHouse()
  + Setter methods: public void setName(String newName), public void setHouse(House newHouse)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

java.lang.RuntimeException: com.fasterxml.jackson.databind.exc.MismatchedInputException: No content to map due to end-of-input
 at [Source: REDACTED (`StreamReadFeature.INCLUDE_SOURCE_IN_LOCATION` disabled); line: 1]
605397 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - Cannot invoke "String.lines()" because "output" is null
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getLived <em>Lived</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Pet> lived;

  protected House()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Pet> getLived()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of names of all pets living in the house.
   * Algorithm: 
   * 1. Iterate over the list of pets in the house.
   * 2. Extract the name of each pet and add it to a list.
   * 3. Return the list of pet names.
   * Input: 
   *  - None
   * Output: 
   *  - List<String>: A list of names of all pets living in the house. It should be a list of strings.
   * Pre-condition: 
   *  - None
   * Post-condition: 
   *  - None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<String> retrievePetNames()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Adds a pet to the house.
   * Algorithm: 
   * 1. Check if the pet is null or has no name.
   * 2. Check if the pet is already associated with a house.
   * 3. If the pet is not associated with any house and has a name, add it to the house's list of pets.
   * 4. Return true if the pet is added successfully, false otherwise.
   * Input: 
   *  - pet: The pet to be added to the house. It should be an instance of Pet (either Dog or Cat).
   *         The pet should have a name and should not be associated with any house.
   * Output: 
   *  - boolean: True if the pet is added successfully, false if the pet is already associated with a house or has no name.
   * Pre-condition: 
   *  - The pet should not be null.
   *  - The pet should not be associated with any house.
   *  - The pet should have a name.
   * Post-condition: 
   *  - If the operation returns true, the pet is added to the house's list of pets and is associated with the house.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean addPet(final Pet pet)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Removes a pet from the house.
   * Algorithm: 
   * 1. Check if the pet is associated with the house.
   * 2. If the pet is associated with the house, remove it from the house's list of pets and reset its house association.
   * 3. Return true if the pet is removed successfully, false otherwise.
   * Input: 
   *  - pet: The pet to be removed from the house. It should be an instance of Pet (either Dog or Cat).
   * Output: 
   *  - boolean: True if the pet is removed successfully, false if the pet does not belong to the house.
   * Pre-condition: 
   *  - The pet should not be null.
   * Post-condition: 
   *  - If the operation returns true, the pet is removed from the house's list of pets and is no longer associated with the house.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void removePet(final Pet pet)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of pets of a specific type living in the house.
   * Algorithm: 
   * 1. Filter the list of pets in the house based on the type (either "dog" or "cat").
   * 2. Return the filtered list of pets.
   * Input: 
   *  - type: The type of pets to be retrieved. It should be either "dog" or "cat".
   * Output: 
   *  - List<Pet>: A list of pets of the specified type living in the house. It should be a list of instances of either Dog or Cat.
   * Pre-condition: 
   *  - The type should be either "dog" or "cat".
   * Post-condition: 
   *  - None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<Pet> getPetsByType(final String type)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves the number of pets in the house.
   * Algorithm: 
   * 1. Return the size of the list of pets in the house.
   * Input: 
   *  - None
   * Output: 
   *  - int: The number of pets in the house. It should be a non-negative integer.
   * Pre-condition: 
   *  - None
   * Post-condition: 
   *  - None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int getPetCount(final String type)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // House
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Pet` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Public methods: public void makeNoise()
  + Getter methods: public String getName(), public House getHouse()
  + Setter methods: public void setName(String newName), public void setHouse(House newHouse)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getLived <em>Lived</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Pet> lived;

  protected House()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Pet> getLived()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of names of all pets living in the house.
   * Algorithm: 
   * 1. Iterate over the list of pets in the house.
   * 2. Extract the name of each pet and add it to a list.
   * 3. Return the list of pet names.
   * Input: 
   *  - None
   * Output: 
   *  - List<String>: A list of names of all pets living in the house. It should be a list of strings.
   * Pre-condition: 
   *  - None
   * Post-condition: 
   *  - None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> retrievePetNames()
  {
    EList<String> petNames = new BasicEList<String>();
    for (Pet pet : getLived()) {
      petNames.add(pet.getName());
    }
    return petNames;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Adds a pet to the house.
   * Algorithm: 
   * 1. Check if the pet is null or has no name.
   * 2. Check if the pet is already associated with a house.
   * 3. If the pet is not associated with any house and has a name, add it to the house's list of pets.
   * 4. Return true if the pet is added successfully, false otherwise.
   * Input: 
   *  - pet: The pet to be added to the house. It should be an instance of Pet (either Dog or Cat).
   *         The pet should have a name and should not be associated with any house.
   * Output: 
   *  - boolean: True if the pet is added successfully, false if the pet is already associated with a house or has no name.
   * Pre-condition: 
   *  - The pet should not be null.
   *  - The pet should not be associated with any house.
   *  - The pet should have a name.
   * Post-condition: 
   *  - If the operation returns true, the pet is added to the house's list of pets and is associated with the house.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean addPet(final Pet pet)
  {
    if (pet == null || pet.getName() == null || !pet.getName().isEmpty() == false || pet.getHouse() != null) {
      return false;
    }
    getLived().add(pet);
    pet.setHouse(this);
    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Removes a pet from the house.
   * Algorithm: 
   * 1. Check if the pet is associated with the house.
   * 2. If the pet is associated with the house, remove it from the house's list of pets and reset its house association.
   * 3. Return true if the pet is removed successfully, false otherwise.
   * Input: 
   *  - pet: The pet to be removed from the house. It should be an instance of Pet (either Dog or Cat).
   * Output: 
   *  - boolean: True if the pet is removed successfully, false if the pet does not belong to the house.
   * Pre-condition: 
   *  - The pet should not be null.
   * Post-condition: 
   *  - If the operation returns true, the pet is removed from the house's list of pets and is no longer associated with the house.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void removePet(final Pet pet)
  {
    if (getLived().contains(pet)) {
      getLived().remove(pet);
      pet.setHouse(null);
    }
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of pets of a specific type living in the house.
   * Algorithm: 
   * 1. Filter the list of pets in the house based on the type (either "dog" or "cat").
   * 2. Return the filtered list of pets.
   * Input: 
   *  - type: The type of pets to be retrieved. It should be either "dog" or "cat".
   * Output: 
   *  - List<Pet>: A list of pets of the specified type living in the house. It should be a list of instances of either Dog or Cat.
   * Pre-condition: 
   *  - The type should be either "dog" or "cat".
   * Post-condition: 
   *  - None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Pet> getPetsByType(final String type)
  {
    EList<Pet> petsByType = new BasicEList<Pet>();
    for (Pet pet : getLived()) {
      if (pet.eClass().getName().toLowerCase().equals(type)) {
        petsByType.add(pet);
      }
    }
    return petsByType;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves the number of pets in the house.
   * Algorithm: 
   * 1. Return the size of the list of pets in the house.
   * Input: 
   *  - None
   * Output: 
   *  - int: The number of pets in the house. It should be a non-negative integer.
   * Pre-condition: 
   *  - None
   * Post-condition: 
   *  - None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int getPetCount(final String type)
  {
    if (type == null) {
      return getLived().size();
    } else {
      return getPetsByType(type).size();
    }
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // House
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public House getHouse()
  { ... /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { ... /* omitted */ }

  public void setHouse(House newHouse)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet make a noise.
   * Algorithm: 
   * This is an abstract method and should be implemented by subclasses (Dog and Cat).
   * Input: 
   *  - None
   * Output: 
   *  - None (or possibly a sound representation, depending on the implementation)
   * Pre-condition: 
   *  - None
   * Post-condition: 
   *  - The pet makes its characteristic noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void makeNoise()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `House` contains the following methods.
  + Instance creation: Use `PetsFactory.eINSTANCE.createHouse()`
  + Public methods: public EList<String> retrievePetNames(), public boolean addPet(final Pet pet), public void removePet(final Pet pet), public EList<Pet> getPetsByType(final String type), public int getPetCount(final String type)
  + Getter methods: public EList<Pet> getLived()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public House getHouse()
  { ... /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { ... /* omitted */ }

  public void setHouse(House newHouse)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet make a noise.
   * Algorithm: 
   * This is an abstract method and should be implemented by subclasses (Dog and Cat).
   * Input: 
   *  - None
   * Output: 
   *  - None (or possibly a sound representation, depending on the implementation)
   * Pre-condition: 
   *  - None
   * Post-condition: 
   *  - The pet makes its characteristic noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public abstract void makeNoise();

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
654596 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public House getHouse()
  { ... /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { ... /* omitted */ }

  public void setHouse(House newHouse)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet make a noise.
   * Algorithm: 
   * This is an abstract method and should be implemented by subclasses (Dog and Cat).
   * Input: 
   *  - None
   * Output: 
   *  - None (or possibly a sound representation, depending on the implementation)
   * Pre-condition: 
   *  - None
   * Post-condition: 
   *  - The pet makes its characteristic noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void makeNoise()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `House` contains the following methods.
  + Instance creation: Use `PetsFactory.eINSTANCE.createHouse()`
  + Public methods: public EList<String> retrievePetNames(), public boolean addPet(final Pet pet), public void removePet(final Pet pet), public EList<Pet> getPetsByType(final String type), public int getPetCount(final String type)
  + Getter methods: public EList<Pet> getLived()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { /* omitted */ }

  public String getName()
  { /* omitted */ }

  public void setName(String newName)
  { /* omitted */ }

  public House getHouse()
  { /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { /* omitted */ }

  public void setHouse(House newHouse)
  { /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet make a noise.
   * Algorithm: 
   * This is an abstract method and should be implemented by subclasses (Dog and Cat).
   * Input: 
   *  - None
   * Output: 
   *  - None (or possibly a sound representation, depending on the implementation)
   * Pre-condition: 
   *  - None
   * Post-condition: 
   *  - The pet makes its characteristic noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public abstract void makeNoise();

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { /* omitted */ }

  @Override
  public String toString()
  { /* omitted */ }

} // Pet
667302 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public House getHouse()
  { ... /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { ... /* omitted */ }

  public void setHouse(House newHouse)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet make a noise.
   * Algorithm: 
   * This is an abstract method and should be implemented by subclasses (Dog and Cat).
   * Input: 
   *  - None
   * Output: 
   *  - None (or possibly a sound representation, depending on the implementation)
   * Pre-condition: 
   *  - None
   * Post-condition: 
   *  - The pet makes its characteristic noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void makeNoise()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `House` contains the following methods.
  + Instance creation: Use `PetsFactory.eINSTANCE.createHouse()`
  + Public methods: public EList<String> retrievePetNames(), public boolean addPet(final Pet pet), public void removePet(final Pet pet), public EList<Pet> getPetsByType(final String type), public int getPetCount(final String type)
  + Getter methods: public EList<Pet> getLived()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
 * <!-- begin-model-doc -->
 * Summary: Makes the pet make a noise.
 * Algorithm: 
 * This is an abstract method and should be implemented by subclasses (Dog and Cat).
 * Input: 
 *  - None
 * Output: 
 *  - None (or possibly a sound representation, depending on the implementation)
 * Pre-condition: 
 *  - None
 * Post-condition: 
 *  - The pet makes its characteristic noise.
 * <!-- end-model-doc -->
 * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
 * @generated NOT
 */
public abstract void makeNoise();
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { /* omitted */ }

  public String getName()
  { /* omitted */ }

  public void setName(String newName)
  { /* omitted */ }

  public House getHouse()
  { /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { /* omitted */ }

  public void setHouse(House newHouse)
  { /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet make a noise.
   * Algorithm: 
   * This is an abstract method and should be implemented by subclasses (Dog and Cat).
   * Input: 
   *  - None
   * Output: 
   *  - None (or possibly a sound representation, depending on the implementation)
   * Pre-condition: 
   *  - None
   * Post-condition: 
   *  - The pet makes its characteristic noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public abstract void makeNoise();

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { /* omitted */ }

  @Override
  public String toString()
  { /* omitted */ }

} // Pet
686833 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public House getHouse()
  { ... /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { ... /* omitted */ }

  public void setHouse(House newHouse)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet make a noise.
   * Algorithm: 
   * This is an abstract method and should be implemented by subclasses (Dog and Cat).
   * Input: 
   *  - None
   * Output: 
   *  - None (or possibly a sound representation, depending on the implementation)
   * Pre-condition: 
   *  - None
   * Post-condition: 
   *  - The pet makes its characteristic noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void makeNoise()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `House` contains the following methods.
  + Instance creation: Use `PetsFactory.eINSTANCE.createHouse()`
  + Public methods: public EList<String> retrievePetNames(), public boolean addPet(final Pet pet), public void removePet(final Pet pet), public EList<Pet> getPetsByType(final String type), public int getPetCount(final String type)
  + Getter methods: public EList<Pet> getLived()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { /* omitted */ }

  public String getName()
  { /* omitted */ }

  public void setName(String newName)
  { /* omitted */ }

  public House getHouse()
  { /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { /* omitted */ }

  public void setHouse(House newHouse)
  { /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet make a noise.
   * Algorithm: 
   * This is an abstract method and should be implemented by subclasses (Dog and Cat).
   * Input: 
   *  - None
   * Output: 
   *  - None (or possibly a sound representation, depending on the implementation)
   * Pre-condition: 
   *  - None
   * Post-condition: 
   *  - The pet makes its characteristic noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public abstract void makeNoise();

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { /* omitted */ }

  @Override
  public String toString()
  { /* omitted */ }

} // Pet
699067 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public House getHouse()
  { ... /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { ... /* omitted */ }

  public void setHouse(House newHouse)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet make a noise.
   * Algorithm: 
   * This is an abstract method and should be implemented by subclasses (Dog and Cat).
   * Input: 
   *  - None
   * Output: 
   *  - None (or possibly a sound representation, depending on the implementation)
   * Pre-condition: 
   *  - None
   * Post-condition: 
   *  - The pet makes its characteristic noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void makeNoise()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `House` contains the following methods.
  + Instance creation: Use `PetsFactory.eINSTANCE.createHouse()`
  + Public methods: public EList<String> retrievePetNames(), public boolean addPet(final Pet pet), public void removePet(final Pet pet), public EList<Pet> getPetsByType(final String type), public int getPetCount(final String type)
  + Getter methods: public EList<Pet> getLived()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { /* omitted */ }

  public String getName()
  { /* omitted */ }

  public void setName(String newName)
  { /* omitted */ }

  public House getHouse()
  { /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { /* omitted */ }

  public void setHouse(House newHouse)
  { /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet make a noise.
   * Algorithm: 
   * This is an abstract method and should be implemented by subclasses (Dog and Cat).
   * Input: 
   *  - None
   * Output: 
   *  - None (or possibly a sound representation, depending on the implementation)
   * Pre-condition: 
   *  - None
   * Post-condition: 
   *  - The pet makes its characteristic noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public abstract void makeNoise();

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { /* omitted */ }

  @Override
  public String toString()
  { /* omitted */ }

} // Pet
712392 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
712392 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - Failed after maximum retry
712392 [main] ERROR .sei.mde.mwe2.EMFGeneratorFragment2  - Failed to execute EMF generator
java.lang.RuntimeException: Failed after maximum retry
	at edu.ustb.sei.mde.mwe2.enhancement.CodewareEnhancement.doEnhancementWithRetry(CodewareEnhancement.java:75)
	at edu.ustb.sei.mde.mwe2.enhancement.CodewareEnhancement.lambda$1(CodewareEnhancement.java:40)
	at com.google.common.collect.Iterables$4.lambda$forEach$0(Iterables.java:588)
	at com.google.common.collect.Iterables$4.lambda$forEach$0(Iterables.java:588)
	at java.base/java.lang.Iterable.forEach(Iterable.java:75)
	at com.google.common.collect.Iterables$4.forEach(Iterables.java:585)
	at com.google.common.collect.Iterables$4.forEach(Iterables.java:585)
	at edu.ustb.sei.mde.mwe2.enhancement.CodewareEnhancement.enhance(CodewareEnhancement.java:42)
	at edu.ustb.sei.mde.mwe2.enhancement.CompoundCodeEnhancement.enhance(CompoundCodeEnhancement.java:21)
	at edu.ustb.sei.mde.mwe2.EMFGeneratorFragment2.generate(EMFGeneratorFragment2.java:447)
	at org.eclipse.xtext.xtext.generator.CompositeGeneratorFragment2.generate(CompositeGeneratorFragment2.java:43)
	at edu.ustb.sei.mde.mwe2.EcoreGenerator.invokeInternal(EcoreGenerator.java:222)
	at org.eclipse.emf.mwe.core.lib.AbstractWorkflowComponent.invoke(AbstractWorkflowComponent.java:133)
	at org.eclipse.emf.mwe.core.lib.Mwe2Bridge.invoke(Mwe2Bridge.java:35)
	at org.eclipse.emf.mwe.core.lib.AbstractWorkflowComponent.invoke(AbstractWorkflowComponent.java:213)
	at org.eclipse.emf.mwe2.runtime.workflow.AbstractCompositeWorkflowComponent.invoke(AbstractCompositeWorkflowComponent.java:38)
	at org.eclipse.emf.mwe2.runtime.workflow.Workflow.run(Workflow.java:21)
	at org.eclipse.emf.mwe2.launch.runtime.Mwe2Runner.run(Mwe2Runner.java:103)
	at org.eclipse.emf.mwe2.launch.runtime.Mwe2Runner.run(Mwe2Runner.java:63)
	at org.eclipse.emf.mwe2.launch.runtime.Mwe2Runner.run(Mwe2Runner.java:53)
	at org.eclipse.emf.mwe2.launch.runtime.Mwe2Launcher.run(Mwe2Launcher.java:78)
	at MainCLI.main(MainCLI.java:25)
712392 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
712393 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample5.mwe2 启动完成
正在拷贝 src-gen/edu/pets 到 llama-4-maverick/pets5...
拷贝完成！

======================================
所有任务完成！
======================================

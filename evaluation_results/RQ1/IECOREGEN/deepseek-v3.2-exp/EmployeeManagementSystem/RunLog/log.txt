  public NotificationChain basicSetCompany(Company newCompany, NotificationChain msgs)
  { ... /* omitted */ }

  public void setCompany(Company newCompany)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates average working hours per week for all workers in this department
   * Algorithm:
   *   totalHours = 0
   *   workerCount = 0
   *   FOR EACH employee IN employees:
   *     IF employee IS Worker:
   *       totalHours += employee.weeklyWorkingHour
   *       workerCount++
   *   IF workerCount = 0:
   *     RETURN 0
   *   ELSE:
   *     RETURN totalHours / workerCount
   * Input: None
   * Output: Average working hours as double (non-negative), returns 0 if no workers in department
   * Pre-condition: employees list is initialized
   * Post-condition: Returns arithmetic mean of weeklyWorkingHour for all workers in this department
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateAverageWorkerWorkingHours()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Department
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Manager` contains the following methods.
  + Instance creation: Use `EmployeeFactory.eINSTANCE.createManager()`
  + Public methods: public int getDirectSubordinateEmployeesCount()
  + Getter methods: , , , , , public double getSalary(), public String getPosition(), public EList<Employee> getSubordinates()
  + Setter methods: , , , , , public void setSalary(double newSalary), public void setPosition(String newPosition)
- Class `Employee` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: public String getDepartment(), public Date getBirthDate(), public String getName(), public String getSocialInsuranceNumber(), public Company getCompany()
  + Setter methods: public void setDepartment(String newDepartment), public void setBirthDate(Date newBirthDate), public void setName(String newName), public void setSocialInsuranceNumber(String newSocialInsuranceNumber), public void setCompany(Company newCompany)
- Class `Company` contains the following methods.
  + Instance creation: Use `EmployeeFactory.eINSTANCE.createCompany()`
  + Public methods: public double calculateTotalEmployeeSalary(), public double calculateTotalSalesPeopleCommission(), public double calculateTotalShiftWorkerHolidayPremiums()
  + Getter methods: public EList<Department> getDepartments(), public EList<Employee> getEmployees()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Department</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.Department#getType <em>Type</em>}</li>
 *   <li>{@link edu.employee.Department#getManager <em>Manager</em>}</li>
 *   <li>{@link edu.employee.Department#getEmployees <em>Employees</em>}</li>
 *   <li>{@link edu.employee.Department#getCompany <em>Company</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getDepartment()
 * @model kind="class"
 * @generated
 */
public class Department extends MinimalEObjectImpl.Container implements EObject
{
  protected static final DepartmentType TYPE_EDEFAULT = DepartmentType.PRODUCTION;

  protected DepartmentType type = TYPE_EDEFAULT;

  protected Manager manager;

  protected EList<Employee> employees;

  protected Department()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public DepartmentType getType()
  { ... /* omitted */ }

  public void setType(DepartmentType newType)
  { ... /* omitted */ }

  public Manager getManager()
  { ... /* omitted */ }

  public Manager basicGetManager()
  { ... /* omitted */ }

  public void setManager(Manager newManager)
  { ... /* omitted */ }

  public EList<Employee> getEmployees()
  { ... /* omitted */ }

  public Company getCompany()
  { ... /* omitted */ }

  public NotificationChain basicSetCompany(Company newCompany, NotificationChain msgs)
  { ... /* omitted */ }

  public void setCompany(Company newCompany)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates average working hours per week for all workers in this department
   * Algorithm:
   *   totalHours = 0
   *   workerCount = 0
   *   FOR EACH employee IN employees:
   *     IF employee IS Worker:
   *       totalHours += employee.weeklyWorkingHour
   *       workerCount++
   *   IF workerCount = 0:
   *     RETURN 0
   *   ELSE:
   *     RETURN totalHours / workerCount
   * Input: None
   * Output: Average working hours as double (non-negative), returns 0 if no workers in department
   * Pre-condition: employees list is initialized
   * Post-condition: Returns arithmetic mean of weeklyWorkingHour for all workers in this department
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateAverageWorkerWorkingHours()
  {
    double totalHours = 0;
    int workerCount = 0;
    
    if (employees != null) {
      for (Employee employee : employees) {
        if (employee instanceof Worker) {
          Worker worker = (Worker) employee;
          totalHours += worker.getWeeklyWorkingHour();
          workerCount++;
        }
      }
    }
    
    if (workerCount == 0) {
      return 0;
    } else {
      return totalHours / workerCount;
    }
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Department
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Company</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.Company#getDepartments <em>Departments</em>}</li>
 *   <li>{@link edu.employee.Company#getEmployees <em>Employees</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getCompany()
 * @model kind="class"
 * @generated
 */
public class Company extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Department> departments;

  protected EList<Employee> employees;

  protected Company()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Department> getDepartments()
  { ... /* omitted */ }

  public EList<Employee> getEmployees()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total salary of all employees in the company by summing up salaries from workers, salespeople, and managers.
   * Algorithm:
   *   totalSalary = 0
   *   FOR EACH employee IN employees:
   *     IF employee IS Worker:
   *       workerSalary = employee.weeklyWorkingHour * employee.hourlyRates
   *       IF employee IS ShiftWorker:
   *         workerSalary += employee.calculateHolidayPremium()
   *       totalSalary += workerSalary
   *     ELSE IF employee IS SalesPeople:
   *       totalSalary += employee.salary + employee.getTotalCommission()
   *     ELSE IF employee IS Manager:
   *       totalSalary += employee.salary
   *   RETURN totalSalary
   * Input: None
   * Output: Total salary value as double (non-negative)
   * Pre-condition: employees list is initialized
   * Post-condition: Returns sum of all employee salaries according to their type-specific calculation rules
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateTotalEmployeeSalary()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total commission amount for all salespeople in the company
   * Algorithm:
   *   totalCommission = 0
   *   FOR EACH employee IN employees:
   *     IF employee IS SalesPeople:
   *       totalCommission += employee.getTotalCommission()
   *   RETURN totalCommission
   * Input: None
   * Output: Total commission value as double (non-negative)
   * Pre-condition: employees list is initialized
   * Post-condition: Returns sum of (amountOfSales * commissionPercentage) for all salespeople
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateTotalSalesPeopleCommission()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates total holiday premiums paid to all shift workers in the company
   * Algorithm:
   *   totalPremiums = 0
   *   FOR EACH employee IN employees:
   *     IF employee IS ShiftWorker AND employee.department = DepartmentType.DELIVERY:
   *       totalPremiums += employee.calculateHolidayPremium()
   *   RETURN totalPremiums
   * Input: None
   * Output: Total holiday premium value as double (non-negative)
   * Pre-condition: employees list is initialized
   * Post-condition: Returns sum of holiday premiums for all shift workers in delivery department, or 0 if none exist
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateTotalShiftWorkerHolidayPremiums()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Company
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Department` contains the following methods.
  + Instance creation: Use `EmployeeFactory.eINSTANCE.createDepartment()`
  + Public methods: public double calculateAverageWorkerWorkingHours()
  + Getter methods: public DepartmentType getType(), public Manager getManager(), public EList<Employee> getEmployees(), public Company getCompany()
  + Setter methods: public void setType(DepartmentType newType), public void setManager(Manager newManager), public void setCompany(Company newCompany)
- Class `Employee` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: public String getDepartment(), public Date getBirthDate(), public String getName(), public String getSocialInsuranceNumber(), public Company getCompany()
  + Setter methods: public void setDepartment(String newDepartment), public void setBirthDate(Date newBirthDate), public void setName(String newName), public void setSocialInsuranceNumber(String newSocialInsuranceNumber), public void setCompany(Company newCompany)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Company</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.Company#getDepartments <em>Departments</em>}</li>
 *   <li>{@link edu.employee.Company#getEmployees <em>Employees</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getCompany()
 * @model kind="class"
 * @generated
 */
public class Company extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Department> departments;

  protected EList<Employee> employees;

  protected Company()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Department> getDepartments()
  { ... /* omitted */ }

  public EList<Employee> getEmployees()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total salary of all employees in the company by summing up salaries from workers, salespeople, and managers.
   * Algorithm:
   *   totalSalary = 0
   *   FOR EACH employee IN employees:
   *     IF employee IS Worker:
   *       workerSalary = employee.weeklyWorkingHour * employee.hourlyRates
   *       IF employee IS ShiftWorker:
   *         workerSalary += employee.calculateHolidayPremium()
   *       totalSalary += workerSalary
   *     ELSE IF employee IS SalesPeople:
   *       totalSalary += employee.salary + employee.getTotalCommission()
   *     ELSE IF employee IS Manager:
   *       totalSalary += employee.salary
   *   RETURN totalSalary
   * Input: None
   * Output: Total salary value as double (non-negative)
   * Pre-condition: employees list is initialized
   * Post-condition: Returns sum of all employee salaries according to their type-specific calculation rules
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateTotalEmployeeSalary()
  {
    double totalSalary = 0;
    for (Employee employee : getEmployees()) {
      if (employee instanceof Worker) {
        Worker worker = (Worker) employee;
        double workerSalary = worker.getWeeklyWorkingHour() * worker.getHourlyRates();
        if (employee instanceof ShiftWorker) {
          ShiftWorker shiftWorker = (ShiftWorker) employee;
          workerSalary += shiftWorker.calculateHolidayPremium();
        }
        totalSalary += workerSalary;
      } else if (employee instanceof SalesPeople) {
        SalesPeople salesPerson = (SalesPeople) employee;
        totalSalary += salesPerson.getSalary() + salesPerson.getTotalCommission();
      } else if (employee instanceof Manager) {
        Manager manager = (Manager) employee;
        totalSalary += manager.getSalary();
      }
    }
    return totalSalary;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total commission amount for all salespeople in the company
   * Algorithm:
   *   totalCommission = 0
   *   FOR EACH employee IN employees:
   *     IF employee IS SalesPeople:
   *       totalCommission += employee.getTotalCommission()
   *   RETURN totalCommission
   * Input: None
   * Output: Total commission value as double (non-negative)
   * Pre-condition: employees list is initialized
   * Post-condition: Returns sum of (amountOfSales * commissionPercentage) for all salespeople
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateTotalSalesPeopleCommission()
  {
    double totalCommission = 0;
    for (Employee employee : getEmployees()) {
      if (employee instanceof SalesPeople) {
        SalesPeople salesPerson = (SalesPeople) employee;
        totalCommission += salesPerson.getTotalCommission();
      }
    }
    return totalCommission;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates total holiday premiums paid to all shift workers in the company
   * Algorithm:
   *   totalPremiums = 0
   *   FOR EACH employee IN employees:
   *     IF employee IS ShiftWorker AND employee.department = DepartmentType.DELIVERY:
   *       totalPremiums += employee.calculateHolidayPremium()
   *   RETURN totalPremiums
   * Input: None
   * Output: Total holiday premium value as double (non-negative)
   * Pre-condition: employees list is initialized
   * Post-condition: Returns sum of holiday premiums for all shift workers in delivery department, or 0 if none exist
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateTotalShiftWorkerHolidayPremiums()
  {
    double totalPremiums = 0;
    for (Employee employee : getEmployees()) {
      if (employee instanceof ShiftWorker) {
        ShiftWorker shiftWorker = (ShiftWorker) employee;
        if (shiftWorker.getDepartment() != null && shiftWorker.getDepartment().equals("DELIVERY")) {
          totalPremiums += shiftWorker.calculateHolidayPremium();
        }
      }
    }
    return totalPremiums;
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Company
1297840 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../EmployeeManagementSystem/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../EmployeeManagementSystem/src-gen/edu/employee/
1297964 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
1297964 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
1297964 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
1297964 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
1297966 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample4.mwe2 启动完成
正在拷贝 src-gen/edu/employee 到 deepseek-v3.2-exp/employee4...
拷贝完成！

======================================
正在启动 sample5.mwe2...
======================================
1298211 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
1298267 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project EmployeeManagementSystem at 'file:/D:/EclipseWorkspace/EmployeeManagementSystem/'
1298269 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
1298275 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@398857f8
1298276 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
1298277 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
1298278 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
Employee Management System
A company has more than one employee. Each employee object contains information about the department, name, date of birth, and social insurance number. These employees are included in the categories of workers, sales people, and managers. In addition, while workers have information such as weekly working hours and hourly rates, the sales persons have information such as fixed salary, amount of sales made, and commission percentage. The managers only get a fixed salary, and have subordinates. Workers are separated as shift workers and non-shift workers. Off-shift workers have weekend and official holiday permits. Shift workers receive premiums for working on holidays. The company has production, control, and delivery departments. Each department has to be controlled by a manager. Shift workers can only work in the delivery department.
In addition to the above basic information, the manager object also has position information. 
Functional requirement:
+ Calculate the total salary of all employees in the company. Total salary = sum(workers' salary + sales people's salary + managers' salary). Workers' salary = weeklyWorkingHour * hourlyRates + [holiday premiums for shift workers]. Sales people's salary = salary + amountOfSales * commissionPercentage. Managers' salary = salary.

+ Find average working hours per week for all workers in the delivery department.  Return 0 if there are no workers in the delivery department.

+ Determine the total commission amount for all salespeople in the company. Sum(amountOfSales * commissionPercentage) for all salespeople.

+ Calculate total holiday premiums paid to all shift workers in the company.  Return 0 if there are no shift workers in the delivery department.

+ Get the number of direct subordinate employees for each manager. 
```

# Class Diagram
```plantuml
@startuml

title employee Model

class Company {
    departments : List<Department>
    employees : List<Employee>
    calculateTotalEmployeeSalary() : double
    calculateTotalSalesPeopleCommission() : double
    calculateTotalShiftWorkerHolidayPremiums() : double
}
class Department {
    type : DepartmentType
    company : Company
    employees : List<Employee>
    manager : Manager
    calculateAverageWorkerWorkingHours() : double
}
abstract class Employee {
    birthDate : EDate
    department : String
    name : String
    socialInsuranceNumber : String
    company : Company
}
class Manager {
    position : String
    salary : double
    subordinates : List<Employee>
    getDirectSubordinateEmployeesCount() : int
}
class OffShiftWorker {
}
class SalesPeople {
    amountOfSales : double
    commissionPercentage : double
    salary : double
    getTotalCommission() : double
}
class ShiftWorker {
    holidayPremium : double
    calculateHolidayPremium() : double
}
abstract class Worker {
    hourlyRates : double
    weeklyWorkingHour : int
}
enum DepartmentType {
    PRODUCTION
    CONTROL
    DELIVERY
}

Company *-- "*" Department : departments  'opposite: company
Company *-- "*" Employee : employees  'opposite: company
Department --> Company : company  'opposite: departments
Department --> "*" Employee : employees
Department --> Manager : manager
Employee --> Company : company  'opposite: employees
Manager --|> Employee
Manager --> "*" Employee : subordinates
OffShiftWorker --|> Worker
SalesPeople --|> Employee
ShiftWorker --|> Worker
Worker --|> Employee
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

1337598 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@2438702 (name: calculateTotalSalesPeopleCommission) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates the total commission amount for all salespeople in the company
Algorithm:
  1. Initialize totalCommission = 0
  2. For each employee in employees list:
      2.1. If employee is SalesPeople: totalCommission += getTotalCommission()
  3. Return totalCommission
Input: None
Output: Total commission amount as double value (>= 0)
Pre-condition: employees list is initialized
Post-condition: Returns sum of all salespeople commissions, org.eclipse.emf.ecore.impl.EOperationImpl@2c969f (name: calculateTotalEmployeeSalary) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates the total salary for all employees in the company by summing salaries from workers, salespeople, and managers
Algorithm:
  1. Initialize totalSalary = 0
  2. For each employee in employees list:
      2.1. If employee is Worker: totalSalary += weeklyWorkingHour * hourlyRates
      2.2. If employee is ShiftWorker: totalSalary += calculateHolidayPremium()
      2.3. If employee is SalesPeople: totalSalary += salary + getTotalCommission()
      2.4. If employee is Manager: totalSalary += salary
  3. Return totalSalary
Input: None
Output: Total salary amount as double value (>= 0)
Pre-condition: employees list is initialized and contains valid Employee objects
Post-condition: Returns sum of all employee salaries without modifying employee data, org.eclipse.emf.ecore.impl.EOperationImpl@346ea2ed (name: calculateHolidayPremium) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates the holiday premium for this shift worker
Algorithm:
  1. Return holidayPremium value
Note: The specific calculation logic for holiday premium is managed externally and stored in holidayPremium attribute
Input: None
Output: Holiday premium amount as double value (>= 0)
Pre-condition: holidayPremium is initialized with valid value
Post-condition: Returns holiday premium without modification, org.eclipse.emf.ecore.impl.EOperationImpl@632f505b (name: calculateAverageWorkerWorkingHours) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates average weekly working hours for all workers in this department
Algorithm:
  1. Initialize totalHours = 0, workerCount = 0
  2. For each employee in employees list:
      2.1. If employee is Worker: totalHours += weeklyWorkingHour, workerCount++
  3. If workerCount > 0: return totalHours / workerCount
  4. Else: return 0
Input: None
Output: Average working hours per week as double value (>= 0)
Pre-condition: employees list is initialized
Post-condition: Returns average working hours or 0 if no workers in department, org.eclipse.emf.ecore.impl.EOperationImpl@19b656b0 (name: getTotalCommission) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates the commission amount for this salesperson
Algorithm:
  1. Return amountOfSales * commissionPercentage
Input: None
Output: Commission amount as double value (>= 0)
Pre-condition: amountOfSales >= 0, commissionPercentage >= 0
Post-condition: Returns calculated commission without modifying object state, org.eclipse.emf.ecore.impl.EOperationImpl@3b22cae9 (name: calculateTotalShiftWorkerHolidayPremiums) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates total holiday premiums paid to all shift workers in the company
Algorithm:
  1. Initialize totalPremiums = 0
  2. For each employee in employees list:
      2.1. If employee is ShiftWorker: totalPremiums += calculateHolidayPremium()
  3. Return totalPremiums
Input: None
Output: Total holiday premium amount as double value (>= 0)
Pre-condition: employees list is initialized
Post-condition: Returns sum of all shift worker holiday premiums, org.eclipse.emf.ecore.impl.EOperationImpl@753aacf (name: getDirectSubordinateEmployeesCount) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Returns the number of direct subordinate employees for this manager
Algorithm:
  1. Return the size of subordinates list
Input: None
Output: Number of direct subordinates as integer (>= 0)
Pre-condition: subordinates list is initialized
Post-condition: Returns count of subordinates without modification}
1337600 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
1337626 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../EmployeeManagementSystem/src-gen/edu/employee
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.impl.ENotificationImpl;

import org.eclipse.emf.ecore.util.EObjectResolvingEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Manager</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.Manager#getSalary <em>Salary</em>}</li>
 *   <li>{@link edu.employee.Manager#getPosition <em>Position</em>}</li>
 *   <li>{@link edu.employee.Manager#getSubordinates <em>Subordinates</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getManager()
 * @model kind="class"
 * @generated
 */
public class Manager extends Employee
{
  protected static final double SALARY_EDEFAULT = 0.0;

  protected double salary = SALARY_EDEFAULT;

  protected static final String POSITION_EDEFAULT = null;

  protected String position = POSITION_EDEFAULT;

  protected EList<Employee> subordinates;

  protected Manager()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public double getSalary()
  { ... /* omitted */ }

  public void setSalary(double newSalary)
  { ... /* omitted */ }

  public String getPosition()
  { ... /* omitted */ }

  public void setPosition(String newPosition)
  { ... /* omitted */ }

  public EList<Employee> getSubordinates()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Returns the number of direct subordinate employees for this manager
   * Algorithm:
   *   1. Return the size of subordinates list
   * Input: None
   * Output: Number of direct subordinates as integer (>= 0)
   * Pre-condition: subordinates list is initialized
   * Post-condition: Returns count of subordinates without modification
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int getDirectSubordinateEmployeesCount()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Manager
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Employee` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: public String getDepartment(), public Date getBirthDate(), public String getName(), public String getSocialInsuranceNumber(), public Company getCompany()
  + Setter methods: public void setDepartment(String newDepartment), public void setBirthDate(Date newBirthDate), public void setName(String newName), public void setSocialInsuranceNumber(String newSocialInsuranceNumber), public void setCompany(Company newCompany)
- Class `Company` contains the following methods.
  + Instance creation: Use `EmployeeFactory.eINSTANCE.createCompany()`
  + Public methods: public double calculateTotalEmployeeSalary(), public double calculateTotalSalesPeopleCommission(), public double calculateTotalShiftWorkerHolidayPremiums()
  + Getter methods: public EList<Department> getDepartments(), public EList<Employee> getEmployees()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.impl.ENotificationImpl;

import org.eclipse.emf.ecore.util.EObjectResolvingEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Manager</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.Manager#getSalary <em>Salary</em>}</li>
 *   <li>{@link edu.employee.Manager#getPosition <em>Position</em>}</li>
 *   <li>{@link edu.employee.Manager#getSubordinates <em>Subordinates</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getManager()
 * @model kind="class"
 * @generated
 */
public class Manager extends Employee
{
  protected static final double SALARY_EDEFAULT = 0.0;

  protected double salary = SALARY_EDEFAULT;

  protected static final String POSITION_EDEFAULT = null;

  protected String position = POSITION_EDEFAULT;

  protected EList<Employee> subordinates;

  protected Manager()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public double getSalary()
  { ... /* omitted */ }

  public void setSalary(double newSalary)
  { ... /* omitted */ }

  public String getPosition()
  { ... /* omitted */ }

  public void setPosition(String newPosition)
  { ... /* omitted */ }

  public EList<Employee> getSubordinates()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Returns the number of direct subordinate employees for this manager
   * Algorithm:
   *   1. Return the size of subordinates list
   * Input: None
   * Output: Number of direct subordinates as integer (>= 0)
   * Pre-condition: subordinates list is initialized
   * Post-condition: Returns count of subordinates without modification
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int getDirectSubordinateEmployeesCount()
  {
    return getSubordinates().size();
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Manager
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.impl.ENotificationImpl;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Sales People</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.SalesPeople#getSalary <em>Salary</em>}</li>
 *   <li>{@link edu.employee.SalesPeople#getAmountOfSales <em>Amount Of Sales</em>}</li>
 *   <li>{@link edu.employee.SalesPeople#getCommissionPercentage <em>Commission Percentage</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getSalesPeople()
 * @model kind="class"
 * @generated
 */
public class SalesPeople extends Employee
{
  protected static final double SALARY_EDEFAULT = 0.0;

  protected double salary = SALARY_EDEFAULT;

  protected static final double AMOUNT_OF_SALES_EDEFAULT = 0.0;

  protected double amountOfSales = AMOUNT_OF_SALES_EDEFAULT;

  protected static final double COMMISSION_PERCENTAGE_EDEFAULT = 0.0;

  protected double commissionPercentage = COMMISSION_PERCENTAGE_EDEFAULT;

  protected SalesPeople()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public double getSalary()
  { ... /* omitted */ }

  public void setSalary(double newSalary)
  { ... /* omitted */ }

  public double getAmountOfSales()
  { ... /* omitted */ }

  public void setAmountOfSales(double newAmountOfSales)
  { ... /* omitted */ }

  public double getCommissionPercentage()
  { ... /* omitted */ }

  public void setCommissionPercentage(double newCommissionPercentage)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the commission amount for this salesperson
   * Algorithm:
   *   1. Return amountOfSales * commissionPercentage
   * Input: None
   * Output: Commission amount as double value (>= 0)
   * Pre-condition: amountOfSales >= 0, commissionPercentage >= 0
   * Post-condition: Returns calculated commission without modifying object state
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double getTotalCommission()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // SalesPeople
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Employee` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: public String getDepartment(), public Date getBirthDate(), public String getName(), public String getSocialInsuranceNumber(), public Company getCompany()
  + Setter methods: public void setDepartment(String newDepartment), public void setBirthDate(Date newBirthDate), public void setName(String newName), public void setSocialInsuranceNumber(String newSocialInsuranceNumber), public void setCompany(Company newCompany)
- Class `Company` contains the following methods.
  + Instance creation: Use `EmployeeFactory.eINSTANCE.createCompany()`
  + Public methods: public double calculateTotalEmployeeSalary(), public double calculateTotalSalesPeopleCommission(), public double calculateTotalShiftWorkerHolidayPremiums()
  + Getter methods: public EList<Department> getDepartments(), public EList<Employee> getEmployees()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.impl.ENotificationImpl;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Sales People</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.SalesPeople#getSalary <em>Salary</em>}</li>
 *   <li>{@link edu.employee.SalesPeople#getAmountOfSales <em>Amount Of Sales</em>}</li>
 *   <li>{@link edu.employee.SalesPeople#getCommissionPercentage <em>Commission Percentage</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getSalesPeople()
 * @model kind="class"
 * @generated
 */
public class SalesPeople extends Employee
{
  protected static final double SALARY_EDEFAULT = 0.0;

  protected double salary = SALARY_EDEFAULT;

  protected static final double AMOUNT_OF_SALES_EDEFAULT = 0.0;

  protected double amountOfSales = AMOUNT_OF_SALES_EDEFAULT;

  protected static final double COMMISSION_PERCENTAGE_EDEFAULT = 0.0;

  protected double commissionPercentage = COMMISSION_PERCENTAGE_EDEFAULT;

  protected SalesPeople()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public double getSalary()
  { ... /* omitted */ }

  public void setSalary(double newSalary)
  { ... /* omitted */ }

  public double getAmountOfSales()
  { ... /* omitted */ }

  public void setAmountOfSales(double newAmountOfSales)
  { ... /* omitted */ }

  public double getCommissionPercentage()
  { ... /* omitted */ }

  public void setCommissionPercentage(double newCommissionPercentage)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the commission amount for this salesperson
   * Algorithm:
   *   1. Return amountOfSales * commissionPercentage
   * Input: None
   * Output: Commission amount as double value (>= 0)
   * Pre-condition: amountOfSales >= 0, commissionPercentage >= 0
   * Post-condition: Returns calculated commission without modifying object state
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double getTotalCommission()
  {
    return amountOfSales * commissionPercentage;
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // SalesPeople
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.impl.ENotificationImpl;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Shift Worker</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.ShiftWorker#getHolidayPremium <em>Holiday Premium</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getShiftWorker()
 * @model kind="class"
 * @generated
 */
public class ShiftWorker extends Worker
{
  protected static final double HOLIDAY_PREMIUM_EDEFAULT = 0.0;

  protected double holidayPremium = HOLIDAY_PREMIUM_EDEFAULT;

  protected ShiftWorker()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public double getHolidayPremium()
  { ... /* omitted */ }

  public void setHolidayPremium(double newHolidayPremium)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the holiday premium for this shift worker
   * Algorithm:
   *   1. Return holidayPremium value
   * Note: The specific calculation logic for holiday premium is managed externally and stored in holidayPremium attribute
   * Input: None
   * Output: Holiday premium amount as double value (>= 0)
   * Pre-condition: holidayPremium is initialized with valid value
   * Post-condition: Returns holiday premium without modification
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateHolidayPremium()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // ShiftWorker
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Employee` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: public String getDepartment(), public Date getBirthDate(), public String getName(), public String getSocialInsuranceNumber(), public Company getCompany()
  + Setter methods: public void setDepartment(String newDepartment), public void setBirthDate(Date newBirthDate), public void setName(String newName), public void setSocialInsuranceNumber(String newSocialInsuranceNumber), public void setCompany(Company newCompany)
- Class `Worker` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: , , , , , public int getWeeklyWorkingHour(), public double getHourlyRates()
  + Setter methods: , , , , , public void setWeeklyWorkingHour(int newWeeklyWorkingHour), public void setHourlyRates(double newHourlyRates)
- Class `Company` contains the following methods.
  + Instance creation: Use `EmployeeFactory.eINSTANCE.createCompany()`
  + Public methods: public double calculateTotalEmployeeSalary(), public double calculateTotalSalesPeopleCommission(), public double calculateTotalShiftWorkerHolidayPremiums()
  + Getter methods: public EList<Department> getDepartments(), public EList<Employee> getEmployees()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.impl.ENotificationImpl;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Shift Worker</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.ShiftWorker#getHolidayPremium <em>Holiday Premium</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getShiftWorker()
 * @model kind="class"
 * @generated
 */
public class ShiftWorker extends Worker
{
  protected static final double HOLIDAY_PREMIUM_EDEFAULT = 0.0;

  protected double holidayPremium = HOLIDAY_PREMIUM_EDEFAULT;

  protected ShiftWorker()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public double getHolidayPremium()
  { ... /* omitted */ }

  public void setHolidayPremium(double newHolidayPremium)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the holiday premium for this shift worker
   * Algorithm:
   *   1. Return holidayPremium value
   * Note: The specific calculation logic for holiday premium is managed externally and stored in holidayPremium attribute
   * Input: None
   * Output: Holiday premium amount as double value (>= 0)
   * Pre-condition: holidayPremium is initialized with valid value
   * Post-condition: Returns holiday premium without modification
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateHolidayPremium()
  {
    // Return the holiday premium value
    return holidayPremium;
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // ShiftWorker
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Department</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.Department#getType <em>Type</em>}</li>
 *   <li>{@link edu.employee.Department#getManager <em>Manager</em>}</li>
 *   <li>{@link edu.employee.Department#getEmployees <em>Employees</em>}</li>
 *   <li>{@link edu.employee.Department#getCompany <em>Company</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getDepartment()
 * @model kind="class"
 * @generated
 */
public class Department extends MinimalEObjectImpl.Container implements EObject
{
  protected static final DepartmentType TYPE_EDEFAULT = DepartmentType.PRODUCTION;

  protected DepartmentType type = TYPE_EDEFAULT;

  protected Manager manager;

  protected EList<Employee> employees;

  protected Department()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public DepartmentType getType()
  { ... /* omitted */ }

  public void setType(DepartmentType newType)
  { ... /* omitted */ }

  public Manager getManager()
  { ... /* omitted */ }

  public Manager basicGetManager()
  { ... /* omitted */ }

  public void setManager(Manager newManager)
  { ... /* omitted */ }

  public EList<Employee> getEmployees()
  { ... /* omitted */ }

  public Company getCompany()
  { ... /* omitted */ }

  public NotificationChain basicSetCompany(Company newCompany, NotificationChain msgs)
  { ... /* omitted */ }

  public void setCompany(Company newCompany)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates average weekly working hours for all workers in this department
   * Algorithm:
   *   1. Initialize totalHours = 0, workerCount = 0
   *   2. For each employee in employees list:
   *       2.1. If employee is Worker: totalHours += weeklyWorkingHour, workerCount++
   *   3. If workerCount > 0: return totalHours / workerCount
   *   4. Else: return 0
   * Input: None
   * Output: Average working hours per week as double value (>= 0)
   * Pre-condition: employees list is initialized
   * Post-condition: Returns average working hours or 0 if no workers in department
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateAverageWorkerWorkingHours()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Department
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Manager` contains the following methods.
  + Instance creation: Use `EmployeeFactory.eINSTANCE.createManager()`
  + Public methods: public int getDirectSubordinateEmployeesCount()
  + Getter methods: , , , , , public double getSalary(), public String getPosition(), public EList<Employee> getSubordinates()
  + Setter methods: , , , , , public void setSalary(double newSalary), public void setPosition(String newPosition)
- Class `Employee` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: public String getDepartment(), public Date getBirthDate(), public String getName(), public String getSocialInsuranceNumber(), public Company getCompany()
  + Setter methods: public void setDepartment(String newDepartment), public void setBirthDate(Date newBirthDate), public void setName(String newName), public void setSocialInsuranceNumber(String newSocialInsuranceNumber), public void setCompany(Company newCompany)
- Class `Company` contains the following methods.
  + Instance creation: Use `EmployeeFactory.eINSTANCE.createCompany()`
  + Public methods: public double calculateTotalEmployeeSalary(), public double calculateTotalSalesPeopleCommission(), public double calculateTotalShiftWorkerHolidayPremiums()
  + Getter methods: public EList<Department> getDepartments(), public EList<Employee> getEmployees()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Department</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.Department#getType <em>Type</em>}</li>
 *   <li>{@link edu.employee.Department#getManager <em>Manager</em>}</li>
 *   <li>{@link edu.employee.Department#getEmployees <em>Employees</em>}</li>
 *   <li>{@link edu.employee.Department#getCompany <em>Company</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getDepartment()
 * @model kind="class"
 * @generated
 */
public class Department extends MinimalEObjectImpl.Container implements EObject
{
  protected static final DepartmentType TYPE_EDEFAULT = DepartmentType.PRODUCTION;

  protected DepartmentType type = TYPE_EDEFAULT;

  protected Manager manager;

  protected EList<Employee> employees;

  protected Department()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public DepartmentType getType()
  { ... /* omitted */ }

  public void setType(DepartmentType newType)
  { ... /* omitted */ }

  public Manager getManager()
  { ... /* omitted */ }

  public Manager basicGetManager()
  { ... /* omitted */ }

  public void setManager(Manager newManager)
  { ... /* omitted */ }

  public EList<Employee> getEmployees()
  { ... /* omitted */ }

  public Company getCompany()
  { ... /* omitted */ }

  public NotificationChain basicSetCompany(Company newCompany, NotificationChain msgs)
  { ... /* omitted */ }

  public void setCompany(Company newCompany)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates average weekly working hours for all workers in this department
   * Algorithm:
   *   1. Initialize totalHours = 0, workerCount = 0
   *   2. For each employee in employees list:
   *       2.1. If employee is Worker: totalHours += weeklyWorkingHour, workerCount++
   *   3. If workerCount > 0: return totalHours / workerCount
   *   4. Else: return 0
   * Input: None
   * Output: Average working hours per week as double value (>= 0)
   * Pre-condition: employees list is initialized
   * Post-condition: Returns average working hours or 0 if no workers in department
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateAverageWorkerWorkingHours()
  {
    double totalHours = 0;
    int workerCount = 0;
    
    if (employees != null) {
      for (Employee employee : employees) {
        if (employee instanceof Worker) {
          Worker worker = (Worker) employee;
          totalHours += worker.getWeeklyWorkingHour();
          workerCount++;
        }
      }
    }
    
    if (workerCount > 0) {
      return totalHours / workerCount;
    } else {
      return 0;
    }
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Department
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Company</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.Company#getDepartments <em>Departments</em>}</li>
 *   <li>{@link edu.employee.Company#getEmployees <em>Employees</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getCompany()
 * @model kind="class"
 * @generated
 */
public class Company extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Department> departments;

  protected EList<Employee> employees;

  protected Company()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Department> getDepartments()
  { ... /* omitted */ }

  public EList<Employee> getEmployees()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total salary for all employees in the company by summing salaries from workers, salespeople, and managers
   * Algorithm:
   *   1. Initialize totalSalary = 0
   *   2. For each employee in employees list:
   *       2.1. If employee is Worker: totalSalary += weeklyWorkingHour * hourlyRates
   *       2.2. If employee is ShiftWorker: totalSalary += calculateHolidayPremium()
   *       2.3. If employee is SalesPeople: totalSalary += salary + getTotalCommission()
   *       2.4. If employee is Manager: totalSalary += salary
   *   3. Return totalSalary
   * Input: None
   * Output: Total salary amount as double value (>= 0)
   * Pre-condition: employees list is initialized and contains valid Employee objects
   * Post-condition: Returns sum of all employee salaries without modifying employee data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateTotalEmployeeSalary()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total commission amount for all salespeople in the company
   * Algorithm:
   *   1. Initialize totalCommission = 0
   *   2. For each employee in employees list:
   *       2.1. If employee is SalesPeople: totalCommission += getTotalCommission()
   *   3. Return totalCommission
   * Input: None
   * Output: Total commission amount as double value (>= 0)
   * Pre-condition: employees list is initialized
   * Post-condition: Returns sum of all salespeople commissions
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateTotalSalesPeopleCommission()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates total holiday premiums paid to all shift workers in the company
   * Algorithm:
   *   1. Initialize totalPremiums = 0
   *   2. For each employee in employees list:
   *       2.1. If employee is ShiftWorker: totalPremiums += calculateHolidayPremium()
   *   3. Return totalPremiums
   * Input: None
   * Output: Total holiday premium amount as double value (>= 0)
   * Pre-condition: employees list is initialized
   * Post-condition: Returns sum of all shift worker holiday premiums
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateTotalShiftWorkerHolidayPremiums()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Company
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Department` contains the following methods.
  + Instance creation: Use `EmployeeFactory.eINSTANCE.createDepartment()`
  + Public methods: public double calculateAverageWorkerWorkingHours()
  + Getter methods: public DepartmentType getType(), public Manager getManager(), public EList<Employee> getEmployees(), public Company getCompany()
  + Setter methods: public void setType(DepartmentType newType), public void setManager(Manager newManager), public void setCompany(Company newCompany)
- Class `Employee` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: public String getDepartment(), public Date getBirthDate(), public String getName(), public String getSocialInsuranceNumber(), public Company getCompany()
  + Setter methods: public void setDepartment(String newDepartment), public void setBirthDate(Date newBirthDate), public void setName(String newName), public void setSocialInsuranceNumber(String newSocialInsuranceNumber), public void setCompany(Company newCompany)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Company</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.Company#getDepartments <em>Departments</em>}</li>
 *   <li>{@link edu.employee.Company#getEmployees <em>Employees</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getCompany()
 * @model kind="class"
 * @generated
 */
public class Company extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Department> departments;

  protected EList<Employee> employees;

  protected Company()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Department> getDepartments()
  { ... /* omitted */ }

  public EList<Employee> getEmployees()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total salary for all employees in the company by summing salaries from workers, salespeople, and managers
   * Algorithm:
   *   1. Initialize totalSalary = 0
   *   2. For each employee in employees list:
   *       2.1. If employee is Worker: totalSalary += weeklyWorkingHour * hourlyRates
   *       2.2. If employee is ShiftWorker: totalSalary += calculateHolidayPremium()
   *       2.3. If employee is SalesPeople: totalSalary += salary + getTotalCommission()
   *       2.4. If employee is Manager: totalSalary += salary
   *   3. Return totalSalary
   * Input: None
   * Output: Total salary amount as double value (>= 0)
   * Pre-condition: employees list is initialized and contains valid Employee objects
   * Post-condition: Returns sum of all employee salaries without modifying employee data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateTotalEmployeeSalary()
  {
    double totalSalary = 0.0;
    EList<Employee> employeesList = getEmployees();
    
    for (Employee employee : employeesList) {
      if (employee instanceof Worker) {
        Worker worker = (Worker) employee;
        totalSalary += worker.getWeeklyWorkingHour() * worker.getHourlyRates();
      } else if (employee instanceof ShiftWorker) {
        ShiftWorker shiftWorker = (ShiftWorker) employee;
        totalSalary += shiftWorker.calculateHolidayPremium();
      } else if (employee instanceof SalesPeople) {
        SalesPeople salesPerson = (SalesPeople) employee;
        totalSalary += salesPerson.getSalary() + salesPerson.getTotalCommission();
      } else if (employee instanceof Manager) {
        Manager manager = (Manager) employee;
        totalSalary += manager.getSalary();
      }
    }
    
    return totalSalary;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total commission amount for all salespeople in the company
   * Algorithm:
   *   1. Initialize totalCommission = 0
   *   2. For each employee in employees list:
   *       2.1. If employee is SalesPeople: totalCommission += getTotalCommission()
   *   3. Return totalCommission
   * Input: None
   * Output: Total commission amount as double value (>= 0)
   * Pre-condition: employees list is initialized
   * Post-condition: Returns sum of all salespeople commissions
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateTotalSalesPeopleCommission()
  {
    double totalCommission = 0.0;
    EList<Employee> employeesList = getEmployees();
    
    for (Employee employee : employeesList) {
      if (employee instanceof SalesPeople) {
        SalesPeople salesPerson = (SalesPeople) employee;
        totalCommission += salesPerson.getTotalCommission();
      }
    }
    
    return totalCommission;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates total holiday premiums paid to all shift workers in the company
   * Algorithm:
   *   1. Initialize totalPremiums = 0
   *   2. For each employee in employees list:
   *       2.1. If employee is ShiftWorker: totalPremiums += calculateHolidayPremium()
   *   3. Return totalPremiums
   * Input: None
   * Output: Total holiday premium amount as double value (>= 0)
   * Pre-condition: employees list is initialized
   * Post-condition: Returns sum of all shift worker holiday premiums
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateTotalShiftWorkerHolidayPremiums()
  {
    double totalPremiums = 0.0;
    EList<Employee> employeesList = getEmployees();
    
    for (Employee employee : employeesList) {
      if (employee instanceof ShiftWorker) {
        ShiftWorker shiftWorker = (ShiftWorker) employee;
        totalPremiums += shiftWorker.calculateHolidayPremium();
      }
    }
    
    return totalPremiums;
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Company
1552694 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../EmployeeManagementSystem/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../EmployeeManagementSystem/src-gen/edu/employee/
1552830 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
1552830 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
1552830 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
1552830 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
1552831 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample5.mwe2 启动完成
正在拷贝 src-gen/edu/employee 到 deepseek-v3.2-exp/employee5...
拷贝完成！

======================================
所有任务完成！
======================================

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Represents a customer of the video rental store.
 */
 class Customer {

    /** Unique account number of the customer. */
    private int accountNumber;

    /** Customer's full name. */
    private String name;

    /** All rental transactions ever created for this customer. */
    private List<RentalTransaction> rentals;

    /** No‑argument constructor required by the specification. */
    public Customer() {
        this.rentals = new ArrayList<>();
    }

    /* ---------- Getters & Setters ---------- */

    public int getAccountNumber() {
        return accountNumber;
    }

    public void setAccountNumber(int accountNumber) {
        this.accountNumber = accountNumber;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

   public List<RentalTransaction> getRentals() {
        return rentals;
    }

    public void setRentals(List<RentalTransaction> rentals) {
        this.rentals = rentals;
    }

    /**
     * Calculates the total past‑due amount for the customer.
     * The amount is the sum of overdue fees for all rentals that are still
     * un‑returned (returnDate == null) and whose due date has passed.
     *
     * @param today the date used for the calculation (normally LocalDate.now())
     * @return the total past‑due fee rounded to two decimal places
     */
    public double calculatePastDueAmount(LocalDate today) {
        double total = 0.0;
        for (RentalTransaction rt : rentals) {
            if (rt.getReturnDate() == null) {
                double fee = rt.calculateOverdueFee(today);
                total += fee;
            }
        }
        return round(total);
    }

    /**
     * Counts how many tapes the customer currently has outstanding
     * (i.e., rentals without a return date).
     *
     * @return number of active rentals
     */
    public int countActiveRentals() {
        int count = 0;
        for (RentalTransaction rt : rentals) {
            if (rt.getReturnDate() == null) {
                count++;
            }
        }
        return count;
    }

    /**
     * Helper method to round a double to two decimal places using
     * {@link BigDecimal}.
     *
     * @param value value to round
     * @return rounded value
     */
    private double round(double value) {
        return BigDecimal.valueOf(value)
                .setScale(2, RoundingMode.HALF_UP)
                .doubleValue();
    }
}

/**
 * Represents a video tape in the inventory.
 */
 class VideoTape {

    /** Barcode identifier of the tape. */
    private String barcodeId;

    /** Title of the video. */
    private String title;

    /** No‑argument constructor required by the specification. */
    public VideoTape() {
    }

    /* ---------- Getters & Setters ---------- */

    public String getBarcodeId() {
        return barcodeId;
    }

    public void setBarcodeId(String barcodeId) {
        this.barcodeId = barcodeId;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }
}

/**
 * Holds information about a single rental transaction.
 */
 class RentalTransaction {

    /** Unique identifier for the transaction (auto‑generated by the system). */
    private int transactionId;

    /** Customer that performed the rental. */
    private Customer customer;

    /** Video tape that was rented. */
    private VideoTape tape;

    /** Date the rental started. */
    private LocalDate rentalDate;

    /** Date the tape is due back (rentalDate + rentalDays). */
    private LocalDate dueDate;

    /** Date the tape was actually returned; null if not yet returned. */
    private LocalDate returnDate;

    /** Base rental fee (rental days × $1). */
    private double baseFee;

    /** No‑argument constructor required by the specification. */
    public RentalTransaction() {
    }

    /* ---------- Getters & Setters ---------- */

    public int getTransactionId() {
        return transactionId;
    }

    public void setTransactionId(int transactionId) {
        this.transactionId = transactionId;
    }

    public Customer getCustomer() {
        return customer;
    }

    public void setCustomer(Customer customer) {
        this.customer = customer;
    }

    public VideoTape getTape() {
        return tape;
    }

    public void setTape(VideoTape tape) {
        this.tape = tape;
    }

    public LocalDate getRentalDate() {
        return rentalDate;
    }

    public void setRentalDate(LocalDate rentalDate) {
        this.rentalDate = rentalDate;
    }

    public LocalDate getDueDate() {
        return dueDate;
    }

    public void setDueDate(LocalDate dueDate) {
        this.dueDate = dueDate;
    }

    public LocalDate getReturnDate() {
        return returnDate;
    }

    public void setReturnDate(LocalDate returnDate) {
        this.returnDate = returnDate;
    }

    public double getBaseFee() {
        return baseFee;
    }

    public void setBaseFee(double baseFee) {
        this.baseFee = baseFee;
    }

    /**
     * Calculates the overdue fee for this rental.
     * <p>
     * If {@code returnDate} is null the fee is based on the current date.
     * The fee is {@code overdueDays × $0.50} and is rounded to two decimal places.
     *
     * @param today the date used when the tape has not yet been returned
     * @return overdue fee (0 if the tape is not overdue)
     */
    public double calculateOverdueFee(LocalDate today) {
        LocalDate effectiveReturn = (returnDate != null) ? returnDate : today;
        long daysLate = ChronoUnit.DAYS.between(dueDate, effectiveReturn);
        if (daysLate <= 0) {
            return 0.0;
        }
        double fee = daysLate * 0.50;
        return round(fee);
    }

    /**
     * Calculates the total price for this transaction (base fee + overdue fee).
     *
     * @param today the date used when the tape has not yet been returned
     * @return total price rounded to two decimal places
     */
    public double calculateTotalPrice(LocalDate today) {
        double overdue = calculateOverdueFee(today);
        double total = baseFee + overdue;
        return round(total);
    }

    /**
     * Helper method to round a double to two decimal places.
     *
     * @param value value to round
     * @return rounded value
     */
    private double round(double value) {
        return BigDecimal.valueOf(value)
                .setScale(2, RoundingMode.HALF_UP)
                .doubleValue();
    }
}

/**
 * Central service class that manages customers, tapes, and rental transactions.
 */
 class RentalSystem {

    /** All customers known to the system (indexed by account number). */
    private List<Customer> customers;

    /** All video tapes in inventory (indexed by barcode). */
    private List<VideoTape> inventory;

    /** All rental transactions ever created. */
    private List<RentalTransaction> allTransactions;

    /** Simple counter for generating transaction IDs. */
    private int nextTransactionId = 1;

    /** No‑argument constructor required by the specification. */
    public RentalSystem() {
        this.customers = new ArrayList<>();
        this.inventory = new ArrayList<>();
        this.allTransactions = new ArrayList<>();
    }

    /* ---------- Getters & Setters ---------- */

    public List<Customer> getCustomers() {
        return customers;
    }

    public void setCustomers(List<Customer> customers) {
        this.customers = customers;
    }

    public List<VideoTape> getInventory() {
        return inventory;
    }

    public void setInventory(List<VideoTape> inventory) {
        this.inventory = inventory;
    }

    public List<RentalTransaction> getAllTransactions() {
        return allTransactions;
    }

    public void setAllTransactions(List<RentalTransaction> allTransactions) {
        this.allTransactions = allTransactions;
    }

    /**
     * Checks whether a specific tape is available for rent on the given date.
     * A tape is unavailable if it belongs to any active rental (returnDate == null).
     *
     * @param tapeId barcode of the tape to check
     * @param currentDate date on which availability is queried
     * @return {@code true} if the tape is free, {@code false} otherwise
     */
    public boolean isTapeAvailable(String tapeId, LocalDate currentDate) {
        for (RentalTransaction rt : allTransactions) {
            if (rt.getTape() != null && tapeId.equals(rt.getTape().getBarcodeId())) {
                if (rt.getReturnDate() == null) {
                    // The tape is currently rented out.
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Attempts to add a new video tape rental for a customer.
     * The method validates:
     * <ul>
     *   <li>Customer has fewer than 20 active rentals.</li>
     *   <li>Customer does not owe any past‑due amount.</li>
     *   <li>The tape is available for the requested date.</li>
     * </ul>
     *
     * @param accountNumber the customer's account number
     * @param tapeId the barcode of the tape to rent
     * @param rentalDate the start date of the rental
     * @param rentalDays number of days the customer intends to keep the tape
     * @return {@code true} if the rental is successfully created; {@code false} otherwise
     */
    public boolean addVideoTapeRental(int accountNumber, String tapeId,
                                      LocalDate rentalDate, int rentalDays) {
        Customer cust = findCustomerByAccount(accountNumber);
        if (cust == null) {
            return false; // unknown customer
        }

        // 1. Check active rental count
        if (cust.countActiveRentals() >= 20) {
            return false;
        }

        // 2. Check past‑due amount
        if (cust.calculatePastDueAmount(LocalDate.now()) > 0.0) {
            return false;
        }

        // 3. Check tape availability
        if (!isTapeAvailable(tapeId, rentalDate)) {
            return false;
        }

        VideoTape tape = findTapeById(tapeId);
        if (tape == null) {
            return false; // tape not found in inventory
        }

        // Create the transaction
        RentalTransaction rt = new RentalTransaction();
        rt.setTransactionId(nextTransactionId++);
        rt.setCustomer(cust);
        rt.setTape(tape);
        rt.setRentalDate(rentalDate);
        rt.setDueDate(rentalDate.plusDays(rentalDays));
        rt.setBaseFee(rentalDays * 1.0); // $1 per day

        // Register transaction
        cust.getRentals().add(rt);
        allTransactions.add(rt);
        return true;
    }

    /**
     * Calculates the total price for all active rentals of a given customer.
     * The total includes base rental fees and any overdue fees (if applicable).
     *
     * @param accountNumber the customer's account number
     * @return total amount rounded to two decimal places; 0.0 if the customer does not exist
     */
    public double calculateTotalPriceForCustomer(int accountNumber) {
        Customer cust = findCustomerByAccount(accountNumber);
        if (cust == null) {
            return 0.0;
        }

        double sum = 0.0;
        LocalDate today = LocalDate.now();
        for (RentalTransaction rt : cust.getRentals()) {
            // Only consider active rentals (returnDate may be null)
            sum += rt.calculateTotalPrice(today);
        }
        return round(sum);
    }

    /**
     * Retrieves a list of barcode IDs for all tapes that a customer has rented
     * and not yet returned.
     *
     * @param accountNumber the customer's account number
     * @return an immutable list of tape IDs; empty if none or customer not found
     */
    public List<String> listUnreturnedTapes(int accountNumber) {
        Customer cust = findCustomerByAccount(accountNumber);
        if (cust == null) {
            return Collections.emptyList();
        }

        List<String> result = new ArrayList<>();
        for (RentalTransaction rt : cust.getRentals()) {
            if (rt.getReturnDate() == null && rt.getTape() != null) {
                result.add(rt.getTape().getBarcodeId());
            }
        }
        return Collections.unmodifiableList(result);
    }

    /**
     * Marks a tape as returned on the given date.
     *
     * @param tapeId barcode of the tape being returned
     * @param returnDate the actual return date
     * @return {@code true} if the return was recorded; {@code false} if the tape
     *         could not be found in an active rental
     */
    public boolean recordReturn(String tapeId, LocalDate returnDate) {
        for (RentalTransaction rt : allTransactions) {
            if (rt.getTape() != null && tapeId.equals(rt.getTape().getBarcodeId())
                    && rt.getReturnDate() == null) {
                rt.setReturnDate(returnDate);
                return true;
            }
        }
        return false;
    }

    /**
     * Helper method to locate a customer by account number.
     *
     * @param accountNumber the account number to search for
     * @return matching {@link Customer} or {@code null} if not found
     */
    private Customer findCustomerByAccount(int accountNumber) {
        for (Customer c : customers) {
            if (c.getAccountNumber() == accountNumber) {
                return c;
            }
        }
        return null;
    }

    /**
     * Helper method to locate a video tape by its barcode.
     *
     * @param tapeId the barcode to search for
     * @return matching {@link VideoTape} or {@code null} if not found
     */
    private VideoTape findTapeById(String tapeId) {
        for (VideoTape vt : inventory) {
            if (tapeId.equals(vt.getBarcodeId())) {
                return vt;
            }
        }
        return null;
    }

    /**
     * Rounds a double to two decimal places using {@link BigDecimal}.
     *
     * @param value value to round
     * @return rounded value
     */
    private double round(double value) {
        return BigDecimal.valueOf(value)
                .setScale(2, RoundingMode.HALF_UP)
                .doubleValue();
    }
}
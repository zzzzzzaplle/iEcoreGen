package com.carrental.store;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * Represents the car rental store. It keeps track of the cars that are
 * available in the gallery, the rentals that have been performed and the
 * overdue notices that have been generated.
 */
 class Store {

    /** List of all cars that belong to the store */
    private List<Car> cars;

    /** List of all rentals performed by the store */
    private List<Rental> rentals;

    /** List of overdue notices that have been created */
    private List<OverdueNotice> notices;

    /** Default constructor â€“ creates empty collections */
    public Store() {
        this.cars = new ArrayList<>();
        this.rentals = new ArrayList<>();
        this.notices = new ArrayList<>();
    }

    /* --------------------------------------------------------------------- */
    /* Getters and Setters                                                   */
    /* --------------------------------------------------------------------- */

    public List<Car> getCars() {
        return cars;
    }

    public void setCars(List<Car> cars) {
        this.cars = cars;
    }

    public List<Rental> getRentals() {
        return rentals;
    }

    public void setRentals(List<Rental> rentals) {
        this.rentals = rentals;
    }

    public List<OverdueNotice> getNotices() {
        return notices;
    }

    public void setNotices(List<OverdueNotice> notices) {
        this.notices = notices;
    }

    /* --------------------------------------------------------------------- */
    /* Business methods                                                      */
    /* --------------------------------------------------------------------- */

    /**
     * Identifies all cars that are currently not rented.
     * <p>
     * A car is considered available when there is no active rental (i.e. a
     * rental whose {@code backDate} is {@code null}) that references this car.
     * The returned list is sorted by the car's daily price in ascending order.
     *
     * @return a list of available cars sorted by daily price; never {@code null}
     */
    public List<Car> identifyAvailableCars() {
        List<Car> available = new ArrayList<>();

        for (Car car : cars) {
            boolean isRented = false;
            for (Rental rental : rentals) {
                if (rental.getCar() != null && rental.getCar().equals(car) && rental.getBackDate() == null) {
                    isRented = true;
                    break;
                }
            }
            if (!isRented) {
                available.add(car);
            }
        }

        available.sort(Comparator.comparingDouble(Car::getDailyPrice));
        return available;
    }

    /**
     * Calculates the total revenue generated by all rentals stored in the
     * system. The revenue of each rental is stored in its {@code totalPrice}
     * field.
     *
     * @return the sum of all rental total prices; {@code 0.0} if there are no rentals
     */
    public double calculateTotalRevenue() {
        double total = 0.0;
        for (Rental rental : rentals) {
            total += rental.getTotalPrice();
        }
        return total;
    }

    /**
     * Finds all customers that have overdue rentals.
     * <p>
     * A rental is overdue when its {@code backDate} is {@code null} and the
     * supplied {@code currentDate} is after the {@code dueDate}.
     *
     * @param currentDate the date against which overdue status is evaluated; must not be {@code null}
     * @return a list of customers with at least one overdue rental; never {@code null}
     */
    public List<Customer> findCustomersWithOverdueRentals(Date currentDate) {
        if (currentDate == null) {
            throw new IllegalArgumentException("currentDate must not be null");
        }

        List<Customer> overdueCustomers = new ArrayList<>();
        for (Rental rental : rentals) {
            if (rental.getBackDate() == null && rental.getDueDate() != null && rental.getDueDate().before(currentDate)) {
                Customer cust = rental.getCustomer();
                if (cust != null && !overdueCustomers.contains(cust)) {
                    overdueCustomers.add(cust);
                }
            }
        }
        return overdueCustomers;
    }

    /**
     * Determines the average daily price of all cars stored in the gallery.
     *
     * @return the average daily price; {@code 0.0} when the store contains no cars
     */
    public double determineAverageDailyPrice() {
        if (cars.isEmpty()) {
            return 0.0;
        }
        double sum = 0.0;
        for (Car car : cars) {
            sum += car.getDailyPrice();
        }
        return sum / cars.size();
    }

    /**
     * Counts how many cars each customer has rented.
     *
     * @return a map where the key is a {@link Customer} and the value is the number of rentals
     *         performed by that customer; never {@code null}
     */
    public Map<Customer, Integer> countCarsRentedPerCustomer() {
        Map<Customer, Integer> countMap = new HashMap<>();
        for (Rental rental : rentals) {
            Customer cust = rental.getCustomer();
            if (cust != null) {
                countMap.put(cust, countMap.getOrDefault(cust, 0) + 1);
            }
        }
        return countMap;
    }

    /* --------------------------------------------------------------------- */
    /* Helper methods for external usage (optional)                           */
    /* --------------------------------------------------------------------- */

    /**
     * Adds a new car to the store's gallery.
     *
     * @param car the car to add; must not be {@code null}
     */
    public void addCar(Car car) {
        if (car == null) {
            throw new IllegalArgumentException("car must not be null");
        }
        this.cars.add(car);
    }

    /**
     * Registers a new rental.
     *
     * @param rental the rental to register; must not be {@code null}
     */
    public void addRental(Rental rental) {
        if (rental == null) {
            throw new IllegalArgumentException("rental must not be null");
        }
        this.rentals.add(rental);
    }

    /**
     * Generates overdue notices for all customers with overdue rentals.
     *
     * @param currentDate the date used to determine overdue status; must not be {@code null}
     */
    public void generateOverdueNotices(Date currentDate) {
        List<Customer> overdue = findCustomersWithOverdueRentals(currentDate);
        for (Customer cust : overdue) {
            OverdueNotice notice = new OverdueNotice();
            notice.setCustomer(cust);
            notice.sendNoticeTo(cust);
            this.notices.add(notice);
        }
    }
}

/* ------------------------------------------------------------------------- */
/* Supporting domain classes                                                */
/* ------------------------------------------------------------------------- */

/**
 * Represents a car that can be rented.
 */
class Car {

    private String plate;
    private String model;
    private double dailyPrice;

    /** Default constructor */
    public Car() {
    }

    /** Parameterized constructor for convenience */
    public Car(String plate, String model, double dailyPrice) {
        this.plate = plate;
        this.model = model;
        this.dailyPrice = dailyPrice;
    }

    // Getters and Setters
    public String getPlate() {
        return plate;
    }

    public void setPlate(String plate) {
        this.plate = plate;
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public double getDailyPrice() {
        return dailyPrice;
    }

    public void setDailyPrice(double dailyPrice) {
        this.dailyPrice = dailyPrice;
    }

    // Equality based on plate (unique identifier)
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Car car = (Car) o;
        return Objects.equals(plate, car.plate);
    }

    @Override
    public int hashCode() {
        return Objects.hash(plate);
    }

    @Override
    public String toString() {
        return "Car{" +
                "plate='" + plate + '\'' +
                ", model='" + model + '\'' +
                ", dailyPrice=" + dailyPrice +
                '}';
    }
}

/**
 * Represents a customer of the car rental store.
 */
class Customer {

    private String name;
    private String surname;
    private String address;
    private String rentedCarPlate; // the plate of the car currently rented (if any)

    /** Default constructor */
    public Customer() {
    }

    /** Parameterized constructor for convenience */
    public Customer(String name, String surname, String address, String rentedCarPlate) {
        this.name = name;
        this.surname = surname;
        this.address = address;
        this.rentedCarPlate = rentedCarPlate;
    }

    // Getters and Setters
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public String getRentedCarPlate() {
        return rentedCarPlate;
    }

    public void setRentedCarPlate(String rentedCarPlate) {
        this.rentedCarPlate = rentedCarPlate;
    }

    // Equality based on personal data (name, surname, address)
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Customer customer = (Customer) o;
        return Objects.equals(name, customer.name) &&
                Objects.equals(surname, customer.surname) &&
                Objects.equals(address, customer.address);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, surname, address);
    }

    @Override
    public String toString() {
        return "Customer{" +
                "name='" + name + '\'' +
                ", surname='" + surname + '\'' +
                ", address='" + address + '\'' +
                ", rentedCarPlate='" + rentedCarPlate + '\'' +
                '}';
    }
}

/**
 * Represents a rental transaction linking a {@link Car} with a {@link Customer}.
 */
class Rental {

    private Date rentalDate;
    private Date dueDate;
    private Date backDate; // null when the car has not been returned yet
    private double totalPrice;
    private String leasingTerms;
    private Car car;
    private Customer customer;

    /** Default constructor */
    public Rental() {
    }

    /** Parameterized constructor for convenience */
    public Rental(Date rentalDate, Date dueDate, Date backDate,
                  double totalPrice, String leasingTerms,
                  Car car, Customer customer) {
        this.rentalDate = rentalDate;
        this.dueDate = dueDate;
        this.backDate = backDate;
        this.totalPrice = totalPrice;
        this.leasingTerms = leasingTerms;
        this.car = car;
        this.customer = customer;
    }

    // Getters and Setters
    public Date getRentalDate() {
        return rentalDate;
    }

    public void setRentalDate(Date rentalDate) {
        this.rentalDate = rentalDate;
    }

    public Date getDueDate() {
        return dueDate;
    }

    public void setDueDate(Date dueDate) {
        this.dueDate = dueDate;
    }

    public Date getBackDate() {
        return backDate;
    }

    public void setBackDate(Date backDate) {
        this.backDate = backDate;
    }

    public double getTotalPrice() {
        return totalPrice;
    }

    public void setTotalPrice(double totalPrice) {
        this.totalPrice = totalPrice;
    }

    public String getLeasingTerms() {
        return leasingTerms;
    }

    public void setLeasingTerms(String leasingTerms) {
        this.leasingTerms = leasingTerms;
    }

    public Car getCar() {
        return car;
    }

    public void setCar(Car car) {
        this.car = car;
    }

    public Customer getCustomer() {
        return customer;
    }

    public void setCustomer(Customer customer) {
        this.customer = customer;
    }

    @Override
    public String toString() {
        return "Rental{" +
                "rentalDate=" + rentalDate +
                ", dueDate=" + dueDate +
                ", backDate=" + backDate +
                ", totalPrice=" + totalPrice +
                ", leasingTerms='" + leasingTerms + '\'' +
                ", car=" + car +
                ", customer=" + customer +
                '}';
    }
}

/**
 * Represents an overdue notice that can be sent to a {@link Customer}.
 */
class OverdueNotice {

    private Customer customer;

    /** Default constructor */
    public OverdueNotice() {
    }

    /** Parameterized constructor for convenience */
    public OverdueNotice(Customer customer) {
        this.customer = customer;
    }

    // Getter and Setter
    public Customer getCustomer() {
        return customer;
    }

    public void setCustomer(Customer customer) {
        this.customer = customer;
    }

    /**
     * Sends the overdue notice to the specified customer.
     *
     * @param customer the customer to notify; must not be {@code null}
     */
    public void sendNoticeTo(Customer customer) {
        if (customer == null) {
            throw new IllegalArgumentException("customer must not be null");
        }
        // In a real system this would trigger an email/SMS/etc.
        System.out.println("Overdue notice sent to " + customer.getName() + " " + customer.getSurname()
                + " (Address: " + customer.getAddress() + ").");
    }

    @Override
    public String toString() {
        return "OverdueNotice{" +
                "customer=" + customer +
                '}';
    }
}
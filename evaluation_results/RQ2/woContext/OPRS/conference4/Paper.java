/**
 * generated by Enhanced EcoreGen
 */
package edu.conference;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectWithInverseResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Paper</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.conference.Paper#getTitle <em>Title</em>}</li>
 *   <li>{@link edu.conference.Paper#getType <em>Type</em>}</li>
 *   <li>{@link edu.conference.Paper#getDecision <em>Decision</em>}</li>
 *   <li>{@link edu.conference.Paper#getReviews <em>Reviews</em>}</li>
 * </ul>
 *
 * @see edu.conference.ConferencePackage#getPaper()
 * @model kind="class"
 * @generated
 */
public class Paper extends MinimalEObjectImpl.Container implements EObject
{
  /**
   * The default value of the '{@link #getTitle() <em>Title</em>}' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getTitle()
   * @generated
   * @ordered
   */
  protected static final String TITLE_EDEFAULT = null;

  /**
   * The cached value of the '{@link #getTitle() <em>Title</em>}' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getTitle()
   * @generated
   * @ordered
   */
  protected String title = TITLE_EDEFAULT;

  /**
   * The default value of the '{@link #getType() <em>Type</em>}' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getType()
   * @generated
   * @ordered
   */
  protected static final PaperType TYPE_EDEFAULT = PaperType.RESEARCH;

  /**
   * The cached value of the '{@link #getType() <em>Type</em>}' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getType()
   * @generated
   * @ordered
   */
  protected PaperType type = TYPE_EDEFAULT;

  /**
   * The default value of the '{@link #getDecision() <em>Decision</em>}' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getDecision()
   * @generated
   * @ordered
   */
  protected static final Grade DECISION_EDEFAULT = Grade.UNDECIDED;

  /**
   * The cached value of the '{@link #getDecision() <em>Decision</em>}' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getDecision()
   * @generated
   * @ordered
   */
  protected Grade decision = DECISION_EDEFAULT;

  /**
   * The cached value of the '{@link #getReviews() <em>Reviews</em>}' reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getReviews()
   * @generated
   * @ordered
   */
  protected EList<ReviewAssignment> reviews;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected Paper()
  {
    super();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  protected EClass eStaticClass()
  {
    return ConferencePackage.Literals.PAPER;
  }

  /**
   * Returns the value of the '<em><b>Title</b></em>' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Title</em>' attribute.
   * @see #setTitle(String)
   * @see edu.conference.ConferencePackage#getPaper_Title()
   * @model
   * @generated
   */
  public String getTitle()
  {
    return title;
  }

  /**
   * Sets the value of the '{@link edu.conference.Paper#getTitle <em>Title</em>}' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @param newTitle the new value of the '<em>Title</em>' attribute.
   * @see #getTitle()
   * @generated
   */
  public void setTitle(String newTitle)
  {
    String oldTitle = title;
    title = newTitle;
    if (eNotificationRequired())
      eNotify(new ENotificationImpl(this, Notification.SET, ConferencePackage.PAPER__TITLE, oldTitle, title));
  }

  /**
   * Returns the value of the '<em><b>Type</b></em>' attribute.
   * The literals are from the enumeration {@link edu.conference.PaperType}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Type</em>' attribute.
   * @see edu.conference.PaperType
   * @see #setType(PaperType)
   * @see edu.conference.ConferencePackage#getPaper_Type()
   * @model
   * @generated
   */
  public PaperType getType()
  {
    return type;
  }

  /**
   * Sets the value of the '{@link edu.conference.Paper#getType <em>Type</em>}' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @param newType the new value of the '<em>Type</em>' attribute.
   * @see edu.conference.PaperType
   * @see #getType()
   * @generated
   */
  public void setType(PaperType newType)
  {
    PaperType oldType = type;
    type = newType == null ? TYPE_EDEFAULT : newType;
    if (eNotificationRequired())
      eNotify(new ENotificationImpl(this, Notification.SET, ConferencePackage.PAPER__TYPE, oldType, type));
  }

  /**
   * Returns the value of the '<em><b>Decision</b></em>' attribute.
   * The literals are from the enumeration {@link edu.conference.Grade}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Decision</em>' attribute.
   * @see edu.conference.Grade
   * @see #setDecision(Grade)
   * @see edu.conference.ConferencePackage#getPaper_Decision()
   * @model
   * @generated
   */
  public Grade getDecision()
  {
    return decision;
  }

  /**
   * Sets the value of the '{@link edu.conference.Paper#getDecision <em>Decision</em>}' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @param newDecision the new value of the '<em>Decision</em>' attribute.
   * @see edu.conference.Grade
   * @see #getDecision()
   * @generated
   */
  public void setDecision(Grade newDecision)
  {
    Grade oldDecision = decision;
    decision = newDecision == null ? DECISION_EDEFAULT : newDecision;
    if (eNotificationRequired())
      eNotify(new ENotificationImpl(this, Notification.SET, ConferencePackage.PAPER__DECISION, oldDecision, decision));
  }

  /**
   * Returns the value of the '<em><b>Reviews</b></em>' reference list.
   * The list contents are of type {@link edu.conference.ReviewAssignment}.
   * It is bidirectional and its opposite is '{@link edu.conference.ReviewAssignment#getPaper <em>Paper</em>}'.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Reviews</em>' reference list.
   * @see edu.conference.ConferencePackage#getPaper_Reviews()
   * @see edu.conference.ReviewAssignment#getPaper
   * @model opposite="paper" lower="3"
   * @generated
   */
  public EList<ReviewAssignment> getReviews()
  {
    if (reviews == null)
    {
      reviews = new EObjectWithInverseResolvingEList<ReviewAssignment>(ReviewAssignment.class, this, ConferencePackage.PAPER__REVIEWS, ConferencePackage.REVIEW_ASSIGNMENT__PAPER);
    }
    return reviews;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Checks if all submitted reviews for this paper are exclusively Accept or exclusively Reject before the final decision is made.
   * Algorithm:
   *   1. If the paper's reviews list is empty, return false (cannot make a check).
   *   2. Let firstGrade be the grade of the first review in the list that has a grade (not null and not UNDECIDED? Inferred: Reviews with null/UNDECIDED grade are considered not submitted and are ignored for this check. Requirement says "all reviews", implying submitted ones).
   *   3. If no review has a non-UNDECIDED grade, return false (no consensus can be determined).
   *   4. For each review in the paper's reviews list:
   *        a. If the review's grade is UNDECIDED or null, skip it (inferred: only consider submitted reviews).
   *        b. If the review's grade is different from firstGrade, return false.
   *   5. Return true.
   * Input: None.
   * Output:
   *   - boolean: true if all submitted reviews for the paper have the same grade (either all ACCEPT or all REJECT), false otherwise.
   * Pre-condition:
   *   - The Paper object must be properly initialized.
   *   - This method is intended to be called before the chair makes the final decision (paper.decision is UNDECIDED), but this is not a strict pre-condition for the method itself.
   * Post-condition: None.
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean isAllReviewsPositive()
  {
    EList<ReviewAssignment> reviewList = getReviews();
    if (reviewList == null || reviewList.isEmpty()) {
      return false;
    }
    
    Grade firstGrade = null;
    // Find the first review with a non-UNDECIDED grade
    for (ReviewAssignment review : reviewList) {
      if (review != null && review.getGrade() != null && review.getGrade() != Grade.UNDECIDED) {
        firstGrade = review.getGrade();
        break;
      }
    }
    
    // If no review has a non-UNDECIDED grade, return false
    if (firstGrade == null) {
      return false;
    }
    
    // Check all reviews have the same grade as firstGrade
    for (ReviewAssignment review : reviewList) {
      if (review != null && review.getGrade() != null && review.getGrade() != Grade.UNDECIDED) {
        if (review.getGrade() != firstGrade) {
          return false;
        }
      }
    }
    
    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: (NOTE: This operation seems misplaced. Calculating an acceptance rate is a property of an Author or the whole conference, not a single Paper. The requirement specifies "acceptance rate of papers for an author". Based on high cohesion principle, this operation should be in the Author class, as it is. The diagram might be incorrect. We will document it as per the diagram, but its functionality is unclear for a single paper.)
   * Algorithm: (Inferred) For a single paper, this might calculate the proportion of ACCEPT grades among its reviews. However, this contradicts the requirement. Since the diagram shows it in Paper, we infer this alternative meaning.
   *   - totalReviews = count of reviews for this paper that have a grade (not UNDECIDED).
   *   - If totalReviews is 0, return 0.0.
   *   - acceptedReviews = count of reviews where grade == Grade.ACCEPT.
   *   - Return acceptedReviews / totalReviews.
   * Input: None.
   * Output:
   *   - double: The proportion of ACCEPT reviews for this paper, between 0.0 and 1.0.
   * Pre-condition: The Paper object must be properly initialized.
   * Post-condition: None.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateAcceptanceRate()
  {
    EList<ReviewAssignment> reviewList = getReviews();
    if (reviewList == null || reviewList.isEmpty()) {
      return 0.0;
    }
    
    int totalReviews = 0;
    int acceptedReviews = 0;
    
    for (ReviewAssignment review : reviewList) {
      if (review != null && review.getGrade() != null && review.getGrade() != Grade.UNDECIDED) {
        totalReviews++;
        if (review.getGrade() == Grade.ACCEPT) {
          acceptedReviews++;
        }
      }
    }
    
    if (totalReviews == 0) {
      return 0.0;
    }
    
    return (double) acceptedReviews / totalReviews;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  {
    switch (featureID)
    {
      case ConferencePackage.PAPER__REVIEWS:
        return ((InternalEList<InternalEObject>)(InternalEList<?>)getReviews()).basicAdd(otherEnd, msgs);
    }
    return super.eInverseAdd(otherEnd, featureID, msgs);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  {
    switch (featureID)
    {
      case ConferencePackage.PAPER__REVIEWS:
        return ((InternalEList<?>)getReviews()).basicRemove(otherEnd, msgs);
    }
    return super.eInverseRemove(otherEnd, featureID, msgs);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  {
    switch (featureID)
    {
      case ConferencePackage.PAPER__TITLE:
        return getTitle();
      case ConferencePackage.PAPER__TYPE:
        return getType();
      case ConferencePackage.PAPER__DECISION:
        return getDecision();
      case ConferencePackage.PAPER__REVIEWS:
        return getReviews();
    }
    return super.eGet(featureID, resolve, coreType);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  {
    switch (featureID)
    {
      case ConferencePackage.PAPER__TITLE:
        setTitle((String)newValue);
        return;
      case ConferencePackage.PAPER__TYPE:
        setType((PaperType)newValue);
        return;
      case ConferencePackage.PAPER__DECISION:
        setDecision((Grade)newValue);
        return;
      case ConferencePackage.PAPER__REVIEWS:
        getReviews().clear();
        getReviews().addAll((Collection<? extends ReviewAssignment>)newValue);
        return;
    }
    super.eSet(featureID, newValue);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public void eUnset(int featureID)
  {
    switch (featureID)
    {
      case ConferencePackage.PAPER__TITLE:
        setTitle(TITLE_EDEFAULT);
        return;
      case ConferencePackage.PAPER__TYPE:
        setType(TYPE_EDEFAULT);
        return;
      case ConferencePackage.PAPER__DECISION:
        setDecision(DECISION_EDEFAULT);
        return;
      case ConferencePackage.PAPER__REVIEWS:
        getReviews().clear();
        return;
    }
    super.eUnset(featureID);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public boolean eIsSet(int featureID)
  {
    switch (featureID)
    {
      case ConferencePackage.PAPER__TITLE:
        return TITLE_EDEFAULT == null ? title != null : !TITLE_EDEFAULT.equals(title);
      case ConferencePackage.PAPER__TYPE:
        return type != TYPE_EDEFAULT;
      case ConferencePackage.PAPER__DECISION:
        return decision != DECISION_EDEFAULT;
      case ConferencePackage.PAPER__REVIEWS:
        return reviews != null && !reviews.isEmpty();
    }
    return super.eIsSet(featureID);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public String toString()
  {
    if (eIsProxy()) return super.toString();

    StringBuilder result = new StringBuilder(super.toString());
    result.append(" (title: ");
    result.append(title);
    result.append(", type: ");
    result.append(type);
    result.append(", decision: ");
    result.append(decision);
    result.append(')');
    return result.toString();
  }

} // Paper

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Represents a car in the gallery
 */
class Car {
    private String plate;
    private String model;
    private double dailyPrice;
    private boolean rented;

    public Car() {
        this.rented = false;
    }

    public String getPlate() {
        return plate;
    }

    public void setPlate(String plate) {
        this.plate = plate;
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public double getDailyPrice() {
        return dailyPrice;
    }

    public void setDailyPrice(double dailyPrice) {
        this.dailyPrice = dailyPrice;
    }

    public boolean isRented() {
        return rented;
    }

    public void setRented(boolean rented) {
        this.rented = rented;
    }
}

/**
 * Represents a customer
 */
class Customer {
    private String name;
    private String surname;
    private String address;

    public Customer() {
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Customer customer = (Customer) o;
        return Objects.equals(name, customer.name) && Objects.equals(surname, customer.surname);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, surname);
    }
}

/**
 * Represents a rental record
 */
class Rental {
    private Customer customer;
    private Car car;
    private LocalDate leaseDate;
    private LocalDate dueDate;
    private LocalDate backDate;

    public Rental() {
    }

    public Customer getCustomer() {
        return customer;
    }

    public void setCustomer(Customer customer) {
        this.customer = customer;
    }

    public Car getCar() {
        return car;
    }

    public void setCar(Car car) {
        this.car = car;
    }

    public LocalDate getLeaseDate() {
        return leaseDate;
    }

    public void setLeaseDate(LocalDate leaseDate) {
        this.leaseDate = leaseDate;
    }

    public LocalDate getDueDate() {
        return dueDate;
    }

    public void setDueDate(LocalDate dueDate) {
        this.dueDate = dueDate;
    }

    public LocalDate getBackDate() {
        return backDate;
    }

    public void setBackDate(LocalDate backDate) {
        this.backDate = backDate;
    }

    /**
     * Checks if the rental is overdue
     * @param currentDate the current date for comparison
     * @return true if the rental is overdue, false otherwise
     */
    public boolean isOverdue(LocalDate currentDate) {
        return backDate == null && currentDate.isAfter(dueDate);
    }
}

/**
 * Represents the car rental store system
 */
class CarRentalStore {
    private List<Car> cars;
    private List<Customer> customers;
    private List<Rental> rentals;

    public CarRentalStore() {
        this.cars = new ArrayList<>();
        this.customers = new ArrayList<>();
        this.rentals = new ArrayList<>();
    }

    public List<Car> getCars() {
        return cars;
    }

    public void setCars(List<Car> cars) {
        this.cars = cars;
    }

    public List<Customer> getCustomers() {
        return customers;
    }

    public void setCustomers(List<Customer> customers) {
        this.customers = customers;
    }

    public List<Rental> getRentals() {
        return rentals;
    }

    public void setRentals(List<Rental> rentals) {
        this.rentals = rentals;
    }

    /**
     * Identifies available cars in the store. A car is available if it is not currently rented.
     * Returns a list of available cars, sorted by daily price in ascending order.
     * If no available cars exist, returns an empty list.
     *
     * @return a list of available cars sorted by daily price
     */
    public List<Car> getAvailableCars() {
        return cars.stream()
                .filter(car -> !car.isRented())
                .sorted(Comparator.comparingDouble(Car::getDailyPrice))
                .collect(Collectors.toList());
    }

    /**
     * Calculates the total revenue generated by all rentals in the store.
     * Revenue is calculated as the daily price of each car multiplied by the number of days it was rented.
     *
     * @return the total revenue generated by all rentals
     */
    public double calculateTotalRevenue() {
        double totalRevenue = 0.0;
        for (Rental rental : rentals) {
            if (rental.getBackDate() != null && rental.getLeaseDate() != null) {
                long daysRented = java.time.temporal.ChronoUnit.DAYS.between(
                        rental.getLeaseDate(), rental.getBackDate());
                totalRevenue += rental.getCar().getDailyPrice() * daysRented;
            }
        }
        return totalRevenue;
    }

    /**
     * Lists customers with overdue rentals. For each rental, if the back date is null and
     * the current date is past the due date, mark it as overdue.
     *
     * @return a list of customers with overdue rentals
     */
    public List<Customer> getOverdueCustomers() {
        LocalDate currentDate = LocalDate.now();
        Set<Customer> overdueCustomers = new HashSet<>();
        
        for (Rental rental : rentals) {
            if (rental.isOverdue(currentDate)) {
                overdueCustomers.add(rental.getCustomer());
            }
        }
        
        return new ArrayList<>(overdueCustomers);
    }

    /**
     * Determines the average daily price of cars in the store.
     * If the store has no cars, returns 0.0.
     *
     * @return the average daily price of all cars
     */
    public double getAverageDailyPrice() {
        if (cars.isEmpty()) {
            return 0.0;
        }
        
        double total = cars.stream()
                .mapToDouble(Car::getDailyPrice)
                .sum();
        
        return total / cars.size();
    }

    /**
     * Counts the number of cars rented per customer.
     * Returns a map of customers and their respective rental counts.
     *
     * @return a map with customers as keys and rental counts as values
     */
    public Map<Customer, Integer> getRentedCarsPerCustomer() {
        Map<Customer, Integer> rentalCountMap = new HashMap<>();
        
        for (Rental rental : rentals) {
            Customer customer = rental.getCustomer();
            rentalCountMap.put(customer, rentalCountMap.getOrDefault(customer, 0) + 1);
        }
        
        return rentalCountMap;
    }

    /**
     * Rents a car to a customer
     * @param customer the customer renting the car
     * @param car the car being rented
     * @param leaseDate the date the car is rented
     * @param dueDate the date the car is due to be returned
     */
    public void rentCar(Customer customer, Car car, LocalDate leaseDate, LocalDate dueDate) {
        if (!car.isRented()) {
            car.setRented(true);
            Rental rental = new Rental();
            rental.setCustomer(customer);
            rental.setCar(car);
            rental.setLeaseDate(leaseDate);
            rental.setDueDate(dueDate);
            rentals.add(rental);
        }
    }

    /**
     * Returns a rented car
     * @param car the car being returned
     * @param returnDate the date the car is returned
     */
    public void returnCar(Car car, LocalDate returnDate) {
        car.setRented(false);
        for (Rental rental : rentals) {
            if (rental.getCar().equals(car) && rental.getBackDate() == null) {
                rental.setBackDate(returnDate);
                break;
            }
        }
    }
}
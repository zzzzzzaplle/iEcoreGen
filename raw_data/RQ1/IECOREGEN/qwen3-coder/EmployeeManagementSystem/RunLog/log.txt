  + Public methods: public double calculateTotalEmployeeSalary(), public double calculateTotalSalesPeopleCommission(), public double calculateTotalShiftWorkerHolidayPremiums()
  + Getter methods: public EList<Department> getDepartments(), public EList<Employee> getEmployees()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.impl.ENotificationImpl;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Shift Worker</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.ShiftWorker#getHolidayPremium <em>Holiday Premium</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getShiftWorker()
 * @model kind="class"
 * @generated
 */
public class ShiftWorker extends Worker
{
  protected static final double HOLIDAY_PREMIUM_EDEFAULT = 0.0;

  protected double holidayPremium = HOLIDAY_PREMIUM_EDEFAULT;

  protected ShiftWorker()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public double getHolidayPremium()
  { ... /* omitted */ }

  public void setHolidayPremium(double newHolidayPremium)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Computes the holiday premium for a shift worker.
   * Algorithm:
   *   RETURN holidayPremium (inferred as hourly rate * multiplier for overtime, but the exact formula depends on business rules)
   * Input: None
   * Output: A double representing the holiday premium for this shift worker.
   * Pre-condition: holidayPremium should be set or derivable from existing fields.
   * Post-condition: The holiday premium is computed and returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateHolidayPremium()
  {
    // According to the algorithm specification, we simply return the holidayPremium value
    return holidayPremium;
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // ShiftWorker
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Department</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.Department#getType <em>Type</em>}</li>
 *   <li>{@link edu.employee.Department#getManager <em>Manager</em>}</li>
 *   <li>{@link edu.employee.Department#getEmployees <em>Employees</em>}</li>
 *   <li>{@link edu.employee.Department#getCompany <em>Company</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getDepartment()
 * @model kind="class"
 * @generated
 */
public class Department extends MinimalEObjectImpl.Container implements EObject
{
  protected static final DepartmentType TYPE_EDEFAULT = DepartmentType.PRODUCTION;

  protected DepartmentType type = TYPE_EDEFAULT;

  protected Manager manager;

  protected EList<Employee> employees;

  protected Department()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public DepartmentType getType()
  { ... /* omitted */ }

  public void setType(DepartmentType newType)
  { ... /* omitted */ }

  public Manager getManager()
  { ... /* omitted */ }

  public Manager basicGetManager()
  { ... /* omitted */ }

  public void setManager(Manager newManager)
  { ... /* omitted */ }

  public EList<Employee> getEmployees()
  { ... /* omitted */ }

  public Company getCompany()
  { ... /* omitted */ }

  public NotificationChain basicSetCompany(Company newCompany, NotificationChain msgs)
  { ... /* omitted */ }

  public void setCompany(Company newCompany)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the average weekly working hours for all workers in the delivery department.
   * Algorithm:
   *   totalHours = 0
   *   workerCount = 0
   *   FOR each employee in department.employees:
   *     IF employee is instance of Worker AND department.type == DELIVERY:
   *       totalHours += employee.weeklyWorkingHour
   *       workerCount++
   *   IF workerCount == 0:
   *     RETURN 0
   *   RETURN totalHours / workerCount
   * Input: None
   * Output: A double representing the average weekly working hours of workers in the delivery department. Returns 0 if no workers exist in the delivery department.
   * Pre-condition: The employees list in the department must be initialized and populated.
   * Post-condition: The average working hours are computed and returned without modifying any state.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateAverageWorkerWorkingHours()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Department
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Manager` contains the following methods.
  + Instance creation: Use `EmployeeFactory.eINSTANCE.createManager()`
  + Public methods: public int getDirectSubordinateEmployeesCount()
  + Getter methods: , , , , , public double getSalary(), public String getPosition(), public EList<Employee> getSubordinates()
  + Setter methods: , , , , , public void setSalary(double newSalary), public void setPosition(String newPosition)
- Class `Employee` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: public String getDepartment(), public Date getBirthDate(), public String getName(), public String getSocialInsuranceNumber(), public Company getCompany()
  + Setter methods: public void setDepartment(String newDepartment), public void setBirthDate(Date newBirthDate), public void setName(String newName), public void setSocialInsuranceNumber(String newSocialInsuranceNumber), public void setCompany(Company newCompany)
- Class `Company` contains the following methods.
  + Instance creation: Use `EmployeeFactory.eINSTANCE.createCompany()`
  + Public methods: public double calculateTotalEmployeeSalary(), public double calculateTotalSalesPeopleCommission(), public double calculateTotalShiftWorkerHolidayPremiums()
  + Getter methods: public EList<Department> getDepartments(), public EList<Employee> getEmployees()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Department</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.Department#getType <em>Type</em>}</li>
 *   <li>{@link edu.employee.Department#getManager <em>Manager</em>}</li>
 *   <li>{@link edu.employee.Department#getEmployees <em>Employees</em>}</li>
 *   <li>{@link edu.employee.Department#getCompany <em>Company</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getDepartment()
 * @model kind="class"
 * @generated
 */
public class Department extends MinimalEObjectImpl.Container implements EObject
{
  protected static final DepartmentType TYPE_EDEFAULT = DepartmentType.PRODUCTION;

  protected DepartmentType type = TYPE_EDEFAULT;

  protected Manager manager;

  protected EList<Employee> employees;

  protected Department()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public DepartmentType getType()
  { ... /* omitted */ }

  public void setType(DepartmentType newType)
  { ... /* omitted */ }

  public Manager getManager()
  { ... /* omitted */ }

  public Manager basicGetManager()
  { ... /* omitted */ }

  public void setManager(Manager newManager)
  { ... /* omitted */ }

  public EList<Employee> getEmployees()
  { ... /* omitted */ }

  public Company getCompany()
  { ... /* omitted */ }

  public NotificationChain basicSetCompany(Company newCompany, NotificationChain msgs)
  { ... /* omitted */ }

  public void setCompany(Company newCompany)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the average weekly working hours for all workers in the delivery department.
   * Algorithm:
   *   totalHours = 0
   *   workerCount = 0
   *   FOR each employee in department.employees:
   *     IF employee is instance of Worker AND department.type == DELIVERY:
   *       totalHours += employee.weeklyWorkingHour
   *       workerCount++
   *   IF workerCount == 0:
   *     RETURN 0
   *   RETURN totalHours / workerCount
   * Input: None
   * Output: A double representing the average weekly working hours of workers in the delivery department. Returns 0 if no workers exist in the delivery department.
   * Pre-condition: The employees list in the department must be initialized and populated.
   * Post-condition: The average working hours are computed and returned without modifying any state.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateAverageWorkerWorkingHours()
  {
    double totalHours = 0;
    int workerCount = 0;
    
    if (getType() == DepartmentType.DELIVERY) {
      for (Employee employee : getEmployees()) {
        if (employee instanceof Worker) {
          totalHours += ((Worker) employee).getWeeklyWorkingHour();
          workerCount++;
        }
      }
    }
    
    if (workerCount == 0) {
      return 0;
    }
    
    return totalHours / workerCount;
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Department
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Company</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.Company#getDepartments <em>Departments</em>}</li>
 *   <li>{@link edu.employee.Company#getEmployees <em>Employees</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getCompany()
 * @model kind="class"
 * @generated
 */
public class Company extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Department> departments;

  protected EList<Employee> employees;

  protected Company()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Department> getDepartments()
  { ... /* omitted */ }

  public EList<Employee> getEmployees()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total salary of all employees in the company by summing up salaries of workers, salespeople, and managers.
   * Algorithm:
   *   totalSalary = 0
   *   FOR each employee in company.employees:
   *     IF employee is instance of Worker:
   *       totalSalary += employee.weeklyWorkingHour * employee.hourlyRates
   *       IF employee is instance of ShiftWorker:
   *         totalSalary += employee.calculateHolidayPremium()
   *     ELSE IF employee is instance of SalesPeople:
   *       totalSalary += employee.salary + (employee.amountOfSales * employee.commissionPercentage)
   *     ELSE IF employee is instance of Manager:
   *       totalSalary += employee.salary
   *   RETURN totalSalary
   * Input: None
   * Output: A double representing the total salary of all employees in the company.
   * Pre-condition: The employees list in the company must be initialized and populated.
   * Post-condition: The total salary of all employees is computed and returned without modifying any state.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateTotalEmployeeSalary()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Computes the total commission amount for all salespeople in the company.
   * Algorithm:
   *   totalCommission = 0
   *   FOR each employee in company.employees:
   *     IF employee is instance of SalesPeople:
   *       totalCommission += employee.getTotalCommission()
   *   RETURN totalCommission
   * Input: None
   * Output: A double representing the total commission for all salespeople.
   * Pre-condition: The employees list in the company must be initialized and populated.
   * Post-condition: The total commission is computed and returned without modifying any state.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateTotalSalesPeopleCommission()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total holiday premiums paid to all shift workers in the company.
   * Algorithm:
   *   totalPremiums = 0
   *   FOR each employee in company.employees:
   *     IF employee is instance of ShiftWorker:
   *       totalPremiums += employee.calculateHolidayPremium()
   *   RETURN totalPremiums
   * Input: None
   * Output: A double representing the total holiday premiums for all shift workers. Returns 0 if there are no shift workers.
   * Pre-condition: The employees list in the company must be initialized and populated.
   * Post-condition: The total holiday premiums are computed and returned without modifying any state.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateTotalShiftWorkerHolidayPremiums()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Company
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Department` contains the following methods.
  + Instance creation: Use `EmployeeFactory.eINSTANCE.createDepartment()`
  + Public methods: public double calculateAverageWorkerWorkingHours()
  + Getter methods: public DepartmentType getType(), public Manager getManager(), public EList<Employee> getEmployees(), public Company getCompany()
  + Setter methods: public void setType(DepartmentType newType), public void setManager(Manager newManager), public void setCompany(Company newCompany)
- Class `Employee` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: public String getDepartment(), public Date getBirthDate(), public String getName(), public String getSocialInsuranceNumber(), public Company getCompany()
  + Setter methods: public void setDepartment(String newDepartment), public void setBirthDate(Date newBirthDate), public void setName(String newName), public void setSocialInsuranceNumber(String newSocialInsuranceNumber), public void setCompany(Company newCompany)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Company</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.Company#getDepartments <em>Departments</em>}</li>
 *   <li>{@link edu.employee.Company#getEmployees <em>Employees</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getCompany()
 * @model kind="class"
 * @generated
 */
public class Company extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Department> departments;

  protected EList<Employee> employees;

  protected Company()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Department> getDepartments()
  { ... /* omitted */ }

  public EList<Employee> getEmployees()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total salary of all employees in the company by summing up salaries of workers, salespeople, and managers.
   * Algorithm:
   *   totalSalary = 0
   *   FOR each employee in company.employees:
   *     IF employee is instance of Worker:
   *       totalSalary += employee.weeklyWorkingHour * employee.hourlyRates
   *       IF employee is instance of ShiftWorker:
   *         totalSalary += employee.calculateHolidayPremium()
   *     ELSE IF employee is instance of SalesPeople:
   *       totalSalary += employee.salary + (employee.amountOfSales * employee.commissionPercentage)
   *     ELSE IF employee is instance of Manager:
   *       totalSalary += employee.salary
   *   RETURN totalSalary
   * Input: None
   * Output: A double representing the total salary of all employees in the company.
   * Pre-condition: The employees list in the company must be initialized and populated.
   * Post-condition: The total salary of all employees is computed and returned without modifying any state.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateTotalEmployeeSalary()
  {
    double totalSalary = 0;
    for (Employee employee : getEmployees()) {
      if (employee instanceof Worker) {
        Worker worker = (Worker) employee;
        totalSalary += worker.getWeeklyWorkingHour() * worker.getHourlyRates();
        if (employee instanceof ShiftWorker) {
          ShiftWorker shiftWorker = (ShiftWorker) employee;
          totalSalary += shiftWorker.calculateHolidayPremium();
        }
      } else if (employee instanceof SalesPeople) {
        SalesPeople salesPerson = (SalesPeople) employee;
        totalSalary += salesPerson.getSalary() + (salesPerson.getAmountOfSales() * salesPerson.getCommissionPercentage());
      } else if (employee instanceof Manager) {
        Manager manager = (Manager) employee;
        totalSalary += manager.getSalary();
      }
    }
    return totalSalary;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Computes the total commission amount for all salespeople in the company.
   * Algorithm:
   *   totalCommission = 0
   *   FOR each employee in company.employees:
   *     IF employee is instance of SalesPeople:
   *       totalCommission += employee.getTotalCommission()
   *   RETURN totalCommission
   * Input: None
   * Output: A double representing the total commission for all salespeople.
   * Pre-condition: The employees list in the company must be initialized and populated.
   * Post-condition: The total commission is computed and returned without modifying any state.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateTotalSalesPeopleCommission()
  {
    double totalCommission = 0;
    for (Employee employee : getEmployees()) {
      if (employee instanceof SalesPeople) {
        SalesPeople salesPerson = (SalesPeople) employee;
        totalCommission += salesPerson.getTotalCommission();
      }
    }
    return totalCommission;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total holiday premiums paid to all shift workers in the company.
   * Algorithm:
   *   totalPremiums = 0
   *   FOR each employee in company.employees:
   *     IF employee is instance of ShiftWorker:
   *       totalPremiums += employee.calculateHolidayPremium()
   *   RETURN totalPremiums
   * Input: None
   * Output: A double representing the total holiday premiums for all shift workers. Returns 0 if there are no shift workers.
   * Pre-condition: The employees list in the company must be initialized and populated.
   * Post-condition: The total holiday premiums are computed and returned without modifying any state.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateTotalShiftWorkerHolidayPremiums()
  {
    double totalPremiums = 0;
    for (Employee employee : getEmployees()) {
      if (employee instanceof ShiftWorker) {
        ShiftWorker shiftWorker = (ShiftWorker) employee;
        totalPremiums += shiftWorker.calculateHolidayPremium();
      }
    }
    return totalPremiums;
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Company
620745 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../EmployeeManagementSystem/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../EmployeeManagementSystem/src-gen/edu/employee/
620861 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
620861 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
620861 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
620862 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
620863 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample4.mwe2 启动完成
正在拷贝 src-gen/edu/employee 到 qwen3-coder/employee4...
拷贝完成！

======================================
正在启动 sample5.mwe2...
======================================
621022 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
621092 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project EmployeeManagementSystem at 'file:/D:/EclipseWorkspace/EmployeeManagementSystem/'
621095 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
621102 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@38dd3252
621102 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
621103 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
621104 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
Employee Management System
A company has more than one employee. Each employee object contains information about the department, name, date of birth, and social insurance number. These employees are included in the categories of workers, sales people, and managers. In addition, while workers have information such as weekly working hours and hourly rates, the sales persons have information such as fixed salary, amount of sales made, and commission percentage. The managers only get a fixed salary, and have subordinates. Workers are separated as shift workers and non-shift workers. Off-shift workers have weekend and official holiday permits. Shift workers receive premiums for working on holidays. The company has production, control, and delivery departments. Each department has to be controlled by a manager. Shift workers can only work in the delivery department.
In addition to the above basic information, the manager object also has position information. 
Functional requirement:
+ Calculate the total salary of all employees in the company. Total salary = sum(workers' salary + sales people's salary + managers' salary). Workers' salary = weeklyWorkingHour * hourlyRates + [holiday premiums for shift workers]. Sales people's salary = salary + amountOfSales * commissionPercentage. Managers' salary = salary.

+ Find average working hours per week for all workers in the delivery department.  Return 0 if there are no workers in the delivery department.

+ Determine the total commission amount for all salespeople in the company. Sum(amountOfSales * commissionPercentage) for all salespeople.

+ Calculate total holiday premiums paid to all shift workers in the company.  Return 0 if there are no shift workers in the delivery department.

+ Get the number of direct subordinate employees for each manager. 
```

# Class Diagram
```plantuml
@startuml

title employee Model

class Company {
    departments : List<Department>
    employees : List<Employee>
    calculateTotalEmployeeSalary() : double
    calculateTotalSalesPeopleCommission() : double
    calculateTotalShiftWorkerHolidayPremiums() : double
}
class Department {
    type : DepartmentType
    company : Company
    employees : List<Employee>
    manager : Manager
    calculateAverageWorkerWorkingHours() : double
}
abstract class Employee {
    birthDate : EDate
    department : String
    name : String
    socialInsuranceNumber : String
    company : Company
}
class Manager {
    position : String
    salary : double
    subordinates : List<Employee>
    getDirectSubordinateEmployeesCount() : int
}
class OffShiftWorker {
}
class SalesPeople {
    amountOfSales : double
    commissionPercentage : double
    salary : double
    getTotalCommission() : double
}
class ShiftWorker {
    holidayPremium : double
    calculateHolidayPremium() : double
}
abstract class Worker {
    hourlyRates : double
    weeklyWorkingHour : int
}
enum DepartmentType {
    PRODUCTION
    CONTROL
    DELIVERY
}

Company *-- "*" Department : departments  'opposite: company
Company *-- "*" Employee : employees  'opposite: company
Department --> Company : company  'opposite: departments
Department --> "*" Employee : employees
Department --> Manager : manager
Employee --> Company : company  'opposite: employees
Manager --|> Employee
Manager --> "*" Employee : subordinates
OffShiftWorker --|> Worker
SalesPeople --|> Employee
ShiftWorker --|> Worker
Worker --|> Employee
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

666804 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@22271065 (name: calculateAverageWorkerWorkingHours) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates the average weekly working hours for all workers in the delivery department.
Algorithm:
  1. Initialize totalHours = 0, workerCount = 0
  2. For each employee in employees:
     a. If employee is a Worker AND belongs to DELIVERY department:
         i. Add weeklyWorkingHour to totalHours
        ii. Increment workerCount
  3. If workerCount is 0:
     a. Return 0
  4. Else:
     a. Return totalHours / workerCount
Input: None
Output: A double representing the average weekly working hours. Returns 0 if there are no workers in the delivery department.
Pre-condition: The employees list is initialized and contains valid worker objects
Post-condition: The average working hours are calculated and returned without modifying any worker data, org.eclipse.emf.ecore.impl.EOperationImpl@a95c1f6 (name: calculateTotalShiftWorkerHolidayPremiums) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates the total holiday premiums paid to all shift workers in the company.
Algorithm:
  1. Initialize totalPremiums = 0
  2. For each employee in employees:
     a. If employee is a ShiftWorker:
         i. Add holidayPremium to totalPremiums
  3. Return totalPremiums
Input: None
Output: A double representing the total holiday premiums paid to all shift workers. Returns 0 if there are no shift workers.
Pre-condition: The employees list is initialized and contains valid employee objects
Post-condition: The total holiday premiums are calculated and returned without modifying any shift worker data, org.eclipse.emf.ecore.impl.EOperationImpl@11c7756f (name: getTotalCommission) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates the commission for this salesperson.
Algorithm:
  1. Return amountOfSales * commissionPercentage
Input: None
Output: A double representing the commission amount for this salesperson
Pre-condition: amountOfSales and commissionPercentage are properly initialized
Post-condition: The commission is calculated and returned without modifying any salesperson data, org.eclipse.emf.ecore.impl.EOperationImpl@35798cd0 (name: calculateHolidayPremium) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates the holiday premium for this shift worker.
Algorithm:
  1. Return holidayPremium
Input: None
Output: A double representing the holiday premium for this shift worker
Pre-condition: holidayPremium is properly initialized
Post-condition: The holiday premium is returned without modifying any data, org.eclipse.emf.ecore.impl.EOperationImpl@6f46764d (name: calculateTotalSalesPeopleCommission) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Determines the total commission amount for all salespeople in the company.
Algorithm:
  1. Initialize totalCommission = 0
  2. For each employee in employees:
     a. If employee is a SalesPeople:
         i. Add (amountOfSales * commissionPercentage) to totalCommission
  3. Return totalCommission
Input: None
Output: A double representing the total commission amount for all salespeople
Pre-condition: The employees list is initialized and contains valid salespeople objects
Post-condition: The total commission is calculated and returned without modifying any salesperson data, org.eclipse.emf.ecore.impl.EOperationImpl@374b1d85 (name: calculateTotalEmployeeSalary) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates the total salary of all employees in the company by summing up salaries of workers, salespeople, and managers.
Algorithm:
  1. Initialize totalSalary = 0
  2. For each employee in employees:
     a. If employee is a Worker:
         i. Calculate worker's salary = weeklyWorkingHour * hourlyRates
        ii. If employee is a ShiftWorker:
            - Add holidayPremium to the salary
     b. If employee is a SalesPeople:
         i. Calculate salesperson's salary = salary + amountOfSales * commissionPercentage
     c. If employee is a Manager:
         i. Add manager's salary to the total
  3. Return totalSalary
Input: None
Output: A double representing the total salary of all employees in the company
Pre-condition: The employees list is initialized and contains valid employee objects
Post-condition: The total salary is calculated and returned without modifying any employee data, org.eclipse.emf.ecore.impl.EOperationImpl@4d6f8691 (name: getDirectSubordinateEmployeesCount) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Gets the number of direct subordinate employees for this manager.
Algorithm:
  1. Return the size of the subordinates list
Input: None
Output: An integer representing the number of direct subordinate employees
Pre-condition: The subordinates list is initialized
Post-condition: The count of direct subordinates is returned without modifying any data}
666806 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
666832 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../EmployeeManagementSystem/src-gen/edu/employee
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.impl.ENotificationImpl;

import org.eclipse.emf.ecore.util.EObjectResolvingEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Manager</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.Manager#getSalary <em>Salary</em>}</li>
 *   <li>{@link edu.employee.Manager#getPosition <em>Position</em>}</li>
 *   <li>{@link edu.employee.Manager#getSubordinates <em>Subordinates</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getManager()
 * @model kind="class"
 * @generated
 */
public class Manager extends Employee
{
  protected static final double SALARY_EDEFAULT = 0.0;

  protected double salary = SALARY_EDEFAULT;

  protected static final String POSITION_EDEFAULT = null;

  protected String position = POSITION_EDEFAULT;

  protected EList<Employee> subordinates;

  protected Manager()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public double getSalary()
  { ... /* omitted */ }

  public void setSalary(double newSalary)
  { ... /* omitted */ }

  public String getPosition()
  { ... /* omitted */ }

  public void setPosition(String newPosition)
  { ... /* omitted */ }

  public EList<Employee> getSubordinates()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Gets the number of direct subordinate employees for this manager.
   * Algorithm:
   *   1. Return the size of the subordinates list
   * Input: None
   * Output: An integer representing the number of direct subordinate employees
   * Pre-condition: The subordinates list is initialized
   * Post-condition: The count of direct subordinates is returned without modifying any data
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int getDirectSubordinateEmployeesCount()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Manager
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Employee` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: public String getDepartment(), public Date getBirthDate(), public String getName(), public String getSocialInsuranceNumber(), public Company getCompany()
  + Setter methods: public void setDepartment(String newDepartment), public void setBirthDate(Date newBirthDate), public void setName(String newName), public void setSocialInsuranceNumber(String newSocialInsuranceNumber), public void setCompany(Company newCompany)
- Class `Company` contains the following methods.
  + Instance creation: Use `EmployeeFactory.eINSTANCE.createCompany()`
  + Public methods: public double calculateTotalEmployeeSalary(), public double calculateTotalSalesPeopleCommission(), public double calculateTotalShiftWorkerHolidayPremiums()
  + Getter methods: public EList<Department> getDepartments(), public EList<Employee> getEmployees()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.impl.ENotificationImpl;

import org.eclipse.emf.ecore.util.EObjectResolvingEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Manager</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.Manager#getSalary <em>Salary</em>}</li>
 *   <li>{@link edu.employee.Manager#getPosition <em>Position</em>}</li>
 *   <li>{@link edu.employee.Manager#getSubordinates <em>Subordinates</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getManager()
 * @model kind="class"
 * @generated
 */
public class Manager extends Employee
{
  protected static final double SALARY_EDEFAULT = 0.0;

  protected double salary = SALARY_EDEFAULT;

  protected static final String POSITION_EDEFAULT = null;

  protected String position = POSITION_EDEFAULT;

  protected EList<Employee> subordinates;

  protected Manager()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public double getSalary()
  { ... /* omitted */ }

  public void setSalary(double newSalary)
  { ... /* omitted */ }

  public String getPosition()
  { ... /* omitted */ }

  public void setPosition(String newPosition)
  { ... /* omitted */ }

  public EList<Employee> getSubordinates()
  {
    if (subordinates == null)
    {
      subordinates = new EObjectResolvingEList<Employee>(Employee.class, this, EmployeePackage.MANAGER__SUBORDINATES);
    }
    return subordinates;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Gets the number of direct subordinate employees for this manager.
   * Algorithm:
   *   1. Return the size of the subordinates list
   * Input: None
   * Output: An integer representing the number of direct subordinate employees
   * Pre-condition: The subordinates list is initialized
   * Post-condition: The count of direct subordinates is returned without modifying any data
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int getDirectSubordinateEmployeesCount()
  {
    return getSubordinates().size();
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Manager
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.impl.ENotificationImpl;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Sales People</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.SalesPeople#getSalary <em>Salary</em>}</li>
 *   <li>{@link edu.employee.SalesPeople#getAmountOfSales <em>Amount Of Sales</em>}</li>
 *   <li>{@link edu.employee.SalesPeople#getCommissionPercentage <em>Commission Percentage</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getSalesPeople()
 * @model kind="class"
 * @generated
 */
public class SalesPeople extends Employee
{
  protected static final double SALARY_EDEFAULT = 0.0;

  protected double salary = SALARY_EDEFAULT;

  protected static final double AMOUNT_OF_SALES_EDEFAULT = 0.0;

  protected double amountOfSales = AMOUNT_OF_SALES_EDEFAULT;

  protected static final double COMMISSION_PERCENTAGE_EDEFAULT = 0.0;

  protected double commissionPercentage = COMMISSION_PERCENTAGE_EDEFAULT;

  protected SalesPeople()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public double getSalary()
  { ... /* omitted */ }

  public void setSalary(double newSalary)
  { ... /* omitted */ }

  public double getAmountOfSales()
  { ... /* omitted */ }

  public void setAmountOfSales(double newAmountOfSales)
  { ... /* omitted */ }

  public double getCommissionPercentage()
  { ... /* omitted */ }

  public void setCommissionPercentage(double newCommissionPercentage)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the commission for this salesperson.
   * Algorithm:
   *   1. Return amountOfSales * commissionPercentage
   * Input: None
   * Output: A double representing the commission amount for this salesperson
   * Pre-condition: amountOfSales and commissionPercentage are properly initialized
   * Post-condition: The commission is calculated and returned without modifying any salesperson data
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double getTotalCommission()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // SalesPeople
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Employee` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: public String getDepartment(), public Date getBirthDate(), public String getName(), public String getSocialInsuranceNumber(), public Company getCompany()
  + Setter methods: public void setDepartment(String newDepartment), public void setBirthDate(Date newBirthDate), public void setName(String newName), public void setSocialInsuranceNumber(String newSocialInsuranceNumber), public void setCompany(Company newCompany)
- Class `Company` contains the following methods.
  + Instance creation: Use `EmployeeFactory.eINSTANCE.createCompany()`
  + Public methods: public double calculateTotalEmployeeSalary(), public double calculateTotalSalesPeopleCommission(), public double calculateTotalShiftWorkerHolidayPremiums()
  + Getter methods: public EList<Department> getDepartments(), public EList<Employee> getEmployees()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.impl.ENotificationImpl;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Sales People</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.SalesPeople#getSalary <em>Salary</em>}</li>
 *   <li>{@link edu.employee.SalesPeople#getAmountOfSales <em>Amount Of Sales</em>}</li>
 *   <li>{@link edu.employee.SalesPeople#getCommissionPercentage <em>Commission Percentage</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getSalesPeople()
 * @model kind="class"
 * @generated
 */
public class SalesPeople extends Employee
{
  protected static final double SALARY_EDEFAULT = 0.0;

  protected double salary = SALARY_EDEFAULT;

  protected static final double AMOUNT_OF_SALES_EDEFAULT = 0.0;

  protected double amountOfSales = AMOUNT_OF_SALES_EDEFAULT;

  protected static final double COMMISSION_PERCENTAGE_EDEFAULT = 0.0;

  protected double commissionPercentage = COMMISSION_PERCENTAGE_EDEFAULT;

  protected SalesPeople()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public double getSalary()
  { ... /* omitted */ }

  public void setSalary(double newSalary)
  { ... /* omitted */ }

  public double getAmountOfSales()
  { ... /* omitted */ }

  public void setAmountOfSales(double newAmountOfSales)
  { ... /* omitted */ }

  public double getCommissionPercentage()
  { ... /* omitted */ }

  public void setCommissionPercentage(double newCommissionPercentage)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the commission for this salesperson.
   * Algorithm:
   *   1. Return amountOfSales * commissionPercentage
   * Input: None
   * Output: A double representing the commission amount for this salesperson
   * Pre-condition: amountOfSales and commissionPercentage are properly initialized
   * Post-condition: The commission is calculated and returned without modifying any salesperson data
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double getTotalCommission()
  {
    return getAmountOfSales() * getCommissionPercentage();
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // SalesPeople
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.impl.ENotificationImpl;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Shift Worker</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.ShiftWorker#getHolidayPremium <em>Holiday Premium</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getShiftWorker()
 * @model kind="class"
 * @generated
 */
public class ShiftWorker extends Worker
{
  protected static final double HOLIDAY_PREMIUM_EDEFAULT = 0.0;

  protected double holidayPremium = HOLIDAY_PREMIUM_EDEFAULT;

  protected ShiftWorker()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public double getHolidayPremium()
  { ... /* omitted */ }

  public void setHolidayPremium(double newHolidayPremium)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the holiday premium for this shift worker.
   * Algorithm:
   *   1. Return holidayPremium
   * Input: None
   * Output: A double representing the holiday premium for this shift worker
   * Pre-condition: holidayPremium is properly initialized
   * Post-condition: The holiday premium is returned without modifying any data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateHolidayPremium()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // ShiftWorker
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Employee` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: public String getDepartment(), public Date getBirthDate(), public String getName(), public String getSocialInsuranceNumber(), public Company getCompany()
  + Setter methods: public void setDepartment(String newDepartment), public void setBirthDate(Date newBirthDate), public void setName(String newName), public void setSocialInsuranceNumber(String newSocialInsuranceNumber), public void setCompany(Company newCompany)
- Class `Worker` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: , , , , , public int getWeeklyWorkingHour(), public double getHourlyRates()
  + Setter methods: , , , , , public void setWeeklyWorkingHour(int newWeeklyWorkingHour), public void setHourlyRates(double newHourlyRates)
- Class `Company` contains the following methods.
  + Instance creation: Use `EmployeeFactory.eINSTANCE.createCompany()`
  + Public methods: public double calculateTotalEmployeeSalary(), public double calculateTotalSalesPeopleCommission(), public double calculateTotalShiftWorkerHolidayPremiums()
  + Getter methods: public EList<Department> getDepartments(), public EList<Employee> getEmployees()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.ecore.EClass;

import org.eclipse.emf.ecore.impl.ENotificationImpl;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Shift Worker</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.ShiftWorker#getHolidayPremium <em>Holiday Premium</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getShiftWorker()
 * @model kind="class"
 * @generated
 */
public class ShiftWorker extends Worker
{
  protected static final double HOLIDAY_PREMIUM_EDEFAULT = 0.0;

  protected double holidayPremium = HOLIDAY_PREMIUM_EDEFAULT;

  protected ShiftWorker()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public double getHolidayPremium()
  { ... /* omitted */ }

  public void setHolidayPremium(double newHolidayPremium)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the holiday premium for this shift worker.
   * Algorithm:
   *   1. Return holidayPremium
   * Input: None
   * Output: A double representing the holiday premium for this shift worker
   * Pre-condition: holidayPremium is properly initialized
   * Post-condition: The holiday premium is returned without modifying any data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateHolidayPremium()
  {
    return holidayPremium;
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // ShiftWorker
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Department</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.Department#getType <em>Type</em>}</li>
 *   <li>{@link edu.employee.Department#getManager <em>Manager</em>}</li>
 *   <li>{@link edu.employee.Department#getEmployees <em>Employees</em>}</li>
 *   <li>{@link edu.employee.Department#getCompany <em>Company</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getDepartment()
 * @model kind="class"
 * @generated
 */
public class Department extends MinimalEObjectImpl.Container implements EObject
{
  protected static final DepartmentType TYPE_EDEFAULT = DepartmentType.PRODUCTION;

  protected DepartmentType type = TYPE_EDEFAULT;

  protected Manager manager;

  protected EList<Employee> employees;

  protected Department()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public DepartmentType getType()
  { ... /* omitted */ }

  public void setType(DepartmentType newType)
  { ... /* omitted */ }

  public Manager getManager()
  { ... /* omitted */ }

  public Manager basicGetManager()
  { ... /* omitted */ }

  public void setManager(Manager newManager)
  { ... /* omitted */ }

  public EList<Employee> getEmployees()
  { ... /* omitted */ }

  public Company getCompany()
  { ... /* omitted */ }

  public NotificationChain basicSetCompany(Company newCompany, NotificationChain msgs)
  { ... /* omitted */ }

  public void setCompany(Company newCompany)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the average weekly working hours for all workers in the delivery department.
   * Algorithm:
   *   1. Initialize totalHours = 0, workerCount = 0
   *   2. For each employee in employees:
   *      a. If employee is a Worker AND belongs to DELIVERY department:
   *          i. Add weeklyWorkingHour to totalHours
   *         ii. Increment workerCount
   *   3. If workerCount is 0:
   *      a. Return 0
   *   4. Else:
   *      a. Return totalHours / workerCount
   * Input: None
   * Output: A double representing the average weekly working hours. Returns 0 if there are no workers in the delivery department.
   * Pre-condition: The employees list is initialized and contains valid worker objects
   * Post-condition: The average working hours are calculated and returned without modifying any worker data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateAverageWorkerWorkingHours()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Department
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Manager` contains the following methods.
  + Instance creation: Use `EmployeeFactory.eINSTANCE.createManager()`
  + Public methods: public int getDirectSubordinateEmployeesCount()
  + Getter methods: , , , , , public double getSalary(), public String getPosition(), public EList<Employee> getSubordinates()
  + Setter methods: , , , , , public void setSalary(double newSalary), public void setPosition(String newPosition)
- Class `Employee` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: public String getDepartment(), public Date getBirthDate(), public String getName(), public String getSocialInsuranceNumber(), public Company getCompany()
  + Setter methods: public void setDepartment(String newDepartment), public void setBirthDate(Date newBirthDate), public void setName(String newName), public void setSocialInsuranceNumber(String newSocialInsuranceNumber), public void setCompany(Company newCompany)
- Class `Company` contains the following methods.
  + Instance creation: Use `EmployeeFactory.eINSTANCE.createCompany()`
  + Public methods: public double calculateTotalEmployeeSalary(), public double calculateTotalSalesPeopleCommission(), public double calculateTotalShiftWorkerHolidayPremiums()
  + Getter methods: public EList<Department> getDepartments(), public EList<Employee> getEmployees()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Department</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.Department#getType <em>Type</em>}</li>
 *   <li>{@link edu.employee.Department#getManager <em>Manager</em>}</li>
 *   <li>{@link edu.employee.Department#getEmployees <em>Employees</em>}</li>
 *   <li>{@link edu.employee.Department#getCompany <em>Company</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getDepartment()
 * @model kind="class"
 * @generated
 */
public class Department extends MinimalEObjectImpl.Container implements EObject
{
  protected static final DepartmentType TYPE_EDEFAULT = DepartmentType.PRODUCTION;

  protected DepartmentType type = TYPE_EDEFAULT;

  protected Manager manager;

  protected EList<Employee> employees;

  protected Department()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public DepartmentType getType()
  { ... /* omitted */ }

  public void setType(DepartmentType newType)
  { ... /* omitted */ }

  public Manager getManager()
  { ... /* omitted */ }

  public Manager basicGetManager()
  { ... /* omitted */ }

  public void setManager(Manager newManager)
  { ... /* omitted */ }

  public EList<Employee> getEmployees()
  { ... /* omitted */ }

  public Company getCompany()
  { ... /* omitted */ }

  public NotificationChain basicSetCompany(Company newCompany, NotificationChain msgs)
  { ... /* omitted */ }

  public void setCompany(Company newCompany)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the average weekly working hours for all workers in the delivery department.
   * Algorithm:
   *   1. Initialize totalHours = 0, workerCount = 0
   *   2. For each employee in employees:
   *      a. If employee is a Worker AND belongs to DELIVERY department:
   *          i. Add weeklyWorkingHour to totalHours
   *         ii. Increment workerCount
   *   3. If workerCount is 0:
   *      a. Return 0
   *   4. Else:
   *      a. Return totalHours / workerCount
   * Input: None
   * Output: A double representing the average weekly working hours. Returns 0 if there are no workers in the delivery department.
   * Pre-condition: The employees list is initialized and contains valid worker objects
   * Post-condition: The average working hours are calculated and returned without modifying any worker data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateAverageWorkerWorkingHours()
  {
    double totalHours = 0;
    int workerCount = 0;
    
    // For each employee in employees
    for (Employee employee : getEmployees()) {
      // Check if employee is a Worker (assuming Worker extends Employee)
      if (employee instanceof Worker) {
        Worker worker = (Worker) employee;
        // Check if this department is of type DELIVERY
        if (getType() == DepartmentType.DELIVERY) {
          // Add weeklyWorkingHour to totalHours
          totalHours += worker.getWeeklyWorkingHour();
          // Increment workerCount
          workerCount++;
        }
      }
    }
    
    // If workerCount is 0, return 0
    if (workerCount == 0) {
      return 0;
    }
    
    // Else return totalHours / workerCount
    return totalHours / workerCount;
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Department
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Company</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.Company#getDepartments <em>Departments</em>}</li>
 *   <li>{@link edu.employee.Company#getEmployees <em>Employees</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getCompany()
 * @model kind="class"
 * @generated
 */
public class Company extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Department> departments;

  protected EList<Employee> employees;

  protected Company()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Department> getDepartments()
  { ... /* omitted */ }

  public EList<Employee> getEmployees()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total salary of all employees in the company by summing up salaries of workers, salespeople, and managers.
   * Algorithm:
   *   1. Initialize totalSalary = 0
   *   2. For each employee in employees:
   *      a. If employee is a Worker:
   *          i. Calculate worker's salary = weeklyWorkingHour * hourlyRates
   *         ii. If employee is a ShiftWorker:
   *             - Add holidayPremium to the salary
   *      b. If employee is a SalesPeople:
   *          i. Calculate salesperson's salary = salary + amountOfSales * commissionPercentage
   *      c. If employee is a Manager:
   *          i. Add manager's salary to the total
   *   3. Return totalSalary
   * Input: None
   * Output: A double representing the total salary of all employees in the company
   * Pre-condition: The employees list is initialized and contains valid employee objects
   * Post-condition: The total salary is calculated and returned without modifying any employee data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateTotalEmployeeSalary()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Determines the total commission amount for all salespeople in the company.
   * Algorithm:
   *   1. Initialize totalCommission = 0
   *   2. For each employee in employees:
   *      a. If employee is a SalesPeople:
   *          i. Add (amountOfSales * commissionPercentage) to totalCommission
   *   3. Return totalCommission
   * Input: None
   * Output: A double representing the total commission amount for all salespeople
   * Pre-condition: The employees list is initialized and contains valid salespeople objects
   * Post-condition: The total commission is calculated and returned without modifying any salesperson data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateTotalSalesPeopleCommission()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total holiday premiums paid to all shift workers in the company.
   * Algorithm:
   *   1. Initialize totalPremiums = 0
   *   2. For each employee in employees:
   *      a. If employee is a ShiftWorker:
   *          i. Add holidayPremium to totalPremiums
   *   3. Return totalPremiums
   * Input: None
   * Output: A double representing the total holiday premiums paid to all shift workers. Returns 0 if there are no shift workers.
   * Pre-condition: The employees list is initialized and contains valid employee objects
   * Post-condition: The total holiday premiums are calculated and returned without modifying any shift worker data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateTotalShiftWorkerHolidayPremiums()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Company
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Department` contains the following methods.
  + Instance creation: Use `EmployeeFactory.eINSTANCE.createDepartment()`
  + Public methods: public double calculateAverageWorkerWorkingHours()
  + Getter methods: public DepartmentType getType(), public Manager getManager(), public EList<Employee> getEmployees(), public Company getCompany()
  + Setter methods: public void setType(DepartmentType newType), public void setManager(Manager newManager), public void setCompany(Company newCompany)
- Class `Employee` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: public String getDepartment(), public Date getBirthDate(), public String getName(), public String getSocialInsuranceNumber(), public Company getCompany()
  + Setter methods: public void setDepartment(String newDepartment), public void setBirthDate(Date newBirthDate), public void setName(String newName), public void setSocialInsuranceNumber(String newSocialInsuranceNumber), public void setCompany(Company newCompany)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.employee;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Company</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.employee.Company#getDepartments <em>Departments</em>}</li>
 *   <li>{@link edu.employee.Company#getEmployees <em>Employees</em>}</li>
 * </ul>
 *
 * @see edu.employee.EmployeePackage#getCompany()
 * @model kind="class"
 * @generated
 */
public class Company extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Department> departments;

  protected EList<Employee> employees;

  protected Company()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Department> getDepartments()
  { ... /* omitted */ }

  public EList<Employee> getEmployees()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total salary of all employees in the company by summing up salaries of workers, salespeople, and managers.
   * Algorithm:
   *   1. Initialize totalSalary = 0
   *   2. For each employee in employees:
   *      a. If employee is a Worker:
   *          i. Calculate worker's salary = weeklyWorkingHour * hourlyRates
   *         ii. If employee is a ShiftWorker:
   *             - Add holidayPremium to the salary
   *      b. If employee is a SalesPeople:
   *          i. Calculate salesperson's salary = salary + amountOfSales * commissionPercentage
   *      c. If employee is a Manager:
   *          i. Add manager's salary to the total
   *   3. Return totalSalary
   * Input: None
   * Output: A double representing the total salary of all employees in the company
   * Pre-condition: The employees list is initialized and contains valid employee objects
   * Post-condition: The total salary is calculated and returned without modifying any employee data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateTotalEmployeeSalary()
  {
    double totalSalary = 0;
    
    for (Employee employee : getEmployees()) {
      if (employee instanceof Worker) {
        Worker worker = (Worker) employee;
        double workerSalary = worker.getWeeklyWorkingHour() * worker.getHourlyRates();
        
        if (employee instanceof ShiftWorker) {
          ShiftWorker shiftWorker = (ShiftWorker) employee;
          workerSalary += shiftWorker.getHolidayPremium();
        }
        
        totalSalary += workerSalary;
      }
      else if (employee instanceof SalesPeople) {
        SalesPeople salesPerson = (SalesPeople) employee;
        double salesSalary = salesPerson.getSalary() + (salesPerson.getAmountOfSales() * salesPerson.getCommissionPercentage());
        totalSalary += salesSalary;
      }
      else if (employee instanceof Manager) {
        Manager manager = (Manager) employee;
        totalSalary += manager.getSalary();
      }
    }
    
    return totalSalary;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Determines the total commission amount for all salespeople in the company.
   * Algorithm:
   *   1. Initialize totalCommission = 0
   *   2. For each employee in employees:
   *      a. If employee is a SalesPeople:
   *          i. Add (amountOfSales * commissionPercentage) to totalCommission
   *   3. Return totalCommission
   * Input: None
   * Output: A double representing the total commission amount for all salespeople
   * Pre-condition: The employees list is initialized and contains valid salespeople objects
   * Post-condition: The total commission is calculated and returned without modifying any salesperson data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateTotalSalesPeopleCommission()
  {
    double totalCommission = 0;
    
    for (Employee employee : getEmployees()) {
      if (employee instanceof SalesPeople) {
        SalesPeople salesPerson = (SalesPeople) employee;
        totalCommission += (salesPerson.getAmountOfSales() * salesPerson.getCommissionPercentage());
      }
    }
    
    return totalCommission;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total holiday premiums paid to all shift workers in the company.
   * Algorithm:
   *   1. Initialize totalPremiums = 0
   *   2. For each employee in employees:
   *      a. If employee is a ShiftWorker:
   *          i. Add holidayPremium to totalPremiums
   *   3. Return totalPremiums
   * Input: None
   * Output: A double representing the total holiday premiums paid to all shift workers. Returns 0 if there are no shift workers.
   * Pre-condition: The employees list is initialized and contains valid employee objects
   * Post-condition: The total holiday premiums are calculated and returned without modifying any shift worker data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateTotalShiftWorkerHolidayPremiums()
  {
    double totalPremiums = 0;
    
    for (Employee employee : getEmployees()) {
      if (employee instanceof ShiftWorker) {
        ShiftWorker shiftWorker = (ShiftWorker) employee;
        totalPremiums += shiftWorker.getHolidayPremium();
      }
    }
    
    return totalPremiums;
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Company
827530 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../EmployeeManagementSystem/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../EmployeeManagementSystem/src-gen/edu/employee/
827659 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
827659 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - ----------
1. WARNING in D:\EclipseWorkspace\EmployeeManagementSystem\src-gen\edu\employee\Department.java (at line 22)
	import org.eclipse.emf.common.util.BasicEList;
	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The import org.eclipse.emf.common.util.BasicEList is never used
----------
1 problem (1 warning)

827659 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
827659 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
827660 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample5.mwe2 启动完成
正在拷贝 src-gen/edu/employee 到 qwen3-coder/employee5...
拷贝完成！

======================================
所有任务完成！
======================================

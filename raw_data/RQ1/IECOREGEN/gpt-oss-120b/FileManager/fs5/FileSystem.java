/**
 * generated by Enhanced EcoreGen
 */
package edu.fs;

import java.util.Collection;
import java.util.Date;
import java.util.Map;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
import java.util.List;
import org.eclipse.emf.common.util.BasicEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>File System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.fs.FileSystem#getDocuments <em>Documents</em>}</li>
 *   <li>{@link edu.fs.FileSystem#getEditors <em>Editors</em>}</li>
 * </ul>
 *
 * @see edu.fs.FsPackage#getFileSystem()
 * @model kind="class"
 * @generated
 */
public class FileSystem extends MinimalEObjectImpl.Container implements EObject
{
  /**
   * The cached value of the '{@link #getDocuments() <em>Documents</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getDocuments()
   * @generated
   * @ordered
   */
  protected EList<Document> documents;

  /**
   * The cached value of the '{@link #getEditors() <em>Editors</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getEditors()
   * @generated
   * @ordered
   */
  protected EList<Editor> editors;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected FileSystem()
  {
    super();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  protected EClass eStaticClass()
  {
    return FsPackage.Literals.FILE_SYSTEM;
  }

  /**
   * Returns the value of the '<em><b>Documents</b></em>' containment reference list.
   * The list contents are of type {@link edu.fs.Document}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Documents</em>' containment reference list.
   * @see edu.fs.FsPackage#getFileSystem_Documents()
   * @model containment="true"
   * @generated
   */
  public EList<Document> getDocuments()
  {
    if (documents == null)
    {
      documents = new EObjectContainmentEList<Document>(Document.class, this, FsPackage.FILE_SYSTEM__DOCUMENTS);
    }
    return documents;
  }

  /**
   * Returns the value of the '<em><b>Editors</b></em>' containment reference list.
   * The list contents are of type {@link edu.fs.Editor}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Editors</em>' containment reference list.
   * @see edu.fs.FsPackage#getFileSystem_Editors()
   * @model containment="true"
   * @generated
   */
  public EList<Editor> getEditors()
  {
    if (editors == null)
    {
      editors = new EObjectContainmentEList<Editor>(Editor.class, this, FsPackage.FILE_SYSTEM__EDITORS);
    }
    return editors;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes the total size (in bytes) of all Document objects stored in the FileSystem.
   * Algorithm:
   *   1. Initialize totalSize = 0.
   *   2. For each Document d in getDocuments():
   *        totalSize = totalSize + d.size
   *   3. Return totalSize.
   * Input:
   *   None.
   * Output:
   *   int – the sum of the `size` attribute of every Document in the FileSystem.
   *   Returns 0 if the documents collection is empty.
   * Pre-condition:
   *   The FileSystem instance has been properly instantiated; documents list is initialized (may be empty).
   * Post-condition:
   *   The returned value equals the arithmetic sum of all document sizes at the moment of invocation.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateTotalDocumentSize()
  {
    int totalSize = 0;
    for (Document d : getDocuments()) {
      totalSize += d.getSize();
    }
    return totalSize;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Calculates the average document size for each editor type (TextEditor, ImageEditor, VideoEditor) present in the FileSystem.
   * Algorithm:
   *   1. Create two auxiliary maps:
   *        totalSizeMap  (String → long) initialized to 0 for each editor name.
   *        countMap      (String → int)  initialized to 0 for each editor name.
   *   2. For each Document d in getDocuments():
   *        editorName = d.editor.name
   *        totalSizeMap[editorName] = totalSizeMap[editorName] + d.size
   *        countMap[editorName]     = countMap[editorName] + 1
   *   3. Create resultMap (String → double).
   *   4. For each editorName in {"TextEditor","ImageEditor","VideoEditor"}:
   *        if countMap[editorName] == 0 then
   *            resultMap[editorName] = 0.0
   *        else
   *            resultMap[editorName] = totalSizeMap[editorName] / (double) countMap[editorName]
   *   5. Return resultMap.
   * Input:
   *   None.
   * Output:
   *   EMap (implemented as Map<String, Double>) – a map with three entries:
   *        "TextEditor" → average size of TextEditor documents,
   *        "ImageEditor" → average size of ImageEditor documents,
   *        "VideoEditor" → average size of VideoEditor documents.
   *   The average is expressed as a double; if an editor has no documents, its average is 0.0.
   * Pre-condition:
   *   - The FileSystem instance is properly initialised.
   *   - All Document objects have non‑negative `size` values.
   * Post-condition:
   *   The returned map represents the exact arithmetic mean of document sizes per editor at the time of the call.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Map<String, Float> findAverageSizePerEditor()
  {
    Map<String, Long> totalSizeMap = new HashMap<>();
    Map<String, Integer> countMap = new HashMap<>();

    // initialise for known editors
    String[] editors = { "TextEditor", "ImageEditor", "VideoEditor" };
    for (String e : editors) {
      totalSizeMap.put(e, 0L);
      countMap.put(e, 0);
    }

    // aggregate sizes and counts
    for (Document d : getDocuments()) {
      Editor ed = d.getEditor();
      if (ed != null) {
        String editorName = ed.getName();
        if (totalSizeMap.containsKey(editorName)) {
          totalSizeMap.put(editorName, totalSizeMap.get(editorName) + d.getSize());
          countMap.put(editorName, countMap.get(editorName) + 1);
        }
      }
    }

    // compute averages
    Map<String, Float> resultMap = new HashMap<>();
    for (String e : editors) {
      int cnt = countMap.get(e);
      if (cnt == 0) {
        resultMap.put(e, 0.0f);
      } else {
        long total = totalSizeMap.get(e);
        float avg = (float) total / (float) cnt;
        resultMap.put(e, avg);
      }
    }

    return resultMap;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Counts how many documents in the FileSystem were created strictly after a given date.
   * Algorithm:
   *   1. Validate that the parameter `date` is not null; otherwise throw IllegalArgumentException.
   *   2. Initialize counter = 0.
   *   3. For each Document d in getDocuments():
   *        if d.createDate.isAfter(date) then counter = counter + 1
   *   4. Return counter.
   * Input:
   *   date : EDate – the reference creation date. Must be a valid date object; format follows the EDate specification (e.g., YYYY‑MM‑DD). The date can represent any past, present or future moment.
   * Output:
   *   int – the number of documents whose `createDate` is later than the supplied `date`.
   *   Returns 0 when no document satisfies the condition or the documents collection is empty.
   * Pre-condition:
   *   - `date` is not null.
   *   - documents list is initialized.
   * Post-condition:
   *   The returned integer accurately reflects the count of documents with creation dates after the supplied date at the time of execution.
   * <!-- end-model-doc -->
   * @model dateRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int countDocumentsAfterDate(final Date date)
  {
    if (date == null) {
      throw new IllegalArgumentException("Parameter 'date' must not be null.");
    }

    int counter = 0;
    for (Document d : getDocuments()) {
      Date createDate = d.getCreateDate();
      if (createDate != null && createDate.after(date)) {
        counter++;
      }
    }
    return counter;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves a list of distinct author names whose documents are edited by the specified editor.
   * Algorithm:
   *   1. Validate that the parameter `editor` is not null; otherwise throw IllegalArgumentException.
   *   2. Initialise an empty Set<String> authorSet to guarantee uniqueness.
   *   3. For each Document d in getDocuments():
   *        if d.editor == editor then
   *            authorSet.add(d.author)
   *   4. Convert authorSet to a List<String> preserving insertion order (or any order) and return it.
   * Input:
   *   editor : Editor – a reference to one of the three concrete editor instances (TextEditor, ImageEditor, VideoEditor). Must not be null.
   * Output:
   *   List<String> – a collection of unique author names (String) whose documents are associated with the supplied editor.
   *   Returns an empty list if no documents match the editor.
   * Pre-condition:
   *   - `editor` is a non‑null object that belongs to editors collection.
   *   - documents list is initialized.
   * Post-condition:
   *   The returned list contains no duplicate author names and includes exactly those authors for which at least one Document in the FileSystem references the given editor at the moment of invocation.
   * <!-- end-model-doc -->
   * @model editorRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> getAuthorsByEditor(final Editor editor)
  {
    if (editor == null) {
      throw new IllegalArgumentException("Parameter 'editor' must not be null.");
    }

    Set<String> authorSet = new HashSet<>();
    for (Document d : getDocuments()) {
      if (editor.equals(d.getEditor())) {
        String author = d.getAuthor();
        if (author != null) {
          authorSet.add(author);
        }
      }
    }

    // Convert the set to an EList (order does not matter)
    return new BasicEList<>(authorSet);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Produces a mapping from each editor type (TextEditor, ImageEditor, VideoEditor) to the number of documents associated with that editor in the FileSystem.
   * Algorithm:
   *   1. Create an empty map resultMap where key = String (editor name) and value = Integer (count).
   *   2. Initialise counts for the three known editors to 0:
   *        resultMap["TextEditor"] = 0
   *        resultMap["ImageEditor"] = 0
   *        resultMap["VideoEditor"] = 0
   *   3. For each Document d in getDocuments():
   *        editorName = d.editor.name   // guaranteed to be one of the three names
   *        resultMap[editorName] = resultMap[editorName] + 1
   *   4. Return resultMap.
   * Input:
   *   None.
   * Output:
   *   EMap (implemented as Map<String, Integer>) – a map containing exactly three entries:
   *        "TextEditor" → count of TextEditor documents,
   *        "ImageEditor" → count of ImageEditor documents,
   *        "VideoEditor" → count of VideoEditor documents.
   *   If there are no documents, all counts are 0.
   * Pre-condition:
   *   - documents list is initialized (may be empty).
   *   - Every Document's `editor` reference points to an instance whose `name` matches one of the three supported editors.
   * Post-condition:
   *   The map reflects the exact number of documents per editor type at the moment of invocation.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Map<String, Integer> countDocumentsPerEditorType()
  {
    Map<String, Integer> resultMap = new HashMap<>();

    // initialise counts
    resultMap.put("TextEditor", 0);
    resultMap.put("ImageEditor", 0);
    resultMap.put("VideoEditor", 0);

    for (Document d : getDocuments()) {
      Editor ed = d.getEditor();
      if (ed != null) {
        String editorName = ed.getName();
        if (resultMap.containsKey(editorName)) {
          resultMap.put(editorName, resultMap.get(editorName) + 1);
        }
      }
    }

    return resultMap;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        return ((InternalEList<?>)getDocuments()).basicRemove(otherEnd, msgs);
      case FsPackage.FILE_SYSTEM__EDITORS:
        return ((InternalEList<?>)getEditors()).basicRemove(otherEnd, msgs);
    }
    return super.eInverseRemove(otherEnd, featureID, msgs);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        return getDocuments();
      case FsPackage.FILE_SYSTEM__EDITORS:
        return getEditors();
    }
    return super.eGet(featureID, resolve, coreType);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        getDocuments().clear();
        getDocuments().addAll((Collection<? extends Document>)newValue);
        return;
      case FsPackage.FILE_SYSTEM__EDITORS:
        getEditors().clear();
        getEditors().addAll((Collection<? extends Editor>)newValue);
        return;
    }
    super.eSet(featureID, newValue);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public void eUnset(int featureID)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        getDocuments().clear();
        return;
      case FsPackage.FILE_SYSTEM__EDITORS:
        getEditors().clear();
        return;
    }
    super.eUnset(featureID);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public boolean eIsSet(int featureID)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        return documents != null && !documents.isEmpty();
      case FsPackage.FILE_SYSTEM__EDITORS:
        return editors != null && !editors.isEmpty();
    }
    return super.eIsSet(featureID);
  }

} // FileSystem

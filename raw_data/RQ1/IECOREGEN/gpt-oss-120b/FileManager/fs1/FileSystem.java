/**
 * generated by Enhanced EcoreGen
 */
package edu.fs;

import java.util.Collection;
import java.util.Date;
import java.util.Map;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.List;
import java.util.ArrayList;
import org.eclipse.emf.common.util.BasicEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>File System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.fs.FileSystem#getDocuments <em>Documents</em>}</li>
 *   <li>{@link edu.fs.FileSystem#getEditors <em>Editors</em>}</li>
 * </ul>
 *
 * @see edu.fs.FsPackage#getFileSystem()
 * @model kind="class"
 * @generated
 */
public class FileSystem extends MinimalEObjectImpl.Container implements EObject
{
  /**
   * The cached value of the '{@link #getDocuments() <em>Documents</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getDocuments()
   * @generated
   * @ordered
   */
  protected EList<Document> documents;

  /**
   * The cached value of the '{@link #getEditors() <em>Editors</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getEditors()
   * @generated
   * @ordered
   */
  protected EList<Editor> editors;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected FileSystem()
  {
    super();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  protected EClass eStaticClass()
  {
    return FsPackage.Literals.FILE_SYSTEM;
  }

  /**
   * Returns the value of the '<em><b>Documents</b></em>' containment reference list.
   * The list contents are of type {@link edu.fs.Document}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Documents</em>' containment reference list.
   * @see edu.fs.FsPackage#getFileSystem_Documents()
   * @model containment="true"
   * @generated
   */
  public EList<Document> getDocuments()
  {
    if (documents == null)
    {
      documents = new EObjectContainmentEList<Document>(Document.class, this, FsPackage.FILE_SYSTEM__DOCUMENTS);
    }
    return documents;
  }

  /**
   * Returns the value of the '<em><b>Editors</b></em>' containment reference list.
   * The list contents are of type {@link edu.fs.Editor}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Editors</em>' containment reference list.
   * @see edu.fs.FsPackage#getFileSystem_Editors()
   * @model containment="true"
   * @generated
   */
  public EList<Editor> getEditors()
  {
    if (editors == null)
    {
      editors = new EObjectContainmentEList<Editor>(Editor.class, this, FsPackage.FILE_SYSTEM__EDITORS);
    }
    return editors;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes the total size (in bytes) of all Document objects stored in the FileSystem.
   * Algorithm:
   *   1. Initialize totalSize to 0.
   *   2. Iterate over each Document d in this.documents:
   *        totalSize ← totalSize + d.size
   *   3. Return totalSize.
   * Input:
   *   None.
   * Output:
   *   int totalSize – the sum of the size field of every Document.
   *   Returns 0 when this.documents is empty.
   * Pre-condition:
   *   - The FileSystem instance has been created and its documents list is non‑null.
   * Post-condition:
   *   - The returned value equals the aggregate size of all stored documents.
   *   - No modification of any Document or FileSystem state occurs.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateTotalDocumentSize()
  {
    int totalSize = 0;
    for (Document d : this.getDocuments()) {
      totalSize += d.getSize();
    }
    return totalSize;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Calculates, for each editor type, the average size of its associated documents.
   * Algorithm:
   *   1. Create two empty maps:
   *        sumMap   (key: String editor type, value: long totalSize)
   *        countMap (key: String editor type, value: int documentCount)
   *   2. Initialise the keys "TextEditor", "ImageEditor", "VideoEditor" in both maps with 0.
   *   3. For each Document d in this.documents:
   *        editorName ← d.editor.getClass().getSimpleName()
   *        sumMap[editorName]   ← sumMap[editorName]   + d.size
   *        countMap[editorName] ← countMap[editorName] + 1
   *   4. Create resultMap (EMap<String, Double>).
   *   5. For each editorName in {"TextEditor","ImageEditor","VideoEditor"}:
   *        if countMap[editorName] > 0
   *            avg ← sumMap[editorName] / countMap[editorName]   // floating‑point division
   *        else
   *            avg ← 0.0
   *        resultMap.put(editorName, avg)
   *   6. Return resultMap.
   * Input:
   *   None.
   * Output:
   *   EMap<String, Double> resultMap – a map where each key is an editor type name and the value
   *   is the arithmetic mean of the size fields of all documents belonging to that editor.
   *   If an editor has no documents, its average size is 0.0.
   * Pre-condition:
   *   - this.documents is non‑null.
   *   - Document.size is non‑negative.
   * Post-condition:
   *   - resultMap contains exactly three entries, one per editor type, with correct average values.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Map<String, Float> findAverageSizePerEditor()
  {
    // maps for accumulating total sizes and counts
    Map<String, Long> sumMap = new HashMap<>();
    Map<String, Integer> countMap = new HashMap<>();

    // initialise keys
    String[] editorTypes = {"TextEditor", "ImageEditor", "VideoEditor"};
    for (String type : editorTypes) {
      sumMap.put(type, 0L);
      countMap.put(type, 0);
    }

    // accumulate sums and counts
    for (Document d : this.getDocuments()) {
      Editor editor = d.getEditor();
      if (editor != null) {
        String editorName = editor.getClass().getSimpleName();
        // only consider the three known types; ignore others safely
        if (sumMap.containsKey(editorName)) {
          sumMap.put(editorName, sumMap.get(editorName) + d.getSize());
          countMap.put(editorName, countMap.get(editorName) + 1);
        }
      }
    }

    // compute averages
    Map<String, Float> resultMap = new HashMap<>();
    for (String type : editorTypes) {
      int count = countMap.get(type);
      if (count > 0) {
        float avg = (float) (sumMap.get(type).doubleValue() / count);
        resultMap.put(type, avg);
      } else {
        resultMap.put(type, 0.0f);
      }
    }

    return resultMap;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Counts how many documents in the FileSystem were created strictly after a given date.
   * Algorithm:
   *   1. Verify that the parameter date is not null.
   *   2. Initialize counter to 0.
   *   3. For each Document d in this.documents:
   *        if d.createDate > date then counter ← counter + 1
   *   4. Return counter.
   * Input:
   *   - date : EDate
   *       The reference date; must be a valid calendar date. Documents with createDate equal to the
   *       parameter are NOT counted.
   * Output:
   *   int count – the number of documents whose createDate is later than the supplied date.
   *   Returns 0 if no such documents exist or if this.documents is empty.
   * Pre-condition:
   *   - this.documents is non‑null.
   *   - date is a valid EDate instance.
   * Post-condition:
   *   - The returned count reflects the number of documents with createDate > date at the time of the call.
   * <!-- end-model-doc -->
   * @model dateRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int countDocumentsAfterDate(final Date date)
  {
    if (date == null) {
      throw new IllegalArgumentException("Parameter 'date' must not be null.");
    }
    int counter = 0;
    for (Document d : this.getDocuments()) {
      Date createDate = d.getCreateDate();
      if (createDate != null && createDate.after(date)) {
        counter++;
      }
    }
    return counter;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves the distinct author names of all documents that are edited with the specified editor.
   * Algorithm:
   *   1. Verify that the parameter editor is not null.
   *   2. Create an empty set authorSet of type Set<String>.
   *   3. For each Document d in this.documents:
   *        if d.editor == editor then
   *            authorSet.add(d.author)
   *   4. Convert authorSet to a List<String> preserving any order (e.g., alphabetical sort is optional).
   *   5. Return the List.
   * Input:
   *   - editor : Editor
   *       The concrete editor instance (e.g., a TextEditor object) whose documents are to be examined.
   * Output:
   *   List<String> authors – a list of unique author names whose documents are associated with the supplied editor.
   *   Returns an empty list when no matching documents exist.
   * Pre-condition:
   *   - this.documents is non‑null.
   *   - editor is a valid instance contained in this.editors (if not, the result will be empty).
   * Post-condition:
   *   - The returned list contains no duplicate author names.
   *   - No modification of any Document or Editor is performed.
   * <!-- end-model-doc -->
   * @model editorRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> getAuthorsByEditor(final Editor editor)
  {
    if (editor == null) {
      throw new IllegalArgumentException("Parameter 'editor' must not be null.");
    }

    Set<String> authorSet = new HashSet<>();
    for (Document d : this.getDocuments()) {
      if (editor.equals(d.getEditor())) {
        String author = d.getAuthor();
        if (author != null) {
          authorSet.add(author);
        }
      }
    }

    EList<String> result = new BasicEList<>();
    result.addAll(authorSet);
    return result;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Produces a mapping from each concrete Editor type (TextEditor, ImageEditor, VideoEditor)
   *   to the number of documents associated with that editor in the FileSystem.
   * Algorithm:
   *   1. Create an empty map resultMap where key = String (editor type name) and value = Integer.
   *   2. Initialise the three keys ("TextEditor", "ImageEditor", "VideoEditor") with 0.
   *   3. For each Document d in this.documents:
   *        editorName ← d.editor.getClass().getSimpleName()
   *        current ← resultMap.get(editorName)
   *        resultMap.put(editorName, current + 1)
   *   4. Return resultMap.
   * Input:
   *   None.
   * Output:
   *   EMap<String, Integer> resultMap – a map whose entries are:
   *       "TextEditor" → number of documents edited by a TextEditor,
   *       "ImageEditor" → number of documents edited by an ImageEditor,
   *       "VideoEditor" → number of documents edited by a VideoEditor.
   *   Keys are always present with a value of 0 when no documents of that type exist.
   * Pre-condition:
   *   - this.documents is non‑null.
   *   - Every Document's editor reference is non‑null and points to an instance of one of the three concrete editors.
   * Post-condition:
   *   - resultMap accurately reflects the current distribution of documents across editor types.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Map<String, Integer> countDocumentsPerEditorType()
  {
    Map<String, Integer> resultMap = new HashMap<>();
    String[] editorTypes = {"TextEditor", "ImageEditor", "VideoEditor"};
    for (String type : editorTypes) {
      resultMap.put(type, 0);
    }

    for (Document d : this.getDocuments()) {
      Editor editor = d.getEditor();
      if (editor != null) {
        String editorName = editor.getClass().getSimpleName();
        if (resultMap.containsKey(editorName)) {
          int current = resultMap.get(editorName);
          resultMap.put(editorName, current + 1);
        }
      }
    }

    return resultMap;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        return ((InternalEList<?>)getDocuments()).basicRemove(otherEnd, msgs);
      case FsPackage.FILE_SYSTEM__EDITORS:
        return ((InternalEList<?>)getEditors()).basicRemove(otherEnd, msgs);
    }
    return super.eInverseRemove(otherEnd, featureID, msgs);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        return getDocuments();
      case FsPackage.FILE_SYSTEM__EDITORS:
        return getEditors();
    }
    return super.eGet(featureID, resolve, coreType);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        getDocuments().clear();
        getDocuments().addAll((Collection<? extends Document>)newValue);
        return;
      case FsPackage.FILE_SYSTEM__EDITORS:
        getEditors().clear();
        getEditors().addAll((Collection<? extends Editor>)newValue);
        return;
    }
    super.eSet(featureID, newValue);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public void eUnset(int featureID)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        getDocuments().clear();
        return;
      case FsPackage.FILE_SYSTEM__EDITORS:
        getEditors().clear();
        return;
    }
    super.eUnset(featureID);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public boolean eIsSet(int featureID)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        return documents != null && !documents.isEmpty();
      case FsPackage.FILE_SYSTEM__EDITORS:
        return editors != null && !editors.isEmpty();
    }
    return super.eIsSet(featureID);
  }

} // FileSystem

/**
 * generated by Enhanced EcoreGen
 */
package edu.videorental;

import java.util.Collection;
import java.util.Date;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.EObjectWithInverseResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;
import java.util.Calendar;
import org.eclipse.emf.common.util.BasicEList;
import edu.videorental.VideorentalFactory;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Customer</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.videorental.Customer#getId <em>Id</em>}</li>
 *   <li>{@link edu.videorental.Customer#getRentals <em>Rentals</em>}</li>
 *   <li>{@link edu.videorental.Customer#getTransactions <em>Transactions</em>}</li>
 * </ul>
 *
 * @see edu.videorental.VideorentalPackage#getCustomer()
 * @model kind="class"
 * @generated
 */
public class Customer extends MinimalEObjectImpl.Container implements EObject
{
  /**
   * The default value of the '{@link #getId() <em>Id</em>}' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getId()
   * @generated
   * @ordered
   */
  protected static final String ID_EDEFAULT = null;

  /**
   * The cached value of the '{@link #getId() <em>Id</em>}' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getId()
   * @generated
   * @ordered
   */
  protected String id = ID_EDEFAULT;

  /**
   * The cached value of the '{@link #getRentals() <em>Rentals</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getRentals()
   * @generated
   * @ordered
   */
  protected EList<VideoRental> rentals;

  /**
   * The cached value of the '{@link #getTransactions() <em>Transactions</em>}' reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getTransactions()
   * @generated
   * @ordered
   */
  protected EList<RentalTransaction> transactions;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected Customer()
  {
    super();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  protected EClass eStaticClass()
  {
    return VideorentalPackage.Literals.CUSTOMER;
  }

  /**
   * Returns the value of the '<em><b>Id</b></em>' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Id</em>' attribute.
   * @see #setId(String)
   * @see edu.videorental.VideorentalPackage#getCustomer_Id()
   * @model
   * @generated
   */
  public String getId()
  {
    return id;
  }

  /**
   * Sets the value of the '{@link edu.videorental.Customer#getId <em>Id</em>}' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @param newId the new value of the '<em>Id</em>' attribute.
   * @see #getId()
   * @generated
   */
  public void setId(String newId)
  {
    String oldId = id;
    id = newId;
    if (eNotificationRequired())
      eNotify(new ENotificationImpl(this, Notification.SET, VideorentalPackage.CUSTOMER__ID, oldId, id));
  }

  /**
   * Returns the value of the '<em><b>Rentals</b></em>' containment reference list.
   * The list contents are of type {@link edu.videorental.VideoRental}.
   * It is bidirectional and its opposite is '{@link edu.videorental.VideoRental#getCustomer <em>Customer</em>}'.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Rentals</em>' containment reference list.
   * @see edu.videorental.VideorentalPackage#getCustomer_Rentals()
   * @see edu.videorental.VideoRental#getCustomer
   * @model opposite="customer" containment="true" upper="20"
   * @generated
   */
  public EList<VideoRental> getRentals()
  {
    if (rentals == null)
    {
      rentals = new EObjectContainmentWithInverseEList<VideoRental>(VideoRental.class, this, VideorentalPackage.CUSTOMER__RENTALS, VideorentalPackage.VIDEO_RENTAL__CUSTOMER);
    }
    return rentals;
  }

  /**
   * Returns the value of the '<em><b>Transactions</b></em>' reference list.
   * The list contents are of type {@link edu.videorental.RentalTransaction}.
   * It is bidirectional and its opposite is '{@link edu.videorental.RentalTransaction#getCustomer <em>Customer</em>}'.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Transactions</em>' reference list.
   * @see edu.videorental.VideorentalPackage#getCustomer_Transactions()
   * @see edu.videorental.RentalTransaction#getCustomer
   * @model opposite="customer"
   * @generated
   */
  public EList<RentalTransaction> getTransactions()
  {
    if (transactions == null)
    {
      transactions = new EObjectWithInverseResolvingEList<RentalTransaction>(RentalTransaction.class, this, VideorentalPackage.CUSTOMER__TRANSACTIONS, VideorentalPackage.RENTAL_TRANSACTION__CUSTOMER);
    }
    return transactions;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary
   *   Attempts to add a new video‑tape rental for this customer.
   *   The method verifies that the customer does not exceed the maximum of 20
   *   concurrent rentals, that the customer has no unpaid past‑due amount, and
   *   that the requested tape is available on the given date.
   *   If all checks pass a new VideoRental object is created, linked to the
   *   customer, the tape and a newly created RentalTransaction, and the method
   *   returns true; otherwise no rental is created and false is returned.
   * Input
   *   tape          : Tape   – the tape the customer wants to rent.
   *   currentDate   : EDate  – the current date‑time in format "yyyy-MM-dd HH:mm:ss".
   * Output
   *   boolean – true if the rental is successfully processed, false otherwise.
   * Algorithm
   *   1. // pre‑condition: tape != null, currentDate is a valid date string
   *   2. if this.rentals.size() >= 20
   *        return false   // customer already has the maximum number of rentals
   *   3. pastDue := this.calculateTotalPastDueAmount(currentDate)
   *      if pastDue > 0.0
   *        return false   // unpaid past‑due amount blocks new rentals
   *   4. if !tape.isAvailable(currentDate)
   *        return false   // tape is currently rented out
   *   5. // create a new transaction for this rental (one‑to‑many transactions per customer)
   *      transaction := new RentalTransaction()
   *      transaction.customer   = this
   *      transaction.rentalDate = currentDate
   *   6. // create the rental linking all objects
   *      rental := new VideoRental()
   *      rental.customer   = this
   *      rental.tape       = tape
   *      rental.transaction = transaction
   *      // dueDate is set to currentDate + allowed rental period (e.g., 7 days);
   *      // for this specification we assume a default period of 7 days.
   *      rental.dueDate = currentDate.addDays(7)
   *      rental.returnDate = null
   *      rental.ownedPastDueAmount = 0.0
   *   7. // maintain bidirectional relations
   *      this.rentals.add(rental)
   *      tape.rentals.add(rental)
   *      transaction.rentals.add(rental)
   *      this.transactions.add(transaction)
   *   8. return true
   * Pre‑condition
   *   - tape object exists in the inventory.
   *   - currentDate is a correctly formatted, parseable date‑time.
   * Post‑condition
   *   - If true is returned, a new VideoRental is persisted and linked to the
   *     customer, tape, and a new RentalTransaction.
   *   - If false is returned, system state is unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean addVedioTapeRental(final Tape tape, final Date currentDate)
  {
    // pre‑condition: tape != null, currentDate != null (assumed)
    if (tape == null || currentDate == null) {
        return false;
    }

    // 2. Check maximum concurrent rentals
    if (this.getRentals().size() >= 20) {
        return false; // customer already has the maximum number of rentals
    }

    // 3. Check for unpaid past‑due amount
    double pastDue = this.calculateTotalPastDueAmount(currentDate);
    if (pastDue > 0.0) {
        return false; // unpaid past‑due amount blocks new rentals
    }

    // 4. Verify tape availability
    if (!tape.isAvailable(currentDate)) {
        return false; // tape is currently rented out
    }

    // 5. Create a new RentalTransaction
    RentalTransaction transaction = VideorentalFactory.eINSTANCE.createRentalTransaction();
    transaction.setCustomer(this);
    transaction.setRentalDate(currentDate);

    // 6. Create the VideoRental and link objects
    VideoRental rental = VideorentalFactory.eINSTANCE.createVideoRental();
    rental.setCustomer(this);
    rental.setTape(tape);
    rental.setTransaction(transaction);

    // Set dueDate = currentDate + 7 days
    Calendar cal = Calendar.getInstance();
    cal.setTime(currentDate);
    cal.add(Calendar.DAY_OF_MONTH, 7);
    Date dueDate = cal.getTime();
    rental.setDueDate(dueDate);
    rental.setReturnDate(null);
    rental.setOwnedPastDueAmount(0.0);

    // 7. Maintain bidirectional relations
    this.getRentals().add(rental);
    tape.getRentals().add(rental);
    transaction.getRentals().add(rental);
    this.getTransactions().add(transaction);

    // 8. Success
    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary
   *   Retrieves a list containing the identifiers of all tapes that the customer
   *   has rented but not yet returned.
   * Input
   *   (none)
   * Output
   *   List<Tape> – a list of Tape objects whose associated VideoRental has a null
   *                returnDate. The list is empty if none exist.
   * Algorithm
   *   1. result := empty list
   *   2. for each rental in this.rentals
   *        if rental.returnDate == null
   *            result.add(rental.tape)
   *   3. return result
   * Pre‑condition
   *   - Customer object is fully initialized.
   * Post‑condition
   *   - No side effects; the returned list reflects the current state of rentals.
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Tape> getUnreturnedTapes()
  {
    EList<Tape> result = new BasicEList<Tape>();
    for (VideoRental rental : this.getRentals()) {
        if (rental.getReturnDate() == null) {
            result.add(rental.getTape());
        }
    }
    return result;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary
   *   Computes the sum of all overdue fees for this customer's active rentals
   *   as of the supplied current date.
   * Input
   *   currentDate : EDate – the date‑time for which the overdue fees are evaluated
   *                         (format "yyyy-MM-dd HH:mm:ss").
   * Output
   *   double – total overdue amount, rounded to two decimal places.
   * Algorithm
   *   1. total := 0.0
   *   2. for each rental in this.rentals
   *        if rental.returnDate == null OR rental.returnDate.after(rental.dueDate)
   *            overdue := rental.calculateOwnedPastDueAmount(currentDate)
   *            total := total + overdue
   *   3. return round(total, 2)
   * Pre‑condition
   *   - currentDate is a valid, parseable date‑time.
   * Post‑condition
   *   - Returns the aggregated overdue amount; does not modify any rental data.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateTotalPastDueAmount(final Date currentDate)
  {
    double total = 0.0;
    for (VideoRental rental : this.getRentals()) {
        Date returnDate = rental.getReturnDate();
        Date dueDate = rental.getDueDate();
        if (returnDate == null || returnDate.after(dueDate)) {
            double overdue = rental.calculateOwnedPastDueAmount(currentDate);
            total += overdue;
        }
    }
    // round to two decimal places
    total = Math.round(total * 100.0) / 100.0;
    return total;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  {
    switch (featureID)
    {
      case VideorentalPackage.CUSTOMER__RENTALS:
        return ((InternalEList<InternalEObject>)(InternalEList<?>)getRentals()).basicAdd(otherEnd, msgs);
      case VideorentalPackage.CUSTOMER__TRANSACTIONS:
        return ((InternalEList<InternalEObject>)(InternalEList<?>)getTransactions()).basicAdd(otherEnd, msgs);
    }
    return super.eInverseAdd(otherEnd, featureID, msgs);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  {
    switch (featureID)
    {
      case VideorentalPackage.CUSTOMER__RENTALS:
        return ((InternalEList<?>)getRentals()).basicRemove(otherEnd, msgs);
      case VideorentalPackage.CUSTOMER__TRANSACTIONS:
        return ((InternalEList<?>)getTransactions()).basicRemove(otherEnd, msgs);
    }
    return super.eInverseRemove(otherEnd, featureID, msgs);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  {
    switch (featureID)
    {
      case VideorentalPackage.CUSTOMER__ID:
        return getId();
      case VideorentalPackage.CUSTOMER__RENTALS:
        return getRentals();
      case VideorentalPackage.CUSTOMER__TRANSACTIONS:
        return getTransactions();
    }
    return super.eGet(featureID, resolve, coreType);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  {
    switch (featureID)
    {
      case VideorentalPackage.CUSTOMER__ID:
        setId((String)newValue);
        return;
      case VideorentalPackage.CUSTOMER__RENTALS:
        getRentals().clear();
        getRentals().addAll((Collection<? extends VideoRental>)newValue);
        return;
      case VideorentalPackage.CUSTOMER__TRANSACTIONS:
        getTransactions().clear();
        getTransactions().addAll((Collection<? extends RentalTransaction>)newValue);
        return;
    }
    super.eSet(featureID, newValue);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public void eUnset(int featureID)
  {
    switch (featureID)
    {
      case VideorentalPackage.CUSTOMER__ID:
        setId(ID_EDEFAULT);
        return;
      case VideorentalPackage.CUSTOMER__RENTALS:
        getRentals().clear();
        return;
      case VideorentalPackage.CUSTOMER__TRANSACTIONS:
        getTransactions().clear();
        return;
    }
    super.eUnset(featureID);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public boolean eIsSet(int featureID)
  {
    switch (featureID)
    {
      case VideorentalPackage.CUSTOMER__ID:
        return ID_EDEFAULT == null ? id != null : !ID_EDEFAULT.equals(id);
      case VideorentalPackage.CUSTOMER__RENTALS:
        return rentals != null && !rentals.isEmpty();
      case VideorentalPackage.CUSTOMER__TRANSACTIONS:
        return transactions != null && !transactions.isEmpty();
    }
    return super.eIsSet(featureID);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public String toString()
  {
    if (eIsProxy()) return super.toString();

    StringBuilder result = new StringBuilder(super.toString());
    result.append(" (id: ");
    result.append(id);
    result.append(')');
    return result.toString();
  }

} // Customer

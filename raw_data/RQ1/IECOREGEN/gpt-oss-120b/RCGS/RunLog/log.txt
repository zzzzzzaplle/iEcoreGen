   *   - `this.cars` and `this.rentals` are non‑null collections (may be empty).
   * Post‑condition:
   *   - Returned list contains only cars that have no active rental (`backDate == null`).
   *   - The list is sorted strictly by `dailyPrice` in ascending order.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Car> identifyAvailableCars()
  {
    // 1. Initialise an empty list `availableCars`.
    EList<Car> availableCars = new BasicEList<>();

    // 2. Iterate over each car in this.cars
    for (Car car : getCars()) {
      boolean hasActiveRental = false;
      // Check rentals for an active one with the same plate
      for (Rental rental : getRentals()) {
        Car rentedCar = rental.getCar();
        if (rentedCar != null
            && rentedCar.getPlate() != null
            && rentedCar.getPlate().equals(car.getPlate())
            && rental.getBackDate() == null) {
          hasActiveRental = true;
          break;
        }
      }
      // a. If no such rental exists, add the car to the result list
      if (!hasActiveRental) {
        availableCars.add(car);
      }
    }

    // 3. Sort the list by dailyPrice (ascending, stable)
    availableCars.sort(Comparator.comparingDouble(Car::getDailyPrice));

    // 4. Return the list
    return availableCars;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes the total revenue generated by all completed rentals stored in the store.
   * Algorithm:
   *   1. Initialise `totalRevenue` ← 0.0.
   *   2. FOR each `rental` in `this.rentals` DO
   *        a. IF rental.backDate != null        // rental is finished
   *           THEN `totalRevenue` ← `totalRevenue` + rental.totalPrice.
   *   3. RETURN `totalRevenue`.
   * Input:
   *   - None.
   * Output:
   *   - double `totalRevenue`
   *       * Meaning: sum of `totalPrice` of all rentals that have been returned.
   *       * Format: floating‑point number rounded to two decimal places (currency style).
   *       * Value range: ≥ 0.0.
   * Pre‑condition:
   *   - `this.rentals` is non‑null.
   * Post‑condition:
   *   - `totalRevenue` equals Σ rental.totalPrice for all rentals where backDate ≠ null.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateTotalRevenue()
  {
    double totalRevenue = 0.0;

    for (Rental rental : getRentals()) {
      if (rental.getBackDate() != null) {
        totalRevenue += rental.getTotalPrice();
      }
    }

    return totalRevenue;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves all customers whose active rentals are overdue as of `currentDate`.
   * Algorithm:
   *   1. Validate that `currentDate` is not null; THROW IllegalArgumentException otherwise.
   *   2. Initialise empty list `overdueCustomers`.
   *   3. FOR each `rental` in `this.rentals` DO
   *        a. IF rental.backDate == null                               // still out
   *           AND rental.dueDate < `currentDate`                       // past due
   *           THEN
   *                i. IF rental.customer NOT already in `overdueCustomers`
   *                   THEN add rental.customer to `overdueCustomers`.
   *   4. RETURN `overdueCustomers`.
   * Input:
   *   - EDate `currentDate`
   *       * Meaning: the date against which overdue status is evaluated.
   *       * Format: ISO‑8601 string "yyyy-MM-dd" (e.g., "2025-11-14").
   *       * Value range: any valid calendar date.
   * Output:
   *   - List<Customer> `overdueCustomers`
   *       * Meaning: distinct customers with at least one active overdue rental.
   *       * Format: mutable list; order of insertion (no specific sorting required).
   *       * Value range: may be empty if no overdue rentals exist.
   * Pre‑condition:
   *   - `this.rentals` is non‑null.
   *   - `currentDate` is a valid, non‑null date.
   * Post‑condition:
   *   - Every customer in the returned list has at least one rental where `backDate == null`
   *     and `dueDate` precedes `currentDate`.
   *   - No duplicate customers appear in the list.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Customer> findCustomersWithOverdueRentals(final Date currentDate)
  {
    if (currentDate == null) {
      throw new IllegalArgumentException("currentDate must not be null");
    }

    EList<Customer> overdueCustomers = new BasicEList<>();

    for (Rental rental : getRentals()) {
      if (rental.getBackDate() == null && rental.getDueDate() != null
          && rental.getDueDate().compareTo(currentDate) < 0) {
        Customer cust = rental.getCustomer();
        if (cust != null && !overdueCustomers.contains(cust)) {
          overdueCustomers.add(cust);
        }
      }
    }

    return overdueCustomers;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Calculates the average daily price of all cars recorded in the store.
   * Algorithm:
   *   1. IF `this.cars` is empty THEN RETURN 0.0.
   *   2. Initialise `sumPrice` ← 0.0.
   *   3. FOR each `car` in `this.cars` DO
   *        a. `sumPrice` ← `sumPrice` + car.dailyPrice.
   *   4. `average` ← `sumPrice` / size(`this.cars`).
   *   5. RETURN `average`.
   * Input:
   *   - None.
   * Output:
   *   - double `average`
   *       * Meaning: arithmetic mean of daily prices of all cars.
   *       * Format: floating‑point number (two decimal places).
   *       * Value range: 0.0 ≤ `average`.
   * Pre‑condition:
   *   - `this.cars` is non‑null.
   * Post‑condition:
   *   - If the store has at least one car, `average` = Σ car.dailyPrice / numberOfCars.
   *   - If the store has no cars, `average` = 0.0.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double determineAverageDailyPrice()
  {
    if (getCars().isEmpty()) {
      return 0.0;
    }

    double sumPrice = 0.0;
    for (Car car : getCars()) {
      sumPrice += car.getDailyPrice();
    }

    return sumPrice / getCars().size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Produces a mapping from each customer to the number of cars they have rented (including both
   *   active and completed rentals).
   * Algorithm:
   *   1. Initialise empty map `countMap` : Customer → Integer.
   *   2. FOR each `rental` in `this.rentals` DO
   *        a. Let `cust` ← rental.customer.
   *        b. IF `cust` is already a key in `countMap`
   *              THEN `countMap[cust]` ← `countMap[cust]` + 1
   *              ELSE `countMap[cust]` ← 1.
   *   3. Convert `countMap` into a List<EMap> where each element contains:
   *        - key : Customer
   *        - value : Integer (rental count)
   *   4. RETURN the list.
   * Input:
   *   - None.
   * Output:
   *   - List<EMap> `customerRentalCounts`
   *       * Meaning: each entry pairs a Customer object with the integer count of rentals they have made.
   *       * Format: List where each element implements map‑like access (`entry.key`, `entry.value`).
   *       * Value range: may be empty if no rentals have been recorded.
   * Pre‑condition:
   *   - `this.rentals` is non‑null.
   * Post‑condition:
   *   - For every Customer `c` that appears in any Rental, there exists exactly one entry
   *     (`c`, n) in the returned list where n equals the number of rentals associated with `c`.
   *   - Customers without rentals are absent from the list.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Map<Customer, Integer>> countCarsRentedPerCustomer()
  {
    // 1. Initialise countMap
    Map<Customer, Integer> countMap = new HashMap<>();

    // 2. Populate the map
    for (Rental rental : getRentals()) {
      Customer cust = rental.getCustomer();
      if (cust != null) {
        countMap.put(cust, countMap.getOrDefault(cust, 0) + 1);
      }
    }

    // 3. Convert each entry into a single‑entry map and collect them into a list
    EList<Map<Customer, Integer>> result = new BasicEList<>();
    for (Map.Entry<Customer, Integer> entry : countMap.entrySet()) {
      Map<Customer, Integer> singleMap = new HashMap<>();
      singleMap.put(entry.getKey(), entry.getValue());
      result.add(singleMap);
    }

    // 4. Return the list
    return result;
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { /* omitted */ }

} // Store
115409 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../RCGS/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../RCGS/src-gen/edu/carrental/
115548 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
115548 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
115548 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
115548 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
115550 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample3.mwe2 启动完成
正在拷贝 src-gen/edu/carrental 到 gpt-oss-120b/carrental3...
拷贝完成！

======================================
正在启动 sample4.mwe2...
======================================
115780 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
115847 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project RCGS at 'file:/D:/EclipseWorkspace/RCGS/'
115850 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
115857 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@56887c8f
115857 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
115858 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
115859 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
Store assistants should store the information for each car in the gallery, such as plate, model, and daily price. 
When customers want to rent a car, the system must show available car records in the gallery and be sorted according to their prices. The system lists the rented car records when the store assistant person enters the related button. Store assistant searches for available cars, submit renting a car, and produces rental reports. The store assistant updates the rental list when he rents a car or takes back a car. The main office sends overdue notices due to late arrivals.
 The store assistant records the customer's information, such as name, surname, address, plate of the rented car, and leasing terms.
Function Requirement:
+ Identify available cars in the store. A car is available if it is not currently rented. Return a list of available cars, sorted by daily price in ascending order. If no available cars exist, return an empty list.

+ Calculate the total revenue generated by all rentals in the store.

+ List customers with overdue rentals. For each rental, if the back date is null and the current date is past the due date (format: yyyy-MM-dd), mark it as overdue. Return an empty list if no overdue customers exist.

+ Determine the average daily price of cars in the store: sum the daily prices of all cars and divide by the total number of cars. If the store has no cars, return 0.0.

+ Count the number of cars rented per customer. Return a map of customers and their respective rental counts, or an empty map if no customers have rented cars.
```

# Class Diagram
```plantuml
@startuml

title carrental Model

class Car {
    dailyPrice : double
    model : String
    plate : String
}
class Customer {
    address : String
    name : String
    rentedCarPlate : String
    surname : String
}
class OverdueNotice {
    customer : Customer
}
class Rental {
    backDate : EDate
    dueDate : EDate
    leasingTerms : String
    rentalDate : EDate
    totalPrice : double
    car : Car
    customer : Customer
}
class Store {
    cars : List<Car>
    notices : List<OverdueNotice>
    rentals : List<Rental>
    calculateTotalRevenue() : double
    countCarsRentedPerCustomer() : List<EMap>
    determineAverageDailyPrice() : double
    findCustomersWithOverdueRentals(currentDate : EDate) : List<Customer>
    identifyAvailableCars() : List<Car>
}

OverdueNotice --> Customer : customer
Rental --> Car : car
Rental --> Customer : customer
Store *-- "*" Car : cars
Store *-- "*" OverdueNotice : notices
Store *-- "*" Rental : rentals
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

132564 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@b666366 (name: determineAverageDailyPrice) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Computes the average daily rental price of all cars stored in the gallery.
  If the store has no cars, the function returns 0.0.
Algorithm:
  1. If `this.cars` is empty, return 0.0.
  2. Initialize `sumPrice` to 0.0.
  3. For each `car` in `this.cars`, add `car.dailyPrice` to `sumPrice`.
  4. Compute `average = sumPrice / this.cars.size()`.
  5. Return `average`.
Input:
  None.
Output:
  double – the arithmetic mean of `dailyPrice` across all cars.
  Returns 0.0 when `this.cars` is empty.
Pre-condition:
  - `this.cars` is non‑null; each `Car` object has a valid `dailyPrice` (>= 0).
Post-condition:
  - The returned value equals the sum of all daily prices divided by the number of cars,
    or 0.0 if there are no cars., org.eclipse.emf.ecore.impl.EOperationImpl@7bbe852a (name: findCustomersWithOverdueRentals) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary:
  Retrieves a list of customers whose rentals are overdue as of the supplied `currentDate`.
  A rental is overdue when its `backDate` is null (car not yet returned) and `currentDate`
  is later than the rental's `dueDate`.
Algorithm:
  1. Validate that `currentDate` is not null.
  2. Initialize an empty set `overdueCustomers` (to avoid duplicates).
  3. For each `rental` in `this.rentals`:
       a. If `rental.backDate == null` AND `currentDate > rental.dueDate`:
             add `rental.customer` to `overdueCustomers`.
  4. Convert `overdueCustomers` to a List<Customer> preserving insertion order.
  5. Return the list (may be empty).
Input:
  - currentDate : EDate
      * Meaning: the date against which overdue status is evaluated.
      * Format: ISO‑8601 date string "yyyy-MM-dd" (e.g., "2025-11-14").
Output:
  List<Customer> – a list of distinct customers with at least one overdue rental.
  The list may be empty if no overdues exist.
Pre-condition:
  - `currentDate` is a valid, non‑null `EDate`.
  - `this.rentals` and each `Rental`'s `dueDate` are properly set.
Post-condition:
  - Every customer in the returned list satisfies:
        exists a rental r where r.customer == customer,
        r.backDate == null, and currentDate > r.dueDate.
  - No customer appears more than once in the returned list., org.eclipse.emf.ecore.impl.EOperationImpl@362fd4e9 (name: calculateTotalRevenue) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Calculates the total revenue generated by all completed rentals in the store.
  Only rentals with a non‑null `totalPrice` are considered (i.e., rentals that have been
  returned or otherwise finalized).
Algorithm:
  1. Initialize `totalRevenue` to 0.0.
  2. For each `rental` in `this.rentals`:
       a. If `rental.totalPrice` is not null (or > 0), add it to `totalRevenue`.
  3. Return `totalRevenue`.
Input:
  None.
Output:
  double – the sum of `totalPrice` of all rentals that have a defined price.
  Returns 0.0 if there are no such rentals.
Pre-condition:
  - `this.rentals` is non‑null; each `Rental` has a numeric `totalPrice`
    (0.0 for rentals that have not yet been priced).
Post-condition:
  - The returned value equals the aggregate revenue from all rentals that have been billed., org.eclipse.emf.ecore.impl.EOperationImpl@106f2425 (name: identifyAvailableCars) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary:
  Returns a list of all cars that are not currently rented, sorted by their daily rental price
  in ascending order. If every car is rented or the store has no cars, an empty list is returned.
Algorithm:
  1. Initialize an empty list `availableCars`.
  2. For each `car` in `this.cars`:
       a. Check if there exists a `rental` in `this.rentals` such that
          `rental.car.plate == car.plate` and `rental.backDate == null`.
       b. If no such rental exists, add `car` to `availableCars`.
  3. Sort `availableCars` by `car.dailyPrice` using ascending numeric order.
  4. Return `availableCars`.
Input:
  None.
Output:
  List<Car> – a list containing the available `Car` objects sorted by `dailyPrice`.
  The list may be empty.
Pre-condition:
  - `this.cars` and `this.rentals` are properly initialized (non‑null).
Post-condition:
  - The returned list contains exactly those cars that have no active rental
    (`backDate` is null) at the time of the call.
  - The list is ordered so that for any consecutive elements `c1, c2`:
      `c1.dailyPrice <= c2.dailyPrice`., org.eclipse.emf.ecore.impl.EOperationImpl@1299c874 (name: countCarsRentedPerCustomer) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary:
  Produces a mapping that indicates how many cars each customer has rented (including both
  active and completed rentals). Customers with zero rentals are omitted from the map.
Algorithm:
  1. Initialize an empty map `rentalCountMap` where key = Customer, value = Integer.
  2. For each `rental` in `this.rentals`:
       a. Let `cust` = `rental.customer`.
       b. If `rentalCountMap` already contains `cust`,
             increment the associated integer by 1;
          else,
             insert `cust` with value 1.
  3. Convert `rentalCountMap` to a List<EMap> (each entry rendered as an EMap
     containing keys "customer" and "count").
  4. Return the list (may be empty).
Input:
  None.
Output:
  List<EMap> – each `EMap` entry holds:
       - key "customer" → Customer object
       - key "count"    → Integer (number of rentals for that customer)
  The list is empty when `this.rentals` contains no entries.
Pre-condition:
  - `this.rentals` is non‑null; each `Rental` references a valid `Customer`.
Post-condition:
  - For every customer appearing in the result list,
        the associated count equals the total number of rentals (active or finished)
        belonging to that customer.
  - No customer with zero rentals appears in the result.}
132566 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
132590 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../RCGS/src-gen/edu/carrental
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.carrental;

import java.util.Collection;
import java.util.Date;
import java.util.Map;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Store</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.carrental.Store#getCars <em>Cars</em>}</li>
 *   <li>{@link edu.carrental.Store#getRentals <em>Rentals</em>}</li>
 *   <li>{@link edu.carrental.Store#getNotices <em>Notices</em>}</li>
 * </ul>
 *
 * @see edu.carrental.CarrentalPackage#getStore()
 * @model kind="class"
 * @generated
 */
public class Store extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Car> cars;

  protected EList<Rental> rentals;

  protected EList<OverdueNotice> notices;

  protected Store()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Car> getCars()
  { ... /* omitted */ }

  public EList<Rental> getRentals()
  { ... /* omitted */ }

  public EList<OverdueNotice> getNotices()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns a list of all cars that are not currently rented, sorted by their daily rental price
   *   in ascending order. If every car is rented or the store has no cars, an empty list is returned.
   * Algorithm:
   *   1. Initialize an empty list `availableCars`.
   *   2. For each `car` in `this.cars`:
   *        a. Check if there exists a `rental` in `this.rentals` such that
   *           `rental.car.plate == car.plate` and `rental.backDate == null`.
   *        b. If no such rental exists, add `car` to `availableCars`.
   *   3. Sort `availableCars` by `car.dailyPrice` using ascending numeric order.
   *   4. Return `availableCars`.
   * Input:
   *   None.
   * Output:
   *   List<Car> – a list containing the available `Car` objects sorted by `dailyPrice`.
   *   The list may be empty.
   * Pre-condition:
   *   - `this.cars` and `this.rentals` are properly initialized (non‑null).
   * Post-condition:
   *   - The returned list contains exactly those cars that have no active rental
   *     (`backDate` is null) at the time of the call.
   *   - The list is ordered so that for any consecutive elements `c1, c2`:
   *       `c1.dailyPrice <= c2.dailyPrice`.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<Car> identifyAvailableCars()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Calculates the total revenue generated by all completed rentals in the store.
   *   Only rentals with a non‑null `totalPrice` are considered (i.e., rentals that have been
   *   returned or otherwise finalized).
   * Algorithm:
   *   1. Initialize `totalRevenue` to 0.0.
   *   2. For each `rental` in `this.rentals`:
   *        a. If `rental.totalPrice` is not null (or > 0), add it to `totalRevenue`.
   *   3. Return `totalRevenue`.
   * Input:
   *   None.
   * Output:
   *   double – the sum of `totalPrice` of all rentals that have a defined price.
   *   Returns 0.0 if there are no such rentals.
   * Pre-condition:
   *   - `this.rentals` is non‑null; each `Rental` has a numeric `totalPrice`
   *     (0.0 for rentals that have not yet been priced).
   * Post-condition:
   *   - The returned value equals the aggregate revenue from all rentals that have been billed.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateTotalRevenue()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves a list of customers whose rentals are overdue as of the supplied `currentDate`.
   *   A rental is overdue when its `backDate` is null (car not yet returned) and `currentDate`
   *   is later than the rental's `dueDate`.
   * Algorithm:
   *   1. Validate that `currentDate` is not null.
   *   2. Initialize an empty set `overdueCustomers` (to avoid duplicates).
   *   3. For each `rental` in `this.rentals`:
   *        a. If `rental.backDate == null` AND `currentDate > rental.dueDate`:
   *              add `rental.customer` to `overdueCustomers`.
   *   4. Convert `overdueCustomers` to a List<Customer> preserving insertion order.
   *   5. Return the list (may be empty).
   * Input:
   *   - currentDate : EDate
   *       * Meaning: the date against which overdue status is evaluated.
   *       * Format: ISO‑8601 date string "yyyy-MM-dd" (e.g., "2025-11-14").
   * Output:
   *   List<Customer> – a list of distinct customers with at least one overdue rental.
   *   The list may be empty if no overdues exist.
   * Pre-condition:
   *   - `currentDate` is a valid, non‑null `EDate`.
   *   - `this.rentals` and each `Rental`'s `dueDate` are properly set.
   * Post-condition:
   *   - Every customer in the returned list satisfies:
   *         exists a rental r where r.customer == customer,
   *         r.backDate == null, and currentDate > r.dueDate.
   *   - No customer appears more than once in the returned list.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<Customer> findCustomersWithOverdueRentals(final Date currentDate)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes the average daily rental price of all cars stored in the gallery.
   *   If the store has no cars, the function returns 0.0.
   * Algorithm:
   *   1. If `this.cars` is empty, return 0.0.
   *   2. Initialize `sumPrice` to 0.0.
   *   3. For each `car` in `this.cars`, add `car.dailyPrice` to `sumPrice`.
   *   4. Compute `average = sumPrice / this.cars.size()`.
   *   5. Return `average`.
   * Input:
   *   None.
   * Output:
   *   double – the arithmetic mean of `dailyPrice` across all cars.
   *   Returns 0.0 when `this.cars` is empty.
   * Pre-condition:
   *   - `this.cars` is non‑null; each `Car` object has a valid `dailyPrice` (>= 0).
   * Post-condition:
   *   - The returned value equals the sum of all daily prices divided by the number of cars,
   *     or 0.0 if there are no cars.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double determineAverageDailyPrice()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Produces a mapping that indicates how many cars each customer has rented (including both
   *   active and completed rentals). Customers with zero rentals are omitted from the map.
   * Algorithm:
   *   1. Initialize an empty map `rentalCountMap` where key = Customer, value = Integer.
   *   2. For each `rental` in `this.rentals`:
   *        a. Let `cust` = `rental.customer`.
   *        b. If `rentalCountMap` already contains `cust`,
   *              increment the associated integer by 1;
   *           else,
   *              insert `cust` with value 1.
   *   3. Convert `rentalCountMap` to a List<EMap> (each entry rendered as an EMap
   *      containing keys "customer" and "count").
   *   4. Return the list (may be empty).
   * Input:
   *   None.
   * Output:
   *   List<EMap> – each `EMap` entry holds:
   *        - key "customer" → Customer object
   *        - key "count"    → Integer (number of rentals for that customer)
   *   The list is empty when `this.rentals` contains no entries.
   * Pre-condition:
   *   - `this.rentals` is non‑null; each `Rental` references a valid `Customer`.
   * Post-condition:
   *   - For every customer appearing in the result list,
   *         the associated count equals the total number of rentals (active or finished)
   *         belonging to that customer.
   *   - No customer with zero rentals appears in the result.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<Map<Customer, Integer>> countCarsRentedPerCustomer()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Store
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Car` contains the following methods.
  + Instance creation: Use `CarrentalFactory.eINSTANCE.createCar()`
  + Getter methods: public String getPlate(), public String getModel(), public double getDailyPrice()
  + Setter methods: public void setPlate(String newPlate), public void setModel(String newModel), public void setDailyPrice(double newDailyPrice)
- Class `Rental` contains the following methods.
  + Instance creation: Use `CarrentalFactory.eINSTANCE.createRental()`
  + Getter methods: public String getLeasingTerms(), public double getTotalPrice(), public Date getRentalDate(), public Date getDueDate(), public Date getBackDate(), public Car getCar(), public Customer getCustomer()
  + Setter methods: public void setLeasingTerms(String newLeasingTerms), public void setTotalPrice(double newTotalPrice), public void setRentalDate(Date newRentalDate), public void setDueDate(Date newDueDate), public void setBackDate(Date newBackDate), public void setCar(Car newCar), public void setCustomer(Customer newCustomer)
- Class `OverdueNotice` contains the following methods.
  + Instance creation: Use `CarrentalFactory.eINSTANCE.createOverdueNotice()`
  + Getter methods: public Customer getCustomer()
  + Setter methods: public void setCustomer(Customer newCustomer)
- Class `Customer` contains the following methods.
  + Instance creation: Use `CarrentalFactory.eINSTANCE.createCustomer()`
  + Getter methods: public String getName(), public String getSurname(), public String getAddress(), public String getRentedCarPlate()
  + Setter methods: public void setName(String newName), public void setSurname(String newSurname), public void setAddress(String newAddress), public void setRentedCarPlate(String newRentedCarPlate)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.carrental;

import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Store</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.carrental.Store#getCars <em>Cars</em>}</li>
 *   <li>{@link edu.carrental.Store#getRentals <em>Rentals</em>}</li>
 *   <li>{@link edu.carrental.Store#getNotices <em>Notices</em>}</li>
 * </ul>
 *
 * @see edu.carrental.CarrentalPackage#getStore()
 * @model kind="class"
 * @generated
 */
public class Store extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Car> cars;

  protected EList<Rental> rentals;

  protected EList<OverdueNotice> notices;

  protected Store()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Car> getCars()
  { ... /* omitted */ }

  public EList<Rental> getRentals()
  { ... /* omitted */ }

  public EList<OverdueNotice> getNotices()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns a list of all cars that are not currently rented, sorted by their daily rental price
   *   in ascending order. If every car is rented or the store has no cars, an empty list is returned.
   * Algorithm:
   *   1. Initialize an empty list `availableCars`.
   *   2. For each `car` in `this.cars`:
   *        a. Check if there exists a `rental` in `this.rentals` such that
   *           `rental.car.plate == car.plate` and `rental.backDate == null`.
   *        b. If no such rental exists, add `car` to `availableCars`.
   *   3. Sort `availableCars` by `car.dailyPrice` using ascending numeric order.
   *   4. Return `availableCars`.
   * Input:
   *   None.
   * Output:
   *   List<Car> – a list containing the available `Car` objects sorted by `dailyPrice`.
   *   The list may be empty.
   * Pre-condition:
   *   - `this.cars` and `this.rentals` are properly initialized (non‑null).
   * Post-condition:
   *   - The returned list contains exactly those cars that have no active rental
   *     (`backDate` is null) at the time of the call.
   *   - The list is ordered so that for any consecutive elements `c1, c2`:
   *       `c1.dailyPrice <= c2.dailyPrice`.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Car> identifyAvailableCars()
  {
    // 1. Initialize an empty list `availableCars`.
    BasicEList<Car> availableCars = new BasicEList<>();

    // 2. For each car, check whether it is currently rented.
    for (Car car : getCars()) {
      boolean rented = false;
      for (Rental rental : getRentals()) {
        Car rentedCar = rental.getCar();
        if (rentedCar != null
            && rentedCar.getPlate().equals(car.getPlate())
            && rental.getBackDate() == null) {
          rented = true;
          break;
        }
      }
      if (!rented) {
        availableCars.add(car);
      }
    }

    // 3. Sort the list by dailyPrice ascending.
    Collections.sort(availableCars, Comparator.comparingDouble(Car::getDailyPrice));

    // 4. Return the result.
    return availableCars;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Calculates the total revenue generated by all completed rentals in the store.
   *   Only rentals with a non‑null `totalPrice` are considered (i.e., rentals that have been
   *   returned or otherwise finalized).
   * Algorithm:
   *   1. Initialize `totalRevenue` to 0.0.
   *   2. For each `rental` in `this.rentals`:
   *        a. If `rental.totalPrice` is not null (or > 0), add it to `totalRevenue`.
   *   3. Return `totalRevenue`.
   * Input:
   *   None.
   * Output:
   *   double – the sum of `totalPrice` of all rentals that have a defined price.
   *   Returns 0.0 if there are no such rentals.
   * Pre-condition:
   *   - `this.rentals` is non‑null; each `Rental` has a numeric `totalPrice`
   *     (0.0 for rentals that have not yet been priced).
   * Post-condition:
   *   - The returned value equals the aggregate revenue from all rentals that have been billed.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateTotalRevenue()
  {
    double totalRevenue = 0.0;
    for (Rental rental : getRentals()) {
      double price = rental.getTotalPrice();
      if (price > 0.0) {
        totalRevenue += price;
      }
    }
    return totalRevenue;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves a list of customers whose rentals are overdue as of the supplied `currentDate`.
   *   A rental is overdue when its `backDate` is null (car not yet returned) and `currentDate`
   *   is later than the rental's `dueDate`.
   * Algorithm:
   *   1. Validate that `currentDate` is not null.
   *   2. Initialize an empty set `overdueCustomers` (to avoid duplicates).
   *   3. For each `rental` in `this.rentals`:
   *        a. If `rental.backDate == null` AND `currentDate > rental.dueDate`:
   *              add `rental.customer` to `overdueCustomers`.
   *   4. Convert `overdueCustomers` to a List<Customer> preserving insertion order.
   *   5. Return the list (may be empty).
   * Input:
   *   - currentDate : EDate
   *       * Meaning: the date against which overdue status is evaluated.
   *       * Format: ISO‑8601 date string "yyyy-MM-dd" (e.g., "2025-11-14").
   * Output:
   *   List<Customer> – a list of distinct customers with at least one overdue rental.
   *   The list may be empty if no overdues exist.
   * Pre-condition:
   *   - `currentDate` is a valid, non‑null `EDate`.
   *   - `this.rentals` and each `Rental`'s `dueDate` are properly set.
   * Post-condition:
   *   - Every customer in the returned list satisfies:
   *         exists a rental r where r.customer == customer,
   *         r.backDate == null, and currentDate > r.dueDate.
   *   - No customer appears more than once in the returned list.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Customer> findCustomersWithOverdueRentals(final Date currentDate)
  {
    if (currentDate == null) {
      throw new IllegalArgumentException("currentDate must not be null");
    }

    Set<Customer> overdueCustomers = new LinkedHashSet<>();
    for (Rental rental : getRentals()) {
      if (rental.getBackDate() == null && currentDate.after(rental.getDueDate())) {
        Customer cust = rental.getCustomer();
        if (cust != null) {
          overdueCustomers.add(cust);
        }
      }
    }

    BasicEList<Customer> result = new BasicEList<>();
    result.addAll(overdueCustomers);
    return result;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes the average daily rental price of all cars stored in the gallery.
   *   If the store has no cars, the function returns 0.0.
   * Algorithm:
   *   1. If `this.cars` is empty, return 0.0.
   *   2. Initialize `sumPrice` to 0.0.
   *   3. For each `car` in `this.cars`, add `car.dailyPrice` to `sumPrice`.
   *   4. Compute `average = sumPrice / this.cars.size()`.
   *   5. Return `average`.
   * Input:
   *   None.
   * Output:
   *   double – the arithmetic mean of `dailyPrice` across all cars.
   *   Returns 0.0 when `this.cars` is empty.
   * Pre-condition:
   *   - `this.cars` is non‑null; each `Car` object has a valid `dailyPrice` (>= 0).
   * Post-condition:
   *   - The returned value equals the sum of all daily prices divided by the number of cars,
   *     or 0.0 if there are no cars.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double determineAverageDailyPrice()
  {
    if (getCars().isEmpty()) {
      return 0.0;
    }

    double sumPrice = 0.0;
    for (Car car : getCars()) {
      sumPrice += car.getDailyPrice();
    }
    return sumPrice / getCars().size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Produces a mapping that indicates how many cars each customer has rented (including both
   *   active and completed rentals). Customers with zero rentals are omitted from the map.
   * Algorithm:
   *   1. Initialize an empty map `rentalCountMap` where key = Customer, value = Integer.
   *   2. For each `rental` in `this.rentals`:
   *        a. Let `cust` = `rental.customer`.
   *        b. If `rentalCountMap` already contains `cust`,
   *              increment the associated integer by 1;
   *           else,
   *              insert `cust` with value 1.
   *   3. Convert `rentalCountMap` to a List<EMap> (each entry rendered as an EMap
   *      containing keys "customer" and "count").
   *   4. Return the list (may be empty).
   * Input:
   *   None.
   * Output:
   *   List<EMap> – each `EMap` entry holds:
   *        - key "customer" → Customer object
   *        - key "count"    → Integer (number of rentals for that customer)
   *   The list is empty when `this.rentals` contains no entries.
   * Pre-condition:
   *   - `this.rentals` is non‑null; each `Rental` references a valid `Customer`.
   * Post-condition:
   *   - For every customer appearing in the result list,
   *         the associated count equals the total number of rentals (active or finished)
   *         belonging to that customer.
   *   - No customer with zero rentals appears in the result.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Map<Customer, Integer>> countCarsRentedPerCustomer()
  {
    Map<Customer, Integer> rentalCountMap = new HashMap<>();

    for (Rental rental : getRentals()) {
      Customer cust = rental.getCustomer();
      if (cust != null) {
        rentalCountMap.merge(cust, 1, Integer::sum);
      }
    }

    BasicEList<Map<Customer, Integer>> result = new BasicEList<>();
    for (Map.Entry<Customer, Integer> entry : rentalCountMap.entrySet()) {
      Map<Customer, Integer> map = new HashMap<>();
      map.put(entry.getKey(), entry.getValue());
      result.add(map);
    }

    return result;
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Store
156179 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../RCGS/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../RCGS/src-gen/edu/carrental/
156297 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
156297 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
156297 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
156297 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
156298 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample4.mwe2 启动完成
正在拷贝 src-gen/edu/carrental 到 gpt-oss-120b/carrental4...
拷贝完成！

======================================
正在启动 sample5.mwe2...
======================================
156519 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
156586 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project RCGS at 'file:/D:/EclipseWorkspace/RCGS/'
156589 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
156596 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@4b8ac512
156596 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
156597 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
156598 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
Store assistants should store the information for each car in the gallery, such as plate, model, and daily price. 
When customers want to rent a car, the system must show available car records in the gallery and be sorted according to their prices. The system lists the rented car records when the store assistant person enters the related button. Store assistant searches for available cars, submit renting a car, and produces rental reports. The store assistant updates the rental list when he rents a car or takes back a car. The main office sends overdue notices due to late arrivals.
 The store assistant records the customer's information, such as name, surname, address, plate of the rented car, and leasing terms.
Function Requirement:
+ Identify available cars in the store. A car is available if it is not currently rented. Return a list of available cars, sorted by daily price in ascending order. If no available cars exist, return an empty list.

+ Calculate the total revenue generated by all rentals in the store.

+ List customers with overdue rentals. For each rental, if the back date is null and the current date is past the due date (format: yyyy-MM-dd), mark it as overdue. Return an empty list if no overdue customers exist.

+ Determine the average daily price of cars in the store: sum the daily prices of all cars and divide by the total number of cars. If the store has no cars, return 0.0.

+ Count the number of cars rented per customer. Return a map of customers and their respective rental counts, or an empty map if no customers have rented cars.
```

# Class Diagram
```plantuml
@startuml

title carrental Model

class Car {
    dailyPrice : double
    model : String
    plate : String
}
class Customer {
    address : String
    name : String
    rentedCarPlate : String
    surname : String
}
class OverdueNotice {
    customer : Customer
}
class Rental {
    backDate : EDate
    dueDate : EDate
    leasingTerms : String
    rentalDate : EDate
    totalPrice : double
    car : Car
    customer : Customer
}
class Store {
    cars : List<Car>
    notices : List<OverdueNotice>
    rentals : List<Rental>
    calculateTotalRevenue() : double
    countCarsRentedPerCustomer() : List<EMap>
    determineAverageDailyPrice() : double
    findCustomersWithOverdueRentals(currentDate : EDate) : List<Customer>
    identifyAvailableCars() : List<Car>
}

OverdueNotice --> Customer : customer
Rental --> Car : car
Rental --> Customer : customer
Store *-- "*" Car : cars
Store *-- "*" OverdueNotice : notices
Store *-- "*" Rental : rentals
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

171911 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@507187c1 (name: identifyAvailableCars) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary:
  Returns all cars in the gallery that are not currently rented, sorted by their daily
  rental price in ascending order.
Algorithm:
  1. Create an empty list `availableCars`.
  2. For each `car` in `this.cars`:
       a. Search `this.rentals` for a Rental whose `car.plate` equals `car.plate`
          and whose `backDate` is null (i.e., the car is still out).
       b. If no such Rental exists, add `car` to `availableCars`.
  3. Sort `availableCars` by `dailyPrice` using an ascending comparator.
  4. Return `availableCars`.
Input:
  None.
Output:
  List<Car> – a list of Car objects that are currently not rented.
  The list is sorted by `dailyPrice` (lowest first). If no cars are available,
  an empty list is returned.
Pre‑condition:
  The Store instance must have its `cars` and `rentals` collections initialized
  (non‑null). Each Car must have a unique `plate`.
Post‑condition:
  The returned list contains exactly those cars from `this.cars` that have no
  active Rental (i.e., Rental.backDate == null). The original collections are
  unchanged., org.eclipse.emf.ecore.impl.EOperationImpl@5bb90b89 (name: determineAverageDailyPrice) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Calculates the average daily rental price of all cars stored in the gallery.
Algorithm:
  1. If `this.cars` is empty, return 0.0.
  2. Initialise `sumPrice` to 0.0.
  3. For each `car` in `this.cars`, add `car.dailyPrice` to `sumPrice`.
  4. Compute `average = sumPrice / this.cars.size()`.
  5. Return `average`.
Input:
  None.
Output:
  double – arithmetic mean of `dailyPrice` values of all cars.
  Returns 0.0 when the store has no cars.
Pre‑condition:
  `this.cars` is non‑null; each Car’s `dailyPrice` is a non‑negative double.
Post‑condition:
  No side‑effects; the returned value represents the average daily price at the
  moment of invocation., org.eclipse.emf.ecore.impl.EOperationImpl@4c231f62 (name: countCarsRentedPerCustomer) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary:
  Counts how many cars each customer has rented (including both active and completed rentals)
  and returns the result as a collection of key‑value pairs.
Algorithm:
  1. Initialise an empty map `counterMap` where key = Customer, value = Integer.
  2. For each `rental` in `this.rentals`:
       a. Let `cust` = `rental.customer`.
       b. If `counterMap` already contains `cust`, increment its value by 1;
          otherwise insert `cust` with value 1.
  3. Convert `counterMap` to a list of map entries (`EMap`) preserving the pairing.
  4. Return the list.
Input:
  None.
Output:
  List<EMap> – each entry contains:
       key   : Customer – the customer object.
       value : Integer   – the total number of rentals associated with that customer.
  Returns an empty list when there are no rentals.
Pre‑condition:
  `this.rentals` is non‑null; each Rental has a non‑null `customer`.
Post‑condition:
  The returned collection reflects the exact count of rentals per customer at the
  time of the call. No changes are made to the Store’s internal collections., org.eclipse.emf.ecore.impl.EOperationImpl@2220c5f7 (name: calculateTotalRevenue) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Computes the total amount of money earned from all completed rentals in the store.
Algorithm:
  1. Initialise `totalRevenue` to 0.0.
  2. For each `rental` in `this.rentals`:
       a. If `rental.backDate` is not null (rental finished), add `rental.totalPrice`
          to `totalRevenue`.
  3. Return `totalRevenue`.
Input:
  None.
Output:
  double – the sum of `totalPrice` of all rentals that have been returned.
  If there are no completed rentals, the result is 0.0.
Pre‑condition:
  `this.rentals` is non‑null. Each Rental’s `totalPrice` must be a non‑negative double.
Post‑condition:
  No modification of any Store data; `totalRevenue` reflects the revenue from
  all rentals with a non‑null `backDate`., org.eclipse.emf.ecore.impl.EOperationImpl@10b0dd3a (name: findCustomersWithOverdueRentals) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary:
  Retrieves a list of customers whose rentals are overdue as of the supplied current date.
Algorithm:
  1. Initialise an empty list `overdueCustomers`.
  2. For each `rental` in `this.rentals`:
       a. If `rental.backDate` is null (car not yet returned) AND
          `rental.dueDate` is before `currentDate` (i.e., currentDate > dueDate):
             i. Add `rental.customer` to `overdueCustomers` if not already present.
  3. Return `overdueCustomers`.
Input:
  currentDate : EDate – the date against which overdue status is evaluated.
  Format: "yyyy-MM-dd". The value must be a valid calendar date.
Output:
  List<Customer> – each element is a distinct Customer with at least one overdue rental.
  Returns an empty list if no overdue rentals exist.
Pre‑condition:
  `this.rentals` is non‑null; `currentDate` is a valid EDate object.
Post‑condition:
  The returned list contains no duplicate Customer objects.
  No Store data is modified.}
171913 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
171933 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../RCGS/src-gen/edu/carrental
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.carrental;

import java.util.Collection;
import java.util.Date;
import java.util.Map;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Store</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.carrental.Store#getCars <em>Cars</em>}</li>
 *   <li>{@link edu.carrental.Store#getRentals <em>Rentals</em>}</li>
 *   <li>{@link edu.carrental.Store#getNotices <em>Notices</em>}</li>
 * </ul>
 *
 * @see edu.carrental.CarrentalPackage#getStore()
 * @model kind="class"
 * @generated
 */
public class Store extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Car> cars;

  protected EList<Rental> rentals;

  protected EList<OverdueNotice> notices;

  protected Store()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Car> getCars()
  { ... /* omitted */ }

  public EList<Rental> getRentals()
  { ... /* omitted */ }

  public EList<OverdueNotice> getNotices()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns all cars in the gallery that are not currently rented, sorted by their daily
   *   rental price in ascending order.
   * Algorithm:
   *   1. Create an empty list `availableCars`.
   *   2. For each `car` in `this.cars`:
   *        a. Search `this.rentals` for a Rental whose `car.plate` equals `car.plate`
   *           and whose `backDate` is null (i.e., the car is still out).
   *        b. If no such Rental exists, add `car` to `availableCars`.
   *   3. Sort `availableCars` by `dailyPrice` using an ascending comparator.
   *   4. Return `availableCars`.
   * Input:
   *   None.
   * Output:
   *   List<Car> – a list of Car objects that are currently not rented.
   *   The list is sorted by `dailyPrice` (lowest first). If no cars are available,
   *   an empty list is returned.
   * Pre‑condition:
   *   The Store instance must have its `cars` and `rentals` collections initialized
   *   (non‑null). Each Car must have a unique `plate`.
   * Post‑condition:
   *   The returned list contains exactly those cars from `this.cars` that have no
   *   active Rental (i.e., Rental.backDate == null). The original collections are
   *   unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<Car> identifyAvailableCars()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes the total amount of money earned from all completed rentals in the store.
   * Algorithm:
   *   1. Initialise `totalRevenue` to 0.0.
   *   2. For each `rental` in `this.rentals`:
   *        a. If `rental.backDate` is not null (rental finished), add `rental.totalPrice`
   *           to `totalRevenue`.
   *   3. Return `totalRevenue`.
   * Input:
   *   None.
   * Output:
   *   double – the sum of `totalPrice` of all rentals that have been returned.
   *   If there are no completed rentals, the result is 0.0.
   * Pre‑condition:
   *   `this.rentals` is non‑null. Each Rental’s `totalPrice` must be a non‑negative double.
   * Post‑condition:
   *   No modification of any Store data; `totalRevenue` reflects the revenue from
   *   all rentals with a non‑null `backDate`.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateTotalRevenue()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves a list of customers whose rentals are overdue as of the supplied current date.
   * Algorithm:
   *   1. Initialise an empty list `overdueCustomers`.
   *   2. For each `rental` in `this.rentals`:
   *        a. If `rental.backDate` is null (car not yet returned) AND
   *           `rental.dueDate` is before `currentDate` (i.e., currentDate > dueDate):
   *              i. Add `rental.customer` to `overdueCustomers` if not already present.
   *   3. Return `overdueCustomers`.
   * Input:
   *   currentDate : EDate – the date against which overdue status is evaluated.
   *   Format: "yyyy-MM-dd". The value must be a valid calendar date.
   * Output:
   *   List<Customer> – each element is a distinct Customer with at least one overdue rental.
   *   Returns an empty list if no overdue rentals exist.
   * Pre‑condition:
   *   `this.rentals` is non‑null; `currentDate` is a valid EDate object.
   * Post‑condition:
   *   The returned list contains no duplicate Customer objects.
   *   No Store data is modified.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<Customer> findCustomersWithOverdueRentals(final Date currentDate)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Calculates the average daily rental price of all cars stored in the gallery.
   * Algorithm:
   *   1. If `this.cars` is empty, return 0.0.
   *   2. Initialise `sumPrice` to 0.0.
   *   3. For each `car` in `this.cars`, add `car.dailyPrice` to `sumPrice`.
   *   4. Compute `average = sumPrice / this.cars.size()`.
   *   5. Return `average`.
   * Input:
   *   None.
   * Output:
   *   double – arithmetic mean of `dailyPrice` values of all cars.
   *   Returns 0.0 when the store has no cars.
   * Pre‑condition:
   *   `this.cars` is non‑null; each Car’s `dailyPrice` is a non‑negative double.
   * Post‑condition:
   *   No side‑effects; the returned value represents the average daily price at the
   *   moment of invocation.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double determineAverageDailyPrice()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Counts how many cars each customer has rented (including both active and completed rentals)
   *   and returns the result as a collection of key‑value pairs.
   * Algorithm:
   *   1. Initialise an empty map `counterMap` where key = Customer, value = Integer.
   *   2. For each `rental` in `this.rentals`:
   *        a. Let `cust` = `rental.customer`.
   *        b. If `counterMap` already contains `cust`, increment its value by 1;
   *           otherwise insert `cust` with value 1.
   *   3. Convert `counterMap` to a list of map entries (`EMap`) preserving the pairing.
   *   4. Return the list.
   * Input:
   *   None.
   * Output:
   *   List<EMap> – each entry contains:
   *        key   : Customer – the customer object.
   *        value : Integer   – the total number of rentals associated with that customer.
   *   Returns an empty list when there are no rentals.
   * Pre‑condition:
   *   `this.rentals` is non‑null; each Rental has a non‑null `customer`.
   * Post‑condition:
   *   The returned collection reflects the exact count of rentals per customer at the
   *   time of the call. No changes are made to the Store’s internal collections.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<Map<Customer, Integer>> countCarsRentedPerCustomer()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Store
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Car` contains the following methods.
  + Instance creation: Use `CarrentalFactory.eINSTANCE.createCar()`
  + Getter methods: public String getPlate(), public String getModel(), public double getDailyPrice()
  + Setter methods: public void setPlate(String newPlate), public void setModel(String newModel), public void setDailyPrice(double newDailyPrice)
- Class `Rental` contains the following methods.
  + Instance creation: Use `CarrentalFactory.eINSTANCE.createRental()`
  + Getter methods: public String getLeasingTerms(), public double getTotalPrice(), public Date getRentalDate(), public Date getDueDate(), public Date getBackDate(), public Car getCar(), public Customer getCustomer()
  + Setter methods: public void setLeasingTerms(String newLeasingTerms), public void setTotalPrice(double newTotalPrice), public void setRentalDate(Date newRentalDate), public void setDueDate(Date newDueDate), public void setBackDate(Date newBackDate), public void setCar(Car newCar), public void setCustomer(Customer newCustomer)
- Class `OverdueNotice` contains the following methods.
  + Instance creation: Use `CarrentalFactory.eINSTANCE.createOverdueNotice()`
  + Getter methods: public Customer getCustomer()
  + Setter methods: public void setCustomer(Customer newCustomer)
- Class `Customer` contains the following methods.
  + Instance creation: Use `CarrentalFactory.eINSTANCE.createCustomer()`
  + Getter methods: public String getName(), public String getSurname(), public String getAddress(), public String getRentedCarPlate()
  + Setter methods: public void setName(String newName), public void setSurname(String newSurname), public void setAddress(String newAddress), public void setRentedCarPlate(String newRentedCarPlate)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.carrental;

import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Store</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.carrental.Store#getCars <em>Cars</em>}</li>
 *   <li>{@link edu.carrental.Store#getRentals <em>Rentals</em>}</li>
 *   <li>{@link edu.carrental.Store#getNotices <em>Notices</em>}</li>
 * </ul>
 *
 * @see edu.carrental.CarrentalPackage#getStore()
 * @model kind="class"
 * @generated
 */
public class Store extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Car> cars;

  protected EList<Rental> rentals;

  protected EList<OverdueNotice> notices;

  protected Store()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Car> getCars()
  { ... /* omitted */ }

  public EList<Rental> getRentals()
  { ... /* omitted */ }

  public EList<OverdueNotice> getNotices()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns all cars in the gallery that are not currently rented, sorted by their daily
   *   rental price in ascending order.
   * Algorithm:
   *   1. Create an empty list `availableCars`.
   *   2. For each `car` in `this.cars`:
   *        a. Search `this.rentals` for a Rental whose `car.plate` equals `car.plate`
   *           and whose `backDate` is null (i.e., the car is still out).
   *        b. If no such Rental exists, add `car` to `availableCars`.
   *   3. Sort `availableCars` by `dailyPrice` using an ascending comparator.
   *   4. Return `availableCars`.
   * Input:
   *   None.
   * Output:
   *   List<Car> – a list of Car objects that are currently not rented.
   *   The list is sorted by `dailyPrice` (lowest first). If no cars are available,
   *   an empty list is returned.
   * Pre‑condition:
   *   The Store instance must have its `cars` and `rentals` collections initialized
   *   (non‑null). Each Car must have a unique `plate`.
   * Post‑condition:
   *   The returned list contains exactly those cars from `this.cars` that have no
   *   active Rental (i.e., Rental.backDate == null). The original collections are
   *   unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Car> identifyAvailableCars()
  {
    // 1. Create an empty list `availableCars`.
    EList<Car> availableCars = new BasicEList<>();

    // 2. For each `car` in `this.cars`:
    for (Car car : this.cars) {
      boolean rented = false;
      // a. Search `this.rentals` for a Rental whose `car.plate` equals `car.plate`
      //    and whose `backDate` is null.
      for (Rental rental : this.rentals) {
        Car rentedCar = rental.getCar();
        if (rentedCar != null
            && rentedCar.getPlate() != null
            && rentedCar.getPlate().equals(car.getPlate())
            && rental.getBackDate() == null) {
          rented = true;
          break;
        }
      }
      // b. If no such Rental exists, add `car` to `availableCars`.
      if (!rented) {
        availableCars.add(car);
      }
    }

    // 3. Sort `availableCars` by `dailyPrice` using an ascending comparator.
    Collections.sort(availableCars, Comparator.comparingDouble(Car::getDailyPrice));

    // 4. Return `availableCars`.
    return availableCars;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes the total amount of money earned from all completed rentals in the store.
   * Algorithm:
   *   1. Initialise `totalRevenue` to 0.0.
   *   2. For each `rental` in `this.rentals`:
   *        a. If `rental.backDate` is not null (rental finished), add `rental.totalPrice`
   *           to `totalRevenue`.
   *   3. Return `totalRevenue`.
   * Input:
   *   None.
   * Output:
   *   double – the sum of `totalPrice` of all rentals that have been returned.
   *   If there are no completed rentals, the result is 0.0.
   * Pre‑condition:
   *   `this.rentals` is non‑null. Each Rental’s `totalPrice` must be a non‑negative double.
   * Post‑condition:
   *   No modification of any Store data; `totalRevenue` reflects the revenue from
   *   all rentals with a non‑null `backDate`.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateTotalRevenue()
  {
    double totalRevenue = 0.0;

    for (Rental rental : this.rentals) {
      if (rental.getBackDate() != null) {
        totalRevenue += rental.getTotalPrice();
      }
    }

    return totalRevenue;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves a list of customers whose rentals are overdue as of the supplied current date.
   * Algorithm:
   *   1. Initialise an empty list `overdueCustomers`.
   *   2. For each `rental` in `this.rentals`:
   *        a. If `rental.backDate` is null (car not yet returned) AND
   *           `rental.dueDate` is before `currentDate` (i.e., currentDate > dueDate):
   *              i. Add `rental.customer` to `overdueCustomers` if not already present.
   *   3. Return `overdueCustomers`.
   * Input:
   *   currentDate : EDate – the date against which overdue status is evaluated.
   *   Format: "yyyy-MM-dd". The value must be a valid calendar date.
   * Output:
   *   List<Customer> – each element is a distinct Customer with at least one overdue rental.
   *   Returns an empty list if no overdue rentals exist.
   * Pre‑condition:
   *   `this.rentals` is non‑null; `currentDate` is a valid EDate object.
   * Post‑condition:
   *   The returned list contains no duplicate Customer objects.
   *   No Store data is modified.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Customer> findCustomersWithOverdueRentals(final Date currentDate)
  {
    EList<Customer> overdueCustomers = new BasicEList<>();

    for (Rental rental : this.rentals) {
      if (rental.getBackDate() == null) {
        Date dueDate = rental.getDueDate();
        if (dueDate != null && dueDate.before(currentDate)) {
          Customer cust = rental.getCustomer();
          if (cust != null && !overdueCustomers.contains(cust)) {
            overdueCustomers.add(cust);
          }
        }
      }
    }

    return overdueCustomers;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Calculates the average daily rental price of all cars stored in the gallery.
   * Algorithm:
   *   1. If `this.cars` is empty, return 0.0.
   *   2. Initialise `sumPrice` to 0.0.
   *   3. For each `car` in `this.cars`, add `car.dailyPrice` to `sumPrice`.
   *   4. Compute `average = sumPrice / this.cars.size()`.
   *   5. Return `average`.
   * Input:
   *   None.
   * Output:
   *   double – arithmetic mean of `dailyPrice` values of all cars.
   *   Returns 0.0 when the store has no cars.
   * Pre‑condition:
   *   `this.cars` is non‑null; each Car’s `dailyPrice` is a non‑negative double.
   * Post‑condition:
   *   No side‑effects; the returned value represents the average daily price at the
   *   moment of invocation.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double determineAverageDailyPrice()
  {
    if (this.cars.isEmpty()) {
      return 0.0;
    }

    double sumPrice = 0.0;
    for (Car car : this.cars) {
      sumPrice += car.getDailyPrice();
    }

    return sumPrice / this.cars.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Counts how many cars each customer has rented (including both active and completed rentals)
   *   and returns the result as a collection of key‑value pairs.
   * Algorithm:
   *   1. Initialise an empty map `counterMap` where key = Customer, value = Integer.
   *   2. For each `rental` in `this.rentals`:
   *        a. Let `cust` = `rental.customer`.
   *        b. If `counterMap` already contains `cust`, increment its value by 1;
   *           otherwise insert `cust` with value 1.
   *   3. Convert `counterMap` to a list of map entries (`EMap`) preserving the pairing.
   *   4. Return the list.
   * Input:
   *   None.
   * Output:
   *   List<EMap> – each entry contains:
   *        key   : Customer – the customer object.
   *        value : Integer   – the total number of rentals associated with that customer.
   *   Returns an empty list when there are no rentals.
   * Pre‑condition:
   *   `this.rentals` is non‑null; each Rental has a non‑null `customer`.
   * Post‑condition:
   *   The returned collection reflects the exact count of rentals per customer at the
   *   time of the call. No changes are made to the Store’s internal collections.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Map<Customer, Integer>> countCarsRentedPerCustomer()
  {
    Map<Customer, Integer> counterMap = new HashMap<>();

    for (Rental rental : this.rentals) {
      Customer cust = rental.getCustomer();
      if (cust != null) {
        counterMap.put(cust, counterMap.getOrDefault(cust, 0) + 1);
      }
    }

    EList<Map<Customer, Integer>> result = new BasicEList<>();
    for (Map.Entry<Customer, Integer> entry : counterMap.entrySet()) {
      Map<Customer, Integer> singleEntryMap = new HashMap<>();
      singleEntryMap.put(entry.getKey(), entry.getValue());
      result.add(singleEntryMap);
    }

    return result;
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Store
182905 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../RCGS/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../RCGS/src-gen/edu/carrental/
183015 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
183015 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
183015 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
183015 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
183016 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample5.mwe2 启动完成
正在拷贝 src-gen/edu/carrental 到 gpt-oss-120b/carrental5...
拷贝完成！

======================================
所有任务完成！
======================================

  public int countBookCheckOuts(final Book book)
  { /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { /* omitted */ }

} // LibrarySystem
240065 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../LS/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../LS/src-gen/edu/library/
240196 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
240196 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
240196 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
240197 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
240198 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample3.mwe2 启动完成
正在拷贝 src-gen/edu/library 到 gpt-oss-120b/library3...
拷贝完成！

======================================
正在启动 sample4.mwe2...
======================================
240505 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
240603 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project LS at 'file:/D:/EclipseWorkspace/LS/'
240606 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
240613 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@785ba20d
240613 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
240615 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
240616 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
An automated library book borrowing system maintains a collection of books. Each book has title, barcode, ISBN, and number of pages. In addition, the system allows users to have either a MEMBER User or a GUEST User. Each user (member/guest) has a name, email, address, and ID. A user can checkout a book on loan which has the start date and end date (format: yyyy-MM-dd).

A user can checkout a book on loan which has the start date and end date.
Function Requirement:
+ Count the number of times a specific book has been checked out.
+ Determine how many unique books a particular user has borrowed during a specified period.
+ Calculate the average page count of the unique books borrowed by a specific user.
+ Calculate the total number of unique books checked out by a specific user.
```

# Class Diagram
```plantuml
@startuml

title library Model

class Book {
    ISBN : String
    barcode : String
    numberOfPages : EIntegerObject
    title : String
}
class CheckOut {
    endDate : EDate
    startDate : EDate
    book : Book
    user : User
}
class LibrarySystem {
    books : List<Book>
    users : List<User>
    averageNumberOfPagesUniqueBooksByUser(user : User) : double
    countBookCheckOuts(book : Book) : int
    totalUniqueBooksCheckedOutByUser(user : User) : int
    uniqueBooksBorrowedByUser(user : User, start : EDate, end : EDate) : int
}
class User {
    ID : String
    address : String
    email : String
    name : String
    type : UserType
    checkouts : List<CheckOut>
}
enum UserType {
    MEMBER
    GUEST
}

CheckOut --> Book : book
CheckOut --> User : user  'opposite: checkouts
LibrarySystem *-- "*" Book : books
LibrarySystem --> "*" User : users
User *-- "*" CheckOut : checkouts  'opposite: user
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

265379 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@124b1369 (name: totalUniqueBooksCheckedOutByUser) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary:
  Calculates how many different books have been borrowed at least once by the
  specified user.
Algorithm:
  1. Validate that `user` is not null and belongs to this LibrarySystem.
  2. Create an empty Set<Book> called `uniqueBooks`.
  3. For each `CheckOut co` in `user.checkouts`:
       a. Add `co.book` to `uniqueBooks`.
  4. Return `uniqueBooks.size()`.
Input:
  - user : User
      * The user whose distinct borrowed books are counted.
      * Must be present in `LibrarySystem.users`.
Output:
  - int
      * Number of unique books the user has ever checked out.
      * Range: [0, ∞).
Pre-condition:
  - `user != null`.
  - `LibrarySystem.users` contains `user`.
Post-condition:
  - No modification of any data structures.
  - Returned value equals the cardinality of `{ co.book | co ∈ user.checkouts }`., org.eclipse.emf.ecore.impl.EOperationImpl@6baa673d (name: countBookCheckOuts) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary:
  Returns the total number of checkout transactions that involve the specified
  book across **all** users.
Algorithm:
  1. Validate that `book` is not null and is part of `LibrarySystem.books`.
  2. Initialise `count = 0`.
  3. Iterate over every `User u` in `LibrarySystem.users`:
       a. For each `CheckOut co` in `u.checkouts`:
             i If `co.book` equals `book` (by ISBN or barcode), increment `count`.
  4. Return `count`.
Input:
  - book : Book
      * The book whose checkout frequency is being queried.
      * Must be an existing object contained in `LibrarySystem.books`.
Output:
  - int
      * The total number of times `book` has been checked out.
      * Range: [0, ∞).
Pre-condition:
  - `book != null`.
  - `LibrarySystem.books` contains `book`.
Post-condition:
  - System state is unchanged.
  - Returned `count` equals the cardinality of the set
    `{ co ∈ CheckOut | co.book == book }`., org.eclipse.emf.ecore.impl.EOperationImpl@22bd6b0a (name: uniqueBooksBorrowedByUser) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary:
  Determines the count of **distinct** books that the given user borrowed
  during the inclusive date interval `[start, end]`.
Algorithm:
  1. Validate inputs:
       a. `user` is non‑null and exists in `LibrarySystem.users`.
       b. `start` and `end` are non‑null `EDate` objects.
       c. `start` ≤ `end` (chronologically).
  2. Initialise an empty Set<Book> called `uniqueBooksInPeriod`.
  3. For each `CheckOut co` in `user.checkouts`:
       a. If `co.startDate` and `co.endDate` intersect with the interval
          `[start, end]` (i.e., `co.endDate` ≥ `start` && `co.startDate` ≤ `end`):
             i. Add `co.book` to `uniqueBooksInPeriod`.
  4. Return `uniqueBooksInPeriod.size()`.
Input:
  - user : User
      * The user whose borrowing activity is examined.
      * Must be part of `LibrarySystem.users`.
  - start : EDate
      * Start of the query period (inclusive). Format: yyyy‑MM‑dd.
  - end : EDate
      * End of the query period (inclusive). Same format as `start`.
Output:
  - int
      * Number of unique books borrowed by `user` whose checkout interval
        overlaps with `[start, end]`.
      * Range: [0, ∞).
Pre-condition:
  - All parameters are non‑null.
  - `start` ≤ `end`.
  - `user` is registered within the system.
Post-condition:
  - System state remains unchanged.
  - Returned value equals the cardinality of
    `{ co.book | co ∈ user.checkouts ∧ co.endDate ≥ start ∧ co.startDate ≤ end }`., org.eclipse.emf.ecore.impl.EOperationImpl@673ce246 (name: averageNumberOfPagesUniqueBooksByUser) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary:
  Computes the average number of pages of all **distinct** books that the given
  user has borrowed at least once (regardless of time period).
Algorithm:
  1. Validate that `user` is not null and belongs to this LibrarySystem.
  2. Initialise an empty Set<Book> called `uniqueBooks`.
  3. For each CheckOut `co` in `user.checkouts`:
       a. Add `co.book` to `uniqueBooks` (Set guarantees uniqueness).
  4. If `uniqueBooks` is empty, return 0.0.
  5. Compute `totalPages` as the sum of `book.numberOfPages` for every
       `book` in `uniqueBooks`.
  6. Return `totalPages / uniqueBooks.size()` as a double.
Input:
  - user : User
      * The user whose borrowing history is analyzed.
      * Must be an existing object contained in `LibrarySystem.users`.
Output:
  - double
      * Average page count of the unique books borrowed by `user`.
      * Range: [0.0, ∞). Returns 0.0 when the user has never borrowed a book.
Pre-condition:
  - `user != null`.
  - `LibrarySystem.users` contains `user`.
Post-condition:
  - No mutation of any system state; all collections remain unchanged.
  - The returned value equals the arithmetic mean of page counts of the
    distinct books the user has ever checked out.}
265382 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
265410 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../LS/src-gen/edu/library
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.library;

import java.util.Collection;
import java.util.Date;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.library.LibrarySystem#getUsers <em>Users</em>}</li>
 *   <li>{@link edu.library.LibrarySystem#getBooks <em>Books</em>}</li>
 * </ul>
 *
 * @see edu.library.LibraryPackage#getLibrarySystem()
 * @model kind="class"
 * @generated
 */
public class LibrarySystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<User> users;

  protected EList<Book> books;

  protected LibrarySystem()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<User> getUsers()
  { ... /* omitted */ }

  public EList<Book> getBooks()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Calculates how many different books have been borrowed at least once by the
   *   specified user.
   * Algorithm:
   *   1. Validate that `user` is not null and belongs to this LibrarySystem.
   *   2. Create an empty Set<Book> called `uniqueBooks`.
   *   3. For each `CheckOut co` in `user.checkouts`:
   *        a. Add `co.book` to `uniqueBooks`.
   *   4. Return `uniqueBooks.size()`.
   * Input:
   *   - user : User
   *       * The user whose distinct borrowed books are counted.
   *       * Must be present in `LibrarySystem.users`.
   * Output:
   *   - int
   *       * Number of unique books the user has ever checked out.
   *       * Range: [0, ∞).
   * Pre-condition:
   *   - `user != null`.
   *   - `LibrarySystem.users` contains `user`.
   * Post-condition:
   *   - No modification of any data structures.
   *   - Returned value equals the cardinality of `{ co.book | co ∈ user.checkouts }`.
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int totalUniqueBooksCheckedOutByUser(final User user)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes the average number of pages of all **distinct** books that the given
   *   user has borrowed at least once (regardless of time period).
   * Algorithm:
   *   1. Validate that `user` is not null and belongs to this LibrarySystem.
   *   2. Initialise an empty Set<Book> called `uniqueBooks`.
   *   3. For each CheckOut `co` in `user.checkouts`:
   *        a. Add `co.book` to `uniqueBooks` (Set guarantees uniqueness).
   *   4. If `uniqueBooks` is empty, return 0.0.
   *   5. Compute `totalPages` as the sum of `book.numberOfPages` for every
   *        `book` in `uniqueBooks`.
   *   6. Return `totalPages / uniqueBooks.size()` as a double.
   * Input:
   *   - user : User
   *       * The user whose borrowing history is analyzed.
   *       * Must be an existing object contained in `LibrarySystem.users`.
   * Output:
   *   - double
   *       * Average page count of the unique books borrowed by `user`.
   *       * Range: [0.0, ∞). Returns 0.0 when the user has never borrowed a book.
   * Pre-condition:
   *   - `user != null`.
   *   - `LibrarySystem.users` contains `user`.
   * Post-condition:
   *   - No mutation of any system state; all collections remain unchanged.
   *   - The returned value equals the arithmetic mean of page counts of the
   *     distinct books the user has ever checked out.
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double averageNumberOfPagesUniqueBooksByUser(final User user)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Determines the count of **distinct** books that the given user borrowed
   *   during the inclusive date interval `[start, end]`.
   * Algorithm:
   *   1. Validate inputs:
   *        a. `user` is non‑null and exists in `LibrarySystem.users`.
   *        b. `start` and `end` are non‑null `EDate` objects.
   *        c. `start` ≤ `end` (chronologically).
   *   2. Initialise an empty Set<Book> called `uniqueBooksInPeriod`.
   *   3. For each `CheckOut co` in `user.checkouts`:
   *        a. If `co.startDate` and `co.endDate` intersect with the interval
   *           `[start, end]` (i.e., `co.endDate` ≥ `start` && `co.startDate` ≤ `end`):
   *              i. Add `co.book` to `uniqueBooksInPeriod`.
   *   4. Return `uniqueBooksInPeriod.size()`.
   * Input:
   *   - user : User
   *       * The user whose borrowing activity is examined.
   *       * Must be part of `LibrarySystem.users`.
   *   - start : EDate
   *       * Start of the query period (inclusive). Format: yyyy‑MM‑dd.
   *   - end : EDate
   *       * End of the query period (inclusive). Same format as `start`.
   * Output:
   *   - int
   *       * Number of unique books borrowed by `user` whose checkout interval
   *         overlaps with `[start, end]`.
   *       * Range: [0, ∞).
   * Pre-condition:
   *   - All parameters are non‑null.
   *   - `start` ≤ `end`.
   *   - `user` is registered within the system.
   * Post-condition:
   *   - System state remains unchanged.
   *   - Returned value equals the cardinality of
   *     `{ co.book | co ∈ user.checkouts ∧ co.endDate ≥ start ∧ co.startDate ≤ end }`.
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int uniqueBooksBorrowedByUser(final User user, final Date start, final Date end)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns the total number of checkout transactions that involve the specified
   *   book across **all** users.
   * Algorithm:
   *   1. Validate that `book` is not null and is part of `LibrarySystem.books`.
   *   2. Initialise `count = 0`.
   *   3. Iterate over every `User u` in `LibrarySystem.users`:
   *        a. For each `CheckOut co` in `u.checkouts`:
   *              i If `co.book` equals `book` (by ISBN or barcode), increment `count`.
   *   4. Return `count`.
   * Input:
   *   - book : Book
   *       * The book whose checkout frequency is being queried.
   *       * Must be an existing object contained in `LibrarySystem.books`.
   * Output:
   *   - int
   *       * The total number of times `book` has been checked out.
   *       * Range: [0, ∞).
   * Pre-condition:
   *   - `book != null`.
   *   - `LibrarySystem.books` contains `book`.
   * Post-condition:
   *   - System state is unchanged.
   *   - Returned `count` equals the cardinality of the set
   *     `{ co ∈ CheckOut | co.book == book }`.
   * <!-- end-model-doc -->
   * @model required="true" bookRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int countBookCheckOuts(final Book book)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // LibrarySystem
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `User` contains the following methods.
  + Instance creation: Use `LibraryFactory.eINSTANCE.createUser()`
  + Getter methods: public String getName(), public String getEmail(), public String getAddress(), public String getID(), public UserType getType(), public EList<CheckOut> getCheckouts()
  + Setter methods: public void setName(String newName), public void setEmail(String newEmail), public void setAddress(String newAddress), public void setID(String newID), public void setType(UserType newType)
- Class `Book` contains the following methods.
  + Instance creation: Use `LibraryFactory.eINSTANCE.createBook()`
  + Getter methods: public String getTitle(), public String getBarcode(), public String getISBN(), public Integer getNumberOfPages()
  + Setter methods: public void setTitle(String newTitle), public void setBarcode(String newBarcode), public void setISBN(String newISBN), public void setNumberOfPages(Integer newNumberOfPages)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.library;

import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.library.LibrarySystem#getUsers <em>Users</em>}</li>
 *   <li>{@link edu.library.LibrarySystem#getBooks <em>Books</em>}</li>
 * </ul>
 *
 * @see edu.library.LibraryPackage#getLibrarySystem()
 * @model kind="class"
 * @generated
 */
public class LibrarySystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<User> users;

  protected EList<Book> books;

  protected LibrarySystem()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<User> getUsers()
  { ... /* omitted */ }

  public EList<Book> getBooks()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Calculates how many different books have been borrowed at least once by the
   *   specified user.
   * Algorithm:
   *   1. Validate that `user` is not null and belongs to this LibrarySystem.
   *   2. Create an empty Set<Book> called `uniqueBooks`.
   *   3. For each `CheckOut co` in `user.checkouts`:
   *        a. Add `co.book` to `uniqueBooks`.
   *   4. Return `uniqueBooks.size()`.
   * Input:
   *   - user : User
   *       * The user whose distinct borrowed books are counted.
   *       * Must be present in `LibrarySystem.users`.
   * Output:
   *   - int
   *       * Number of unique books the user has ever checked out.
   *       * Range: [0, ∞).
   * Pre-condition:
   *   - `user != null`.
   *   - `LibrarySystem.users` contains `user`.
   * Post-condition:
   *   - No modification of any data structures.
   *   - Returned value equals the cardinality of `{ co.book | co ∈ user.checkouts }`.
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int totalUniqueBooksCheckedOutByUser(final User user)
  {
    // Validate pre‑conditions
    if (user == null) {
      throw new IllegalArgumentException("User must not be null.");
    }
    if (!getUsers().contains(user)) {
      throw new IllegalArgumentException("User is not registered in this LibrarySystem.");
    }

    // Initialise a set to collect distinct books
    Set<Book> uniqueBooks = new HashSet<>();

    // Accumulate books from all check‑outs of the user
    for (CheckOut co : user.getCheckouts()) {
      Book b = co.getBook();
      if (b != null) {
        uniqueBooks.add(b);
      }
    }

    // Result is the size of the set
    return uniqueBooks.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes the average number of pages of all **distinct** books that the given
   *   user has borrowed at least once (regardless of time period).
   * Algorithm:
   *   1. Validate that `user` is not null and belongs to this LibrarySystem.
   *   2. Initialise an empty Set<Book> called `uniqueBooks`.
   *   3. For each CheckOut `co` in `user.checkouts`:
   *        a. Add `co.book` to `uniqueBooks` (Set guarantees uniqueness).
   *   4. If `uniqueBooks` is empty, return 0.0.
   *   5. Compute `totalPages` as the sum of `book.numberOfPages` for every
   *        `book` in `uniqueBooks`.
   *   6. Return `totalPages / uniqueBooks.size()` as a double.
   * Input:
   *   - user : User
   *       * The user whose borrowing history is analyzed.
   *       * Must be an existing object contained in `LibrarySystem.users`.
   * Output:
   *   - double
   *       * Average page count of the unique books borrowed by `user`.
   *       * Range: [0.0, ∞). Returns 0.0 when the user has never borrowed a book.
   * Pre-condition:
   *   - `user != null`.
   *   - `LibrarySystem.users` contains `user`.
   * Post-condition:
   *   - No mutation of any system state; all collections remain unchanged.
   *   - The returned value equals the arithmetic mean of page counts of the
   *     distinct books the user has ever checked out.
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double averageNumberOfPagesUniqueBooksByUser(final User user)
  {
    // Validate pre‑conditions
    if (user == null) {
      throw new IllegalArgumentException("User must not be null.");
    }
    if (!getUsers().contains(user)) {
      throw new IllegalArgumentException("User is not registered in this LibrarySystem.");
    }

    // Collect distinct books
    Set<Book> uniqueBooks = new HashSet<>();
    for (CheckOut co : user.getCheckouts()) {
      Book b = co.getBook();
      if (b != null) {
        uniqueBooks.add(b);
      }
    }

    // If the user has never borrowed a book, return 0.0
    if (uniqueBooks.isEmpty()) {
      return 0.0;
    }

    // Sum the number of pages
    double totalPages = 0.0;
    for (Book b : uniqueBooks) {
      Integer pages = b.getNumberOfPages();
      if (pages != null) {
        totalPages += pages;
      }
    }

    // Compute and return the average
    return totalPages / uniqueBooks.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Determines the count of **distinct** books that the given user borrowed
   *   during the inclusive date interval `[start, end]`.
   * Algorithm:
   *   1. Validate inputs:
   *        a. `user` is non‑null and exists in `LibrarySystem.users`.
   *        b. `start` and `end` are non‑null `EDate` objects.
   *        c. `start` ≤ `end` (chronologically).
   *   2. Initialise an empty Set<Book> called `uniqueBooksInPeriod`.
   *   3. For each `CheckOut co` in `user.checkouts`:
   *        a. If `co.startDate` and `co.endDate` intersect with the interval
   *           `[start, end]` (i.e., `co.endDate` ≥ `start` && `co.startDate` ≤ `end`):
   *              i. Add `co.book` to `uniqueBooksInPeriod`.
   *   4. Return `uniqueBooksInPeriod.size()`.
   * Input:
   *   - user : User
   *       * The user whose borrowing activity is examined.
   *       * Must be part of `LibrarySystem.users`.
   *   - start : EDate
   *       * Start of the query period (inclusive). Format: yyyy‑MM‑dd.
   *   - end : EDate
   *       * End of the query period (inclusive). Same format as `start`.
   * Output:
   *   - int
   *       * Number of unique books borrowed by `user` whose checkout interval
   *         overlaps with `[start, end]`.
   *       * Range: [0, ∞).
   * Pre-condition:
   *   - All parameters are non‑null.
   *   - `start` ≤ `end`.
   *   - `user` is registered within the system.
   * Post-condition:
   *   - System state remains unchanged.
   *   - Returned value equals the cardinality of
   *     `{ co.book | co ∈ user.checkouts ∧ co.endDate ≥ start ∧ co.startDate ≤ end }`.
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int uniqueBooksBorrowedByUser(final User user, final Date start, final Date end)
  {
    // Validate pre‑conditions
    if (user == null) {
      throw new IllegalArgumentException("User must not be null.");
    }
    if (start == null || end == null) {
      throw new IllegalArgumentException("Start and end dates must not be null.");
    }
    if (!getUsers().contains(user)) {
      throw new IllegalArgumentException("User is not registered in this LibrarySystem.");
    }
    if (start.compareTo(end) > 0) {
      throw new IllegalArgumentException("Start date must not be after end date.");
    }

    // Collect distinct books whose checkout period overlaps the query interval
    Set<Book> uniqueBooksInPeriod = new HashSet<>();
    for (CheckOut co : user.getCheckouts()) {
      Date coStart = co.getStartDate();
      Date coEnd   = co.getEndDate();

      // Ensure both dates are present before checking overlap
      if (coStart != null && coEnd != null) {
        boolean overlaps = !coEnd.before(start) && !coStart.after(end);
        if (overlaps) {
          Book b = co.getBook();
          if (b != null) {
            uniqueBooksInPeriod.add(b);
          }
        }
      }
    }

    return uniqueBooksInPeriod.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns the total number of checkout transactions that involve the specified
   *   book across **all** users.
   * Algorithm:
   *   1. Validate that `book` is not null and is part of `LibrarySystem.books`.
   *   2. Initialise `count = 0`.
   *   3. Iterate over every `User u` in `LibrarySystem.users`:
   *        a. For each `CheckOut co` in `u.checkouts`:
   *              i If `co.book` equals `book` (by ISBN or barcode), increment `count`.
   *   4. Return `count`.
   * Input:
   *   - book : Book
   *       * The book whose checkout frequency is being queried.
   *       * Must be an existing object contained in `LibrarySystem.books`.
   * Output:
   *   - int
   *       * The total number of times `book` has been checked out.
   *       * Range: [0, ∞).
   * Pre-condition:
   *   - `book != null`.
   *   - `LibrarySystem.books` contains `book`.
   * Post-condition:
   *   - System state is unchanged.
   *   - Returned `count` equals the cardinality of the set
   *     `{ co ∈ CheckOut | co.book == book }`.
   * <!-- end-model-doc -->
   * @model required="true" bookRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int countBookCheckOuts(final Book book)
  {
    // Validate pre‑conditions
    if (book == null) {
      throw new IllegalArgumentException("Book must not be null.");
    }
    if (!getBooks().contains(book)) {
      throw new IllegalArgumentException("Book is not registered in this LibrarySystem.");
    }

    int count = 0;
    for (User u : getUsers()) {
      for (CheckOut co : u.getCheckouts()) {
        Book b = co.getBook();
        if (b != null && b.equals(book)) {
          count++;
        }
      }
    }
    return count;
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // LibrarySystem
312980 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../LS/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../LS/src-gen/edu/library/
313076 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
313076 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
313076 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
313076 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
313077 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample4.mwe2 启动完成
正在拷贝 src-gen/edu/library 到 gpt-oss-120b/library4...
拷贝完成！

======================================
正在启动 sample5.mwe2...
======================================
313264 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
313345 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project LS at 'file:/D:/EclipseWorkspace/LS/'
313347 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
313354 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@747e0a31
313354 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
313356 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
313357 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
An automated library book borrowing system maintains a collection of books. Each book has title, barcode, ISBN, and number of pages. In addition, the system allows users to have either a MEMBER User or a GUEST User. Each user (member/guest) has a name, email, address, and ID. A user can checkout a book on loan which has the start date and end date (format: yyyy-MM-dd).

A user can checkout a book on loan which has the start date and end date.
Function Requirement:
+ Count the number of times a specific book has been checked out.
+ Determine how many unique books a particular user has borrowed during a specified period.
+ Calculate the average page count of the unique books borrowed by a specific user.
+ Calculate the total number of unique books checked out by a specific user.
```

# Class Diagram
```plantuml
@startuml

title library Model

class Book {
    ISBN : String
    barcode : String
    numberOfPages : EIntegerObject
    title : String
}
class CheckOut {
    endDate : EDate
    startDate : EDate
    book : Book
    user : User
}
class LibrarySystem {
    books : List<Book>
    users : List<User>
    averageNumberOfPagesUniqueBooksByUser(user : User) : double
    countBookCheckOuts(book : Book) : int
    totalUniqueBooksCheckedOutByUser(user : User) : int
    uniqueBooksBorrowedByUser(user : User, start : EDate, end : EDate) : int
}
class User {
    ID : String
    address : String
    email : String
    name : String
    type : UserType
    checkouts : List<CheckOut>
}
enum UserType {
    MEMBER
    GUEST
}

CheckOut --> Book : book
CheckOut --> User : user  'opposite: checkouts
LibrarySystem *-- "*" Book : books
LibrarySystem --> "*" User : users
User *-- "*" CheckOut : checkouts  'opposite: user
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

344322 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@55691a59 (name: totalUniqueBooksCheckedOutByUser) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary:
  Returns the total number of different books a user has ever borrowed,
  regardless of time.
Algorithm:
  1. Verify that `user` is non‑null and present in `users`.
  2. Create an empty Set<Book> uniqueBooks.
  3. Iterate over user.checkouts
       a. uniqueBooks.add(c.book)
  4. Return uniqueBooks.size().
Input:
  - user : User
      * Meaning: the patron whose borrowing history is considered.
Output:
  - int
      * Meaning: number of distinct books ever borrowed by the user.
      * Range: 0 … Integer.MAX_VALUE.
Pre-condition:
  - The user exists in the system.
Post-condition:
  - No mutation of any data structures.
  - Returned integer equals the size of the distinct‑book set derived from the user's checkout list., org.eclipse.emf.ecore.impl.EOperationImpl@3152a0a3 (name: averageNumberOfPagesUniqueBooksByUser) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary:
  Computes the average page count of all unique books that the specified user
  has borrowed at least once.
Algorithm:
  1. Validate that `user` is non‑null and present in `users`.
  2. Initialise an empty Set<Book> uniqueBooks.
  3. For each checkout c in user.checkouts
       a. uniqueBooks.add(c.book)
  4. If uniqueBooks.isEmpty()
       → return 0.0   // no books borrowed
  5. Initialise totalPages ← 0.
  6. For each book b in uniqueBooks
       a. totalPages ← totalPages + b.numberOfPages
  7. Compute average ← totalPages / uniqueBooks.size() as double.
  8. Return average.
Input:
  - user : User
      * Meaning: the patron whose borrowed books are analysed.
Output:
  - double
      * Meaning: arithmetic mean of page counts of the distinct books borrowed.
      * Range: 0.0 … max double; 0.0 indicates the user has not borrowed any book.
Pre-condition:
  - `user` exists in `users`.
  - Each Book in the system has a non‑negative integer `numberOfPages`.
Post-condition:
  - System remains unchanged.
  - Returned value equals Σ_{b∈U} b.numberOfPages / |U| where U is the set of distinct books borrowed by `user`., org.eclipse.emf.ecore.impl.EOperationImpl@2350e46 (name: uniqueBooksBorrowedByUser) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary:
  Calculates how many distinct books a particular user has borrowed within a
  given inclusive date interval.
Algorithm:
  1. Validate inputs (non‑null user, start, end; start ≤ end).
  2. Initialise an empty Set<Book> distinctBooks.
  3. For each checkout c in user.checkouts
       a. If c.startDate ≥ start AND c.endDate ≤ end
             → distinctBooks.add(c.book)
  4. Return distinctBooks.size().
Input:
  - user : User
      * Meaning: the borrower whose activity is examined.
  - start : EDate
      * Meaning: start of the period (inclusive).
      * Format: date in ISO‑8601 "yyyy-MM-dd".
  - end : EDate
      * Meaning: end of the period (inclusive).
      * Same format as start.
Output:
  - int
      * Meaning: count of unique Book instances borrowed by `user` inside the period.
      * Range: 0 … Integer.MAX_VALUE.
Pre-condition:
  - `user` exists in `users`.
  - `start` and `end` are valid dates; `start` is not after `end`.
Post-condition:
  - System state is unchanged.
  - Returned value equals the cardinality of the set of distinct books
    satisfying the date constraint., org.eclipse.emf.ecore.impl.EOperationImpl@1f234e35 (name: countBookCheckOuts) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary:
  Returns the total number of times the specified book has been borrowed
  across all users and all checkout records stored in the system.
Algorithm:
  1. Validate that `book` is not null and exists in `books`.
  2. Initialise counter ← 0.
  3. For each user u in `users`
       a. For each checkout c in u.checkouts
             i. If c.book equals the supplied `book`
                → counter ← counter + 1
  4. Return counter.
Input:
  - book : Book
      * Meaning: the book whose checkout frequency is being queried.
      * Format: an instance of class Book; must have non‑null ISBN/barcode.
Output:
  - int
      * Meaning: number of checkout records that reference the given book.
      * Range: 0 … Integer.MAX_VALUE.
Pre-condition:
  - The LibrarySystem instance is fully initialised (books & users collections are non‑null).
  - The supplied `book` is present in `books`.
Post-condition:
  - No modification of any system state; collections remain unchanged.
  - Returned integer equals the count of matching Checkout objects.}
344324 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
344346 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../LS/src-gen/edu/library
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.library;

import java.util.Collection;
import java.util.Date;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.library.LibrarySystem#getUsers <em>Users</em>}</li>
 *   <li>{@link edu.library.LibrarySystem#getBooks <em>Books</em>}</li>
 * </ul>
 *
 * @see edu.library.LibraryPackage#getLibrarySystem()
 * @model kind="class"
 * @generated
 */
public class LibrarySystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<User> users;

  protected EList<Book> books;

  protected LibrarySystem()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<User> getUsers()
  { ... /* omitted */ }

  public EList<Book> getBooks()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns the total number of different books a user has ever borrowed,
   *   regardless of time.
   * Algorithm:
   *   1. Verify that `user` is non‑null and present in `users`.
   *   2. Create an empty Set<Book> uniqueBooks.
   *   3. Iterate over user.checkouts
   *        a. uniqueBooks.add(c.book)
   *   4. Return uniqueBooks.size().
   * Input:
   *   - user : User
   *       * Meaning: the patron whose borrowing history is considered.
   * Output:
   *   - int
   *       * Meaning: number of distinct books ever borrowed by the user.
   *       * Range: 0 … Integer.MAX_VALUE.
   * Pre-condition:
   *   - The user exists in the system.
   * Post-condition:
   *   - No mutation of any data structures.
   *   - Returned integer equals the size of the distinct‑book set derived from the user's checkout list.
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int totalUniqueBooksCheckedOutByUser(final User user)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes the average page count of all unique books that the specified user
   *   has borrowed at least once.
   * Algorithm:
   *   1. Validate that `user` is non‑null and present in `users`.
   *   2. Initialise an empty Set<Book> uniqueBooks.
   *   3. For each checkout c in user.checkouts
   *        a. uniqueBooks.add(c.book)
   *   4. If uniqueBooks.isEmpty()
   *        → return 0.0   // no books borrowed
   *   5. Initialise totalPages ← 0.
   *   6. For each book b in uniqueBooks
   *        a. totalPages ← totalPages + b.numberOfPages
   *   7. Compute average ← totalPages / uniqueBooks.size() as double.
   *   8. Return average.
   * Input:
   *   - user : User
   *       * Meaning: the patron whose borrowed books are analysed.
   * Output:
   *   - double
   *       * Meaning: arithmetic mean of page counts of the distinct books borrowed.
   *       * Range: 0.0 … max double; 0.0 indicates the user has not borrowed any book.
   * Pre-condition:
   *   - `user` exists in `users`.
   *   - Each Book in the system has a non‑negative integer `numberOfPages`.
   * Post-condition:
   *   - System remains unchanged.
   *   - Returned value equals Σ_{b∈U} b.numberOfPages / |U| where U is the set of distinct books borrowed by `user`.
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double averageNumberOfPagesUniqueBooksByUser(final User user)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Calculates how many distinct books a particular user has borrowed within a
   *   given inclusive date interval.
   * Algorithm:
   *   1. Validate inputs (non‑null user, start, end; start ≤ end).
   *   2. Initialise an empty Set<Book> distinctBooks.
   *   3. For each checkout c in user.checkouts
   *        a. If c.startDate ≥ start AND c.endDate ≤ end
   *              → distinctBooks.add(c.book)
   *   4. Return distinctBooks.size().
   * Input:
   *   - user : User
   *       * Meaning: the borrower whose activity is examined.
   *   - start : EDate
   *       * Meaning: start of the period (inclusive).
   *       * Format: date in ISO‑8601 "yyyy-MM-dd".
   *   - end : EDate
   *       * Meaning: end of the period (inclusive).
   *       * Same format as start.
   * Output:
   *   - int
   *       * Meaning: count of unique Book instances borrowed by `user` inside the period.
   *       * Range: 0 … Integer.MAX_VALUE.
   * Pre-condition:
   *   - `user` exists in `users`.
   *   - `start` and `end` are valid dates; `start` is not after `end`.
   * Post-condition:
   *   - System state is unchanged.
   *   - Returned value equals the cardinality of the set of distinct books
   *     satisfying the date constraint.
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int uniqueBooksBorrowedByUser(final User user, final Date start, final Date end)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns the total number of times the specified book has been borrowed
   *   across all users and all checkout records stored in the system.
   * Algorithm:
   *   1. Validate that `book` is not null and exists in `books`.
   *   2. Initialise counter ← 0.
   *   3. For each user u in `users`
   *        a. For each checkout c in u.checkouts
   *              i. If c.book equals the supplied `book`
   *                 → counter ← counter + 1
   *   4. Return counter.
   * Input:
   *   - book : Book
   *       * Meaning: the book whose checkout frequency is being queried.
   *       * Format: an instance of class Book; must have non‑null ISBN/barcode.
   * Output:
   *   - int
   *       * Meaning: number of checkout records that reference the given book.
   *       * Range: 0 … Integer.MAX_VALUE.
   * Pre-condition:
   *   - The LibrarySystem instance is fully initialised (books & users collections are non‑null).
   *   - The supplied `book` is present in `books`.
   * Post-condition:
   *   - No modification of any system state; collections remain unchanged.
   *   - Returned integer equals the count of matching Checkout objects.
   * <!-- end-model-doc -->
   * @model required="true" bookRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int countBookCheckOuts(final Book book)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // LibrarySystem
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `User` contains the following methods.
  + Instance creation: Use `LibraryFactory.eINSTANCE.createUser()`
  + Getter methods: public String getName(), public String getEmail(), public String getAddress(), public String getID(), public UserType getType(), public EList<CheckOut> getCheckouts()
  + Setter methods: public void setName(String newName), public void setEmail(String newEmail), public void setAddress(String newAddress), public void setID(String newID), public void setType(UserType newType)
- Class `Book` contains the following methods.
  + Instance creation: Use `LibraryFactory.eINSTANCE.createBook()`
  + Getter methods: public String getTitle(), public String getBarcode(), public String getISBN(), public Integer getNumberOfPages()
  + Setter methods: public void setTitle(String newTitle), public void setBarcode(String newBarcode), public void setISBN(String newISBN), public void setNumberOfPages(Integer newNumberOfPages)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.library;

import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.library.LibrarySystem#getUsers <em>Users</em>}</li>
 *   <li>{@link edu.library.LibrarySystem#getBooks <em>Books</em>}</li>
 * </ul>
 *
 * @see edu.library.LibraryPackage#getLibrarySystem()
 * @model kind="class"
 * @generated
 */
public class LibrarySystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<User> users;

  protected EList<Book> books;

  protected LibrarySystem()
  { /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { /* omitted */ }

  public EList<User> getUsers()
  { /* omitted */ }

  public EList<Book> getBooks()
  { /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns the total number of different books a user has ever borrowed,
   *   regardless of time.
   * Algorithm:
   *   1. Verify that `user` is non‑null and present in `users`.
   *   2. Create an empty Set<Book> uniqueBooks.
   *   3. Iterate over user.checkouts
   *        a. uniqueBooks.add(c.book)
   *   4. Return uniqueBooks.size().
   * Input:
   *   - user : User
   *       * Meaning: the patron whose borrowing history is considered.
   * Output:
   *   - int
   *       * Meaning: number of distinct books ever borrowed by the user.
   *       * Range: 0 … Integer.MAX_VALUE.
   * Pre-condition:
   *   - The user exists in the system.
   * Post-condition:
   *   - No mutation of any data structures.
   *   - Returned integer equals the size of the distinct‑book set derived from the user's checkout list.
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int totalUniqueBooksCheckedOutByUser(final User user)
  {
    if (user == null || !getUsers().contains(user)) {
      throw new IllegalArgumentException("User must be non‑null and part of the system.");
    }

    Set<Book> uniqueBooks = new HashSet<>();
    for (CheckOut checkout : user.getCheckouts()) {
      Book b = checkout.getBook();
      if (b != null) {
        uniqueBooks.add(b);
      }
    }
    return uniqueBooks.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes the average page count of all unique books that the specified user
   *   has borrowed at least once.
   * Algorithm:
   *   1. Validate that `user` is non‑null and present in `users`.
   *   2. Initialise an empty Set<Book> uniqueBooks.
   *   3. For each checkout c in user.checkouts
   *        a. uniqueBooks.add(c.book)
   *   4. If uniqueBooks.isEmpty()
   *        → return 0.0   // no books borrowed
   *   5. Initialise totalPages ← 0.
   *   6. For each book b in uniqueBooks
   *        a. totalPages ← totalPages + b.numberOfPages
   *   7. Compute average ← totalPages / uniqueBooks.size() as double.
   *   8. Return average.
   * Input:
   *   - user : User
   *       * Meaning: the patron whose borrowed books are analysed.
   * Output:
   *   - double
   *       * Meaning: arithmetic mean of page counts of the distinct books borrowed.
   *       * Range: 0.0 … max double; 0.0 indicates the user has not borrowed any book.
   * Pre-condition:
   *   - `user` exists in `users`.
   *   - Each Book in the system has a non‑negative integer `numberOfPages`.
   * Post-condition:
   *   - System remains unchanged.
   *   - Returned value equals Σ_{b∈U} b.numberOfPages / |U| where U is the set of distinct books borrowed by `user`.
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double averageNumberOfPagesUniqueBooksByUser(final User user)
  {
    if (user == null || !getUsers().contains(user)) {
      throw new IllegalArgumentException("User must be non‑null and part of the system.");
    }

    Set<Book> uniqueBooks = new HashSet<>();
    for (CheckOut checkout : user.getCheckouts()) {
      Book b = checkout.getBook();
      if (b != null) {
        uniqueBooks.add(b);
      }
    }

    if (uniqueBooks.isEmpty()) {
      return 0.0;
    }

    int totalPages = 0;
    for (Book b : uniqueBooks) {
      Integer pages = b.getNumberOfPages();
      if (pages != null) {
        totalPages += pages.intValue();
      }
    }

    return ((double) totalPages) / uniqueBooks.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Calculates how many distinct books a particular user has borrowed within a
   *   given inclusive date interval.
   * Algorithm:
   *   1. Validate inputs (non‑null user, start, end; start ≤ end).
   *   2. Initialise an empty Set<Book> distinctBooks.
   *   3. For each checkout c in user.checkouts
   *        a. If c.startDate ≥ start AND c.endDate ≤ end
   *              → distinctBooks.add(c.book)
   *   4. Return distinctBooks.size().
   * Input:
   *   - user : User
   *       * Meaning: the borrower whose activity is examined.
   *   - start : EDate
   *       * Meaning: start of the period (inclusive).
   *       * Format: date in ISO‑8601 "yyyy-MM-dd".
   *   - end : EDate
   *       * Meaning: end of the period (inclusive).
   *       * Same format as start.
   * Output:
   *   - int
   *       * Meaning: count of unique Book instances borrowed by `user` inside the period.
   *       * Range: 0 … Integer.MAX_VALUE.
   * Pre-condition:
   *   - `user` exists in `users`.
   *   - `start` and `end` are valid dates; `start` is not after `end`.
   * Post-condition:
   *   - System state is unchanged.
   *   - Returned value equals the cardinality of the set of distinct books
   *     satisfying the date constraint.
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int uniqueBooksBorrowedByUser(final User user, final Date start, final Date)
  {
    if (user == null || start == null || end == null) {
      throw new IllegalArgumentException("User and dates must be non‑null.");
    }
    if (!getUsers().contains(user)) {
      throw new IllegalArgumentException("User must be part of the system.");
    }
    if (start.compareTo(end) > 0) {
      throw new IllegalArgumentException("Start date must not be after end date.");
    }

    Set<Book> distinctBooks = new HashSet<>();
    for (CheckOut checkout : user.getCheckouts()) {
      Date cStart = checkout.getStartDate();
      Date cEnd   = checkout.getEndDate();
      if (cStart != null && cEnd != null
          && cStart.compareTo(start) >= 0
          && cEnd.compareTo(end) <= 0) {
        Book = checkout.getBook();
        if (b != null) {
          distinctBooks.add(b);
        }
      }
    }
    return distinctBooks.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns the total number of times the specified book has been borrowed
   *   across all users and all checkout records stored in the system.
   * Algorithm:
   *   1. Validate that `book` is not null and exists in `books`.
   *   2. Initialise counter ← 0.
   *   3. For each user u in `users`
   *        a. For each checkout c in u.checkouts
   *              i. If c.book equals the supplied `book`
   *                 → counter ← counter + 1
   *   4. Return counter.
   * Input:
   *   - book : Book
   *       * Meaning: the book whose checkout frequency is being queried.
   *       * Format: an instance of class Book; must have non‑null ISBN/barcode.
   * Output:
   *   - int
   *       * Meaning: number of checkout records that reference the given book.
   *       * Range: 0 … Integer.MAX_VALUE.
   * Pre-condition:
   *   - The LibrarySystem instance is fully initialised (books & users collections are non‑null).
   *   - The supplied `book` is present in `books`.
   * Post-condition:
   *   - No modification of any system state; collections remain unchanged.
   *   - Returned integer equals the count of matching Checkout objects.
   * <!-- end-model-doc -->
   * @model required="true" bookRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int countBookCheckOuts(final Book book)
  {
    if (book == null || !getBooks().contains(book)) {
      throw new IllegalArgumentException("Book must be non‑null and part of the system.");
    }

    int counter = 0;
    for (User user : getUsers()) {
      for (CheckOut checkout : user.getCheckouts()) {
        if (book.equals(checkout.getBook())) {
          counter++;
        }
      }
    }
    return counter;
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { /* omitted */ }

} // LibrarySystem
386703 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../LS/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../LS/src-gen/edu/library/
386802 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
386802 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - ----------
1. ERROR in D:\EclipseWorkspace\LS\src-gen\edu\library\LibrarySystem.java (at line 275)
	, final Date)
	^
Syntax error on token ",", { expected
----------
2. ERROR in D:\EclipseWorkspace\LS\src-gen\edu\library\LibrarySystem.java (at line 275)
	, final Date)
	        ^^^^
Syntax error, insert "VariableDeclarators" to complete LocalVariableDeclaration
----------
3. ERROR in D:\EclipseWorkspace\LS\src-gen\edu\library\LibrarySystem.java (at line 275)
	, final Date)
	        ^^^^
Syntax error, insert ";" to complete BlockStatements
----------
4. ERROR in D:\EclipseWorkspace\LS\src-gen\edu\library\LibrarySystem.java (at line 301)
	}
	^
Syntax error, insert "}" to complete MethodBody
----------
4 problems (4 errors)

386802 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - File: D:\EclipseWorkspace\LS\src-gen\edu\library\LibrarySystem.java
Line: 275
Type: ERROR
Message: Syntax error on token ",", { expected
Code line: 	, final Date)
Caret Pos: 	^

386802 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - File: D:\EclipseWorkspace\LS\src-gen\edu\library\LibrarySystem.java
Line: 275
Type: ERROR
Message: Syntax error, insert "VariableDeclarators" to complete LocalVariableDeclaration
Code line: 	, final Date)
Caret Pos: 	        ^^^^

386802 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - File: D:\EclipseWorkspace\LS\src-gen\edu\library\LibrarySystem.java
Line: 275
Type: ERROR
Message: Syntax error, insert ";" to complete BlockStatements
Code line: 	, final Date)
Caret Pos: 	        ^^^^

386802 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - File: D:\EclipseWorkspace\LS\src-gen\edu\library\LibrarySystem.java
Line: 301
Type: ERROR
Message: Syntax error, insert "}" to complete MethodBody
Code line: 	}
Caret Pos: 	^

# Task
You will be given a **Java Class** that is originally generated by EMF code generator with `suppressInterfaces=true` and later is completed by LLMs. Your task is to fix the **Compilation Errors** by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. Read the error messages carefully.
2. Do your best to fix the errors locally without introducing new types, fields, and methods.
3. You should not remove faulty methods to eliminate compilation errors.
4. Do not change parts without errors.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.library;

import java.util.Collection;
import java.util.Date;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;
import java.util.HashSet;
import java.util.Set;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.library.LibrarySystem#getUsers <em>Users</em>}</li>
 *   <li>{@link edu.library.LibrarySystem#getBooks <em>Books</em>}</li>
 * </ul>
 *
 * @see edu.library.LibraryPackage#getLibrarySystem()
 * @model kind="class"
 * @generated
 */
public class LibrarySystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<User> users;

  protected EList<Book> books;

  protected LibrarySystem()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<User> getUsers()
  { ... /* omitted */ }

  public EList<Book> getBooks()
  { ... /* omitted */ }

  public int totalUniqueBooksCheckedOutByUser(final User user)
  { ... /* omitted */ }

  public double averageNumberOfPagesUniqueBooksByUser(final User user)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Calculates how many distinct books a particular user has borrowed within a
   *   given inclusive date interval.
   * Algorithm:
   *   1. Validate inputs (non‑null user, start, end; start ≤ end).
   *   2. Initialise an empty Set<Book> distinctBooks.
   *   3. For each checkout c in user.checkouts
   *        a. If c.startDate ≥ start AND c.endDate ≤ end
   *              → distinctBooks.add(c.book)
   *   4. Return distinctBooks.size().
   * Input:
   *   - user : User
   *       * Meaning: the borrower whose activity is examined.
   *   - start : EDate
   *       * Meaning: start of the period (inclusive).
   *       * Format: date in ISO‑8601 "yyyy-MM-dd".
   *   - end : EDate
   *       * Meaning: end of the period (inclusive).
   *       * Same format as start.
   * Output:
   *   - int
   *       * Meaning: count of unique Book instances borrowed by `user` inside the period.
   *       * Range: 0 … Integer.MAX_VALUE.
   * Pre-condition:
   *   - `user` exists in `users`.
   *   - `start` and `end` are valid dates; `start` is not after `end`.
   * Post-condition:
   *   - System state is unchanged.
   *   - Returned value equals the cardinality of the set of distinct books
   *     satisfying the date constraint.
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int uniqueBooksBorrowedByUser(final User user, final Date start, final Date end)
  , final Date)
  {
    if (user == null || start == null || end == null) {
      throw new IllegalArgumentException("User and dates must be non‑null.");
    }
    if (!getUsers().contains(user)) {
      throw new IllegalArgumentException("User must be part of the system.");
    }
    if (start.compareTo(end) > 0) {
      throw new IllegalArgumentException("Start date must not be after end date.");
    }

    Set<Book> distinctBooks = new HashSet<>();
    for (CheckOut checkout : user.getCheckouts()) {
      Date cStart = checkout.getStartDate();
      Date cEnd   = checkout.getEndDate();
      if (cStart != null && cEnd != null
          && cStart.compareTo(start) >= 0
          && cEnd.compareTo(end) <= 0) {
        Book = checkout.getBook();
        if (b != null) {
          distinctBooks.add(b);
        }
      }
    }
    return distinctBooks.size();
  }

  public int countBookCheckOuts(final Book book)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // LibrarySystem
```

# Compilation Errors
```
- ERROR: Syntax error on token ",", { expected
	, final Date)
	^

- ERROR: Syntax error, insert "VariableDeclarators" to complete LocalVariableDeclaration
	, final Date)
	        ^^^^

- ERROR: Syntax error, insert ";" to complete BlockStatements
	, final Date)
	        ^^^^

- ERROR: Syntax error, insert "}" to complete MethodBody
	}
	^
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `User` contains the following methods.
  + Instance creation: Use `LibraryFactory.eINSTANCE.createUser()`
  + Getter methods: public String getName(), public String getEmail(), public String getAddress(), public String getID(), public UserType getType(), public EList<CheckOut> getCheckouts()
  + Setter methods: public void setName(String newName), public void setEmail(String newEmail), public void setAddress(String newAddress), public void setID(String newID), public void setType(UserType newType)
- Class `Book` contains the following methods.
  + Instance creation: Use `LibraryFactory.eINSTANCE.createBook()`
  + Getter methods: public String getTitle(), public String getBarcode(), public String getISBN(), public Integer getNumberOfPages()
  + Setter methods: public void setTitle(String newTitle), public void setBarcode(String newBarcode), public void setISBN(String newISBN), public void setNumberOfPages(Integer newNumberOfPages)

# Output Format
Just put the Java class you fixed into a single block as follows.

```result
(fixed Java class)
```

fixed code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.library;

import java.util.Collection;
import java.util.Date;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;
import java.util.HashSet;
import java.util.Set;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.library.LibrarySystem#getUsers <em>Users</em>}</li>
 *   <li>{@link edu.library.LibrarySystem#getBooks <em>Books</em>}</li>
 * </ul>
 *
 * @see edu.library.LibraryPackage#getLibrarySystem()
 * @model kind="class"
 * @generated
 */
public class LibrarySystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<User> users;

  protected EList<Book> books;

  protected LibrarySystem()
  { /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { /* omitted */ }

  public EList<User> getUsers()
  { /* omitted */ }

  public EList<Book> getBooks()
  { /* omitted */ }

  public int totalUniqueBooksCheckedOutByUser(final User user)
  { /* omitted */ }

  public double averageNumberOfPagesUniqueBooksByUser(final User user)
  { /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Calculates how many distinct books a particular user has borrowed within a
   *   given inclusive date interval.
   * Algorithm:
   *   1. Validate inputs (non‑null user, start, end; start ≤ end).
   *   2. Initialise an empty Set<Book> distinctBooks.
   *   3. For each checkout c in user.checkouts
   *        a. If c.startDate ≥ start AND c.endDate ≤ end
   *              → distinctBooks.add(c.book)
   *   4. Return distinctBooks.size().
   * Input:
   *   - user : User
   *       * Meaning: the borrower whose activity is examined.
   *   - start : EDate
   *       * Meaning: start of the period (inclusive).
   *       * Format: date in ISO‑8601 "yyyy-MM-dd".
   *   - end : EDate
   *       * Meaning: end of the period (inclusive).
   *       * Same format as start.
   * Output:
   *   - int
   *       * Meaning: count of unique Book instances borrowed by `user` inside the period.
   *       * Range: 0 … Integer.MAX_VALUE.
   * Pre-condition:
   *   - `user` exists in `users`.
   *   - `start` and `end` are valid dates; `start` is not after `end`.
   * Post-condition:
   *   - System state is unchanged.
   *   - Returned value equals the cardinality of the set of distinct books
   *     satisfying the date constraint.
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int uniqueBooksBorrowedByUser(final User user, final Date start, final Date end)
  {
    if (user == null || start == null || end == null) {
      throw new IllegalArgumentException("User and dates must be non‑null.");
    }
    if (!getUsers().contains(user)) {
      throw new IllegalArgumentException("User must be part of the system.");
    }
    if (start.compareTo(end) > 0) {
      throw new IllegalArgumentException("Start date must not be after end date.");
    }

    Set<Book> distinctBooks = new HashSet<>();
    for (CheckOut checkout : user.getCheckouts()) {
      Date cStart = checkout.getStartDate();
      Date cEnd   = checkout.getEndDate();
      if (cStart != null && cEnd != null
          && cStart.compareTo(start) >= 0
          && cEnd.compareTo(end) <= 0) {
        Book b = checkout.getBook();
        if (b != null) {
          distinctBooks.add(b);
        }
      }
    }
    return distinctBooks.size();
  }

  public int countBookCheckOuts(final Book book)
  { /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { /* omitted */ }

} // LibrarySystem
415100 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../LS/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../LS/src-gen/edu/library/
415202 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
415202 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
415202 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
415202 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
415204 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample5.mwe2 启动完成
正在拷贝 src-gen/edu/library 到 gpt-oss-120b/library5...
拷贝完成！

======================================
所有任务完成！
======================================

/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;
import org.eclipse.emf.common.util.BasicEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getLived <em>Lived</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  /**
   * The cached value of the '{@link #getLived() <em>Lived</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getLived()
   * @generated
   * @ordered
   */
  protected EList<Pet> lived;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected House()
  {
    super();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  protected EClass eStaticClass()
  {
    return PetsPackage.Literals.HOUSE;
  }

  /**
   * Returns the value of the '<em><b>Lived</b></em>' containment reference list.
   * The list contents are of type {@link edu.pets.Pet}.
   * It is bidirectional and its opposite is '{@link edu.pets.Pet#getHouse <em>House</em>}'.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Lived</em>' containment reference list.
   * @see edu.pets.PetsPackage#getHouse_Lived()
   * @see edu.pets.Pet#getHouse
   * @model opposite="house" containment="true"
   * @generated
   */
  public EList<Pet> getLived()
  {
    if (lived == null)
    {
      lived = new EObjectContainmentWithInverseEList<Pet>(Pet.class, this, PetsPackage.HOUSE__LIVED, PetsPackage.PET__HOUSE);
    }
    return lived;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary
   *   Returns a list containing the names of all pets (dogs and cats) that live in
   *   this house. If the house has no pets, an empty list is returned.
   * Algorithm
   *   1. Create an empty List<String> result.
   *   2. For each pet in this.lived:
   *        a. Add pet.name to result.
   *   3. Return result.
   * Input
   *   - None.
   * Output
   *   - List<String> – a list of pet names; order corresponds to the iteration order
   *     of the internal `lived` collection. The list may be empty but never null.
   * Pre‑condition
   *   - The house instance exists.
   * Post‑condition
   *   - The returned list reflects the current set of pets in the house.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> retrievePetNames()
  {
    // Create an empty result list
    EList<String> result = new BasicEList<String>();
    // Iterate over the pets stored in this house
    for (Pet pet : this.getLived()) {
      // Add the pet's name (may be null, but spec does not forbid)
      result.add(pet.getName());
    }
    // Return the populated list (may be empty)
    return result;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary
   *   Adds the specified pet to this house.
   *   The operation succeeds only if the pet has a non‑empty name and is not already
   *   associated with any house (including this one). The pet’s `house` reference
   *   is set to this house and the pet is stored in the house’s `lived` collection.
   * Algorithm
   *   1. IF pet == null → RETURN false
   *   2. IF pet.name == null OR pet.name.trim().isEmpty() → RETURN false
   *   3. IF pet.house != null → RETURN false          // pet already lives somewhere
   *   4. Add pet to this.lived
   *   5. Set pet.house = this
   *   6. RETURN true
   * Input
   *   - pet : Pet – an instance of Dog or Cat. Must have a non‑null, non‑blank name.
   * Output
   *   - boolean – true if the pet was added to the house; false otherwise.
   * Pre‑condition
   *   - This House object is properly instantiated.
   * Post‑condition
   *   - If true is returned, the house’s `lived` list contains the pet and the pet’s
   *     `house` attribute references this house.
   *   - If false is returned, the state of the house and the pet remains unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean addPet(final Pet pet)
  {
    // 1. Check for null pet
    if (pet == null) {
      return false;
    }
    // 2. Check for non‑empty name
    String name = pet.getName();
    if (name == null || name.trim().isEmpty()) {
      return false;
    }
    // 3. Ensure the pet does not already belong to a house
    if (pet.getHouse() != null) {
      return false;
    }
    // 4. Add to the lived collection
    this.getLived().add(pet);
    // 5. Set the back‑reference
    pet.setHouse(this);
    // 6. Success
    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary
   *   Removes the specified pet from this house if, and only if, the pet currently
   *   belongs to this house. The pet’s `house` reference is cleared.
   * Algorithm
   *   1. IF pet == null OR pet.house != this → EXIT (no action)
   *   2. Remove pet from this.lived
   *   3. Set pet.house = null
   * Input
   *   - pet : Pet – the pet to be removed; may be a Dog or Cat.
   * Output
   *   - void (the method has no return value). The caller can inspect the house’s
   *     `lived` collection to determine whether removal succeeded.
   * Pre‑condition
   *   - This House object is instantiated and may contain zero or more pets.
   * Post‑condition
   *   - If the pet belonged to this house, it is no longer present in `lived`
   *     and its `house` reference is null.
   *   - If the pet did not belong to this house, the house’s state is unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void removePet(final Pet pet)
  {
    // 1. Validate that the pet belongs to this house
    if (pet == null || pet.getHouse() != this) {
      return;
    }
    // 2. Remove from the collection (if present)
    this.getLived().remove(pet);
    // 3. Clear the back‑reference
    pet.setHouse(null);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary
   *   Retrieves all pets of the specified type that live in this house.
   *   Accepted type strings are "dog" and "cat" (case‑insensitive). If the
   *   type argument is null, empty, or not one of the accepted values,
   *   an empty list is returned.
   * Algorithm
   *   1. IF type == null → RETURN empty list.
   *   2. Normalize: t = type.trim().toLowerCase().
   *   3. IF t != "dog" && t != "cat" → RETURN empty list.
   *   4. Create empty List<Pet> result.
   *   5. For each pet in this.lived:
   *        a. IF (t == "dog" && pet instanceof Dog) OR
   *           (t == "cat" && pet instanceof Cat) THEN
   *              add pet to result.
   *   6. Return result.
   * Input
   *   - type : String – the pet type filter ("dog" or "cat").
   * Output
   *   - List<Pet> – list of pets matching the type; may be empty but never null.
   * Pre‑condition
   *   - House object is instantiated.
   * Post‑condition
   *   - The returned list contains exactly those pets of the requested type that
   *     are currently stored in `lived`.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Pet> getPetsByType(final String type)
  {
    // 1. Null check
    if (type == null) {
      return new BasicEList<Pet>();
    }
    // 2. Normalise
    String t = type.trim().toLowerCase();
    // 3. Validate type
    if (!"dog".equals(t) && !"cat".equals(t)) {
      return new BasicEList<Pet>();
    }
    // 4. Prepare result list
    EList<Pet> result = new BasicEList<Pet>();
    // 5. Filter by type
    for (Pet pet : this.getLived()) {
      if (("dog".equals(t) && pet instanceof Dog) ||
          ("cat".equals(t) && pet instanceof Cat)) {
        result.add(pet);
      }
    }
    // 6. Return the collected pets
    return result;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary
   *   Returns the number of pets of a given type living in this house.
   *   If `type` is null, empty or not "dog"/"cat", the method returns the total
   *   number of pets in the house.
   * Algorithm
   *   1. IF type == null OR type.trim().isEmpty() → RETURN this.lived.size().
   *   2. Normalize: t = type.trim().toLowerCase().
   *   3. IF t != "dog" && t != "cat" → RETURN this.lived.size().
   *   4. Initialize count = 0.
   *   5. For each pet in this.lived:
   *        a. IF (t == "dog" && pet instanceof Dog) OR
   *           (t == "cat" && pet instanceof Cat) THEN count++.
   *   6. RETURN count.
   * Input
   *   - type : String – filter for "dog" or "cat". Case‑insensitive.
   * Output
   *   - int – number of pets matching the filter; 0 if none.
   * Pre‑condition
   *   - The house instance exists.
   * Post‑condition
   *   - No modification of the house’s state.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int getPetCount(final String type)
  {
    // 1. Null or empty check
    if (type == null || type.trim().isEmpty()) {
      return this.getLived().size();
    }
    // 2. Normalise
    String t = type.trim().toLowerCase();
    // 3. Validate type
    if (!"dog".equals(t) && !"cat".equals(t)) {
      return this.getLived().size();
    }
    // 4. Count matching pets
    int count = 0;
    for (Pet pet : this.getLived()) {
      if (("dog".equals(t) && pet instanceof Dog) ||
          ("cat".equals(t) && pet instanceof Cat)) {
        count++;
      }
    }
    // 5. Return the count
    return count;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  {
    switch (featureID)
    {
      case PetsPackage.HOUSE__LIVED:
        return ((InternalEList<InternalEObject>)(InternalEList<?>)getLived()).basicAdd(otherEnd, msgs);
    }
    return super.eInverseAdd(otherEnd, featureID, msgs);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  {
    switch (featureID)
    {
      case PetsPackage.HOUSE__LIVED:
        return ((InternalEList<?>)getLived()).basicRemove(otherEnd, msgs);
    }
    return super.eInverseRemove(otherEnd, featureID, msgs);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  {
    switch (featureID)
    {
      case PetsPackage.HOUSE__LIVED:
        return getLived();
    }
    return super.eGet(featureID, resolve, coreType);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  {
    switch (featureID)
    {
      case PetsPackage.HOUSE__LIVED:
        getLived().clear();
        getLived().addAll((Collection<? extends Pet>)newValue);
        return;
    }
    super.eSet(featureID, newValue);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public void eUnset(int featureID)
  {
    switch (featureID)
    {
      case PetsPackage.HOUSE__LIVED:
        getLived().clear();
        return;
    }
    super.eUnset(featureID);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public boolean eIsSet(int featureID)
  {
    switch (featureID)
    {
      case PetsPackage.HOUSE__LIVED:
        return lived != null && !lived.isEmpty();
    }
    return super.eIsSet(featureID);
  }

} // House

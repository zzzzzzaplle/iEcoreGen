- ERROR: Syntax error, insert "}" to complete MethodBody
	}
	^
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Pet` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Public methods: public void makeNoise()
  + Getter methods: public String getName()
  + Setter methods: public void setName(String newName)

# Output Format
Just put the Java class you fixed into a single block as follows.

```result
(fixed Java class)
```

fixed code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;
import org.eclipse.emf.common.util.BasicEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getPets <emPets</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Pet> pets;

  protected House()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Pet> getPets()
  { ... /* omitted */ }

  public EList<String>PetNames()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Adds the specified Pet to this House if the pet is eligible.
   * Algorithm:
   *   1. IF pet is null OR pet.name is null OR pet.name.trim() is empty
   *        RETURN false.
   *   2. IF pet is already associated with any House
   * RETURN false.
   *   3. Add pet to this.pets collection.
   *  4. (Optional) Set pet.home = this   // to keep bidirectional link.
   *   5. RETURN true.
   * Input:
   *   - pet : Pet
   *       The pet instance to be added.
   *       Must a non‑null, non‑empty name.
   * Output:
   *   - boolean
   *       true  – pet was successfully added to this house.
   *       false – pet had no name or already belonged to a house.
   * Pre‑condition:
   *   - The House object exists.
   *   - The internal list `pets` may be empty or contain other pets.
   * Post‑condition:
   *   - If true is returned, `pet` is now a member of `this.pets`
   *     and (if a back‑reference exists) `pet.home == this`.
   *   - If false is returned, the state of `this.pets` is unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean addPet(final Pet pet)
  {
    // Validate pet and its name
    if (pet == null) {
      return false;
    }
    String name = pet.getName();
    if (name == null || name.trim().isEmpty()) {
      return false;
    }
    // Check whether the pet is already contained in another EObject (e.g., another House)
    if (pet.eContainer() != null) {
      // It already belongs to a container, thus we consider it associated with a house
      return false;
    }
    // Add the pet to the house's collection
    if (pets == null) {
      // Defensive: ensure the list is initialized (normally handled by getPets())
      pets = new EObjectContainmentEList<Pet>(Pet.class, this, PetsPackage.HOUSE__PETS);
    }
    pets.add(pet);
    // Optional back‑reference handling would go here if such a feature existed.
    return true;
  }

  public void removePet(final Pet pet)
  { ... /* omitted */ }

  public EList<Pet> getPetsByType(final String type)
  { ... /* omitted */ }

  public int getPetCount(final String type)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // House
234762 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../Pets/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../Pets/src-gen/edu/pets/
234844 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
234844 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
234844 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
234844 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
234845 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample3.mwe2 启动完成
正在拷贝 src-gen/edu/pets 到 gpt-oss-120b/pets3...
拷贝完成！

======================================
正在启动 sample4.mwe2...
======================================
235031 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
235091 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project Pets at 'file:/D:/EclipseWorkspace/Pets/'
235094 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
235098 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@65c75870
235098 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
235100 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
235100 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
A house may have any number of pets living in it. The two possible types of pets that can live in a house are dogs and cats. Each dog or cat has a name. An animal’s house is its one and only home. You can tell an animal to make noise and it will do its thing.
Functional requirement：
+ Retrieve a list of all pet names (dogs and cats) living in a specified house. Return an empty list if there are no pets.

+ Add a pet to the house. Return false if the pet already belongs to any house (including this one) or the pet does have name; return true if the pet is added successfully.

+ Remove a specified pet from its current house. Return false if the pet does not belong to the given current house; return true if it is removed successfully.

+ Retrieve a list of pets of a specific input string ("dog" or "cat") that live in a particular house. Return an empty list if there are no pets.

+ Count the number of pets in a particular house. Return 0 if there are no pets.
```

# Class Diagram
```plantuml
@startuml

title pets Model

class Cat {
}
class Dog {
}
class House {
    pets : List<Pet>
    addPet(pet : Pet) : boolean
    getPetCount(type : String) : int
    getPetsByType(type : String) : List<Pet>
    removePet(pet : Pet) : void
    retrievePetNames() : List<String>
}
abstract class Pet {
    name : String
    makeNoise() : void
}

Cat --|> Pet
Dog --|> Pet
House *-- "*" Pet : pets
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

244332 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@6d6e8dfc (name: getPetsByType) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary:
  Counts the number of pets of a given type ("dog" or "cat") living in this house.
Algorithm:
  1. Call getPetsByType(type) to obtain the filtered list.
  2; Return the size of that list.
Input:
  - type : String
      Expected values: "dog" or "cat" (case‑insensitive).
Output:
  - int
      Number of pets of the specified type. Returns 0 when there are none or when type is.
Pre‑condition:
  - The House object is instantiated.
Post‑condition:
  - No modification of internal state; merely reports a count., org.eclipse.emf.ecore.impl.EOperationImpl@5b628376 (name: addPet) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Adds a pet (Dog or Cat) to this house if the pet is not already assigned to any house
  and has a valid (non‑empty) name.
Algorithm:
  1. Validate that pet not null.
  2. If pet.name is null or empty → return false.
  3. If pet.house ≠ null →    // pet already belongs to a house
         return false.
  4. Append pet to this.pets list.
  5. Set pet.house = this.
  6. Return true.
Input:
  - pet : Pet
      The pet instance to be added. Must be a concrete subclass (Dog or Cat).
Output:
  - boolean
      true  – pet successfully added to this house.
      false – pet was not added because it already belongs to a house or has an invalid name.
Pre‑condition:
  - The House object is properly instantiated.
Post‑condition:
  - If result == true: this.pets contains the pet and pet.house references this House.
  - If result == false: the state of this.pets and pet.house is unchanged., org.eclipse.emf.ecore.impl.EOperationImpl@930b6f9 (name: removePet) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Removes a specified pet from this house.
Algorithm:
  1. Validate that pet is not null.
  2. If pet.house ≠ this → return false.
  3. Remove pet from this.pets collection.
  4. Set pet.house = null.
  5. Return true.
Input:
  - pet : Pet
      The pet to be removed. Must be a Dog or Cat instance currently residing in this house.
Output:
  - boolean
      true  – pet was successfully removed.
      false – pet did not belong to this house; no removal performed.
Pre‑condition:
  - The House object is instantiated and may contain zero or more pets.
Post‑condition:
  - If result == true: this.pets no longer contains the pet and pet.house is null.
  - If result == false: the collection and pet.house remain unchanged., org.eclipse.emf.ecore.impl.EOperationImpl@15363eba (name: retrievePetNames) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary:
  Retrieves the names of all pets (dogs and cats) that live in this house.
Algorithm:
  1. Initialise an empty List<String> result.
  2. For each pet in this.pets:
       a. If pet.name is not null, add pet.name to result.
  3. Return result.
Input:
  None
Output:
  - List<String>
      A list containing the names of all pets in the house.
      Returns an empty list when the house has no pets.
Pre‑condition:
  - The House object is instantiated.
Post‑condition:
  - The returned list reflects the current set of pets; the internal state of the house is unchanged., org.eclipse.emf.ecore.impl.EOperationImpl@2258ca14 (name: makeNoise) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Makes the animal emit its characteristic sound.
  1. Determine the concrete runtime class of this Pet.
  2. If this is a Dog → output "Woof!" (or appropriate dog sound).
     If this is a Cat → output "Meow!" (or appropriate cat sound).
  3. The method performs the side‑effect of printing/playing the sound; it returns nothing.
Input:
  - None
Output:
  - void
      Side‑effect: the sound is emitted (e.g., printed to console or sent to an audio subsystem).
Pre‑condition:
  - The Pet instance has a non‑null name (name not required for noise but assumed by domain).
Post‑condition:
  - No change to object state; the audible/visual cue has been produced.}
244335 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
244354 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../Pets/src-gen/edu/pets
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getPets <em>Pets</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Pet> pets;

  protected House()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Pet> getPets()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves the names of all pets (dogs and cats) that live in this house.
   * Algorithm:
   *   1. Initialise an empty List<String> result.
   *   2. For each pet in this.pets:
   *        a. If pet.name is not null, add pet.name to result.
   *   3. Return result.
   * Input:
   *   None
   * Output:
   *   - List<String>
   *       A list containing the names of all pets in the house.
   *       Returns an empty list when the house has no pets.
   * Pre‑condition:
   *   - The House object is instantiated.
   * Post‑condition:
   *   - The returned list reflects the current set of pets; the internal state of the house is unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<String> retrievePetNames()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Adds a pet (Dog or Cat) to this house if the pet is not already assigned to any house
   *   and has a valid (non‑empty) name.
   * Algorithm:
   *   1. Validate that pet not null.
   *   2. If pet.name is null or empty → return false.
   *   3. If pet.house ≠ null →    // pet already belongs to a house
   *          return false.
   *   4. Append pet to this.pets list.
   *   5. Set pet.house = this.
   *   6. Return true.
   * Input:
   *   - pet : Pet
   *       The pet instance to be added. Must be a concrete subclass (Dog or Cat).
   * Output:
   *   - boolean
   *       true  – pet successfully added to this house.
   *       false – pet was not added because it already belongs to a house or has an invalid name.
   * Pre‑condition:
   *   - The House object is properly instantiated.
   * Post‑condition:
   *   - If result == true: this.pets contains the pet and pet.house references this House.
   *   - If result == false: the state of this.pets and pet.house is unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean addPet(final Pet pet)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Removes a specified pet from this house.
   * Algorithm:
   *   1. Validate that pet is not null.
   *   2. If pet.house ≠ this → return false.
   *   3. Remove pet from this.pets collection.
   *   4. Set pet.house = null.
   *   5. Return true.
   * Input:
   *   - pet : Pet
   *       The pet to be removed. Must be a Dog or Cat instance currently residing in this house.
   * Output:
   *   - boolean
   *       true  – pet was successfully removed.
   *       false – pet did not belong to this house; no removal performed.
   * Pre‑condition:
   *   - The House object is instantiated and may contain zero or more pets.
   * Post‑condition:
   *   - If result == true: this.pets no longer contains the pet and pet.house is null.
   *   - If result == false: the collection and pet.house remain unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void removePet(final Pet pet)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Counts the number of pets of a given type ("dog" or "cat") living in this house.
   * Algorithm:
   *   1. Call getPetsByType(type) to obtain the filtered list.
   *   2; Return the size of that list.
   * Input:
   *   - type : String
   *       Expected values: "dog" or "cat" (case‑insensitive).
   * Output:
   *   - int
   *       Number of pets of the specified type. Returns 0 when there are none or when type is.
   * Pre‑condition:
   *   - The House object is instantiated.
   * Post‑condition:
   *   - No modification of internal state; merely reports a count.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<Pet> getPetsByType(final String type)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  public int getPetCount(String type)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // House
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Pet` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Public methods: public void makeNoise()
  + Getter methods: public String getName()
  + Setter methods: public void setName(String newName)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getPets <em>Pets</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Pet> pets;

  protected House()
  { /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { /* omitted */ }

  public EList<Pet> getPets()
  { /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves the names of alldogs and cats) that live in this house.
   * Algorithm:
   *   1. Initialise an empty List<String> result.
   *   2. For each pet in this.pets:
   *        a. If pet.name is not null, add pet.name to result.
   *   3. Return result.
   * Input:
   *   None
   * Output:
   *   - List<String>
   *       A list containing the names of all pets in the house.
   *       Returns an empty list when the house has no pets.
   * Pre‑condition:
   *   - The House object is instantiated.
   * Post‑condition:
   *   - The returned list reflects the current set of pets; the internal state of the house is unchanged.
   <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> retrievePetNames()
  {
    BasicEList<String> result = new BasicEList<>();
    if (pets != null) {
      for (Pet pet : pets) {
        if (pet != null) {
          String name = pet.getName();
          if (name != null) {
            result.add(name);
          }
        }
      }
    }
    return result;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Adds a pet (Dog or Cat) to this house if the pet is not already assigned to any house
   *   and has a valid (non‑empty) name.
   * Algorithm:
   *   1. Validate that pet not null.
   *   2. If pet.name is null or empty → return false.
   *   3. If pet.house ≠ null →    // pet already belongs to a house
   *          return false.
   *   4. Append pet to this.pets list.
   *   5. Set pet.house = this.
   *   6. Return true.
   * Input:
   *   - pet : Pet
   *       The pet instance to be added. Must be a concrete subclass (Dog or Cat).
   * Output:
   *   - boolean
   *       true  – pet successfully added to this house.
   *       false – pet was not added because it already belongs to a house or has an invalid name.
   * Pre‑condition:
   *   - The House object is properly instantiated.
   * Post‑condition:
   *   - If result == true: this.pets contains the pet and pet.house references this House.
   *   - If result == false: the state of this.pets and pet.house is unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean addPet(final Pet pet)
  {
    if (pet == null) {
      return false;
    }
    String name = pet.getName();
    if (name == null || name.isEmpty()) {
      return false;
    }
    // Assuming Pet has a generated container reference getter/setter for House
    // e.g., getHouse() and setHouse(House)
    try {
      java.lang.reflect.Method getHouse = pet.getClass().getMethod("getHouse");
      Object currentHouse = getHouse.invoke(pet);
      if (currentHouse != null) {
        return false;
      }
      // Add to the house's pet list
      getPets().add(pet);
      // Set the back‑reference
      java.lang.reflect.Method setHouse = pet.getClass().getMethod("setHouse", House.class);
      setHouse.invoke(pet, this);
      return true;
    } catch (Exception e) {
      // If reflective access fails, we conservatively return false
      return false;
    }
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Removes a specified pet from this house.
   * Algorithm:
   *   1. Validate that pet is not null.
   *   2. If pet.house ≠ this → return false.
   *   3. Remove pet from this.pets collection.
   *   4. Set pet.house = null.
   *   5. Return true.
   * Input:
   *   - pet : Pet
   *       The pet to be removed. Must be a Dog or Cat instance currently residing in this house.
   * Output:
   *   - boolean
   *       true  – pet was successfully removed.
   *       false – pet did not belong to this house; no removal performed.
   * Pre‑condition:
   *   - The House object is instantiated and may contain zero or more pets.
   * Post‑condition:
   *   - If result == true: this.pets no longer contains the pet and pet.house is null.
   *   - If result == false: the collection and pet.house remain unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void removePet(final Pet pet)
  {
    if (pet == null) {
      return;
    }
    try {
      java.lang.reflect.Method getHouse = pet.getClass().getMethod("getHouse");
      Object currentHouse = getHouse.invoke(pet);
      if (currentHouse != this) {
        return;
      }
      getPets().remove(pet);
      java.lang.reflect.Method setHouse = pet.getClass().getMethod("setHouse", House.class);
      setHouse.invoke(pet, new Object[] { null });
    } catch (Exception e) {
      // If reflective access fails, do nothing
    }
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Counts the number of pets of a given type ("dog" or "cat") living in this house.
   * Algorithm:
   *   1. Call getPetsByType(type) to obtain the filtered list.
   *   2; Return the size of that list.
   * Input:
   *   - type : String
   *       Expected values: "dog" or "cat" (case‑insensitive).
   * Output:
   *   - int
   *       Number of pets of the specified type. Returns 0 when there are none or when type is.
   * Pre‑condition:
 *   - The House object is instantiated   * Post‑condition:
   *   - No modification of internal state; merely reports a count.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Pet> getPetsByType(final String type)
  {
    BasicEList<Pet> result = new BasicEList<>();
    if (type == null || pets == null) {
      return result;
    }
    for (Pet pet : pets) {
      if (pet != null) {
        String simpleName = pet.getClass().getSimpleName();
        if (simpleName.equalsIgnoreCase(type)) {
          result.add(pet);
        }
      }
    }
    return result;
  }

  public int getPetCount(String type)
  { /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { /* omitted */ }

} // House
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Makes the animal emit its characteristic sound.
   *   1. Determine the concrete runtime class of this Pet.
   *   2. If this is a Dog → output "Woof!" (or appropriate dog sound).
   *      If this is a Cat → output "Meow!" (or appropriate cat sound).
   *   3. The method performs the side‑effect of printing/playing the sound; it returns nothing.
   * Input:
   *   - None
   * Output:
   *   - void
   *       Side‑effect: the sound is emitted (e.g., printed to console or sent to an audio subsystem).
   * Pre‑condition:
   *   - The Pet instance has a non‑null name (name not required for noise but assumed by domain).
   * Post‑condition:
   *   - No change to object state; the audible/visual cue has been produced.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void makeNoise()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { /* omitted */ }

  public String getName()
  { /* omitted */ }

  public void setName(String newName)
  { /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Makes the animal emit its characteristic sound.
   *   1. Determine the concrete runtime class of this Pet.
   *   2. If this is a Dog → output "Woof!" (or appropriate dog sound).
   *      If this is a Cat → output "Meow!" (or appropriate cat sound).
   *   3. The method performs the side‑effect of printing/playing the sound; it returns nothing.
   * Input:
   *   - None
 * Output:
   *   - void
   *       Side‑effect: the sound is emitted (e.g., printed to console or sent to an audio subsystem).
   * Pre‑condition:
   *   - The Pet instance has a non‑null name (name not required for noise but assumed by domain).
   * Post‑condition:
   *   - No change to object state; the audible/visual cue has been produced.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void makeNoise()
  {
    // Pre‑condition: the name should be non‑null; we simply ignore if null.
    // Determine concrete type and emit the appropriate sound.
    if (this instanceof Dog) {
      System.out.println("Woof!");
    } else if (this instanceof Cat) {
      System.out.println("Meow!");
    }
    // No state change; method completes after side‑effect.
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { /* omitted */ }

  @Override
  public String toString()
  { /* omitted */ }

} // Pet
268001 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../Pets/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../Pets/src-gen/edu/pets/
268083 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
268083 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
268083 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
268083 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
268084 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample4.mwe2 启动完成
正在拷贝 src-gen/edu/pets 到 gpt-oss-120b/pets4...
拷贝完成！

======================================
正在启动 sample5.mwe2...
======================================
268256 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
268321 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project Pets at 'file:/D:/EclipseWorkspace/Pets/'
268324 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
268328 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@5e1fc897
268328 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
268330 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
268330 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
A house may have any number of pets living in it. The two possible types of pets that can live in a house are dogs and cats. Each dog or cat has a name. An animal’s house is its one and only home. You can tell an animal to make noise and it will do its thing.
Functional requirement：
+ Retrieve a list of all pet names (dogs and cats) living in a specified house. Return an empty list if there are no pets.

+ Add a pet to the house. Return false if the pet already belongs to any house (including this one) or the pet does have name; return true if the pet is added successfully.

+ Remove a specified pet from its current house. Return false if the pet does not belong to the given current house; return true if it is removed successfully.

+ Retrieve a list of pets of a specific input string ("dog" or "cat") that live in a particular house. Return an empty list if there are no pets.

+ Count the number of pets in a particular house. Return 0 if there are no pets.
```

# Class Diagram
```plantuml
@startuml

title pets Model

class Cat {
}
class Dog {
}
class House {
    pets : List<Pet>
    addPet(pet : Pet) : boolean
    getPetCount(type : String) : int
    getPetsByType(type : String) : List<Pet>
    removePet(pet : Pet) : void
    retrievePetNames() : List<String>
}
abstract class Pet {
    name : String
    makeNoise() : void
}

Cat --|> Pet
Dog --|> Pet
House *-- "*" Pet : pets
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

280760 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@18ca65ea (name: retrievePetNames) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary:
  Returns a list of the names of all pets (dogs and cats) residing in this House.
Algorithm:
  1. Create an empty List<String> names.
  2. For each pet in this.pets:
       a. If pet.name is non‑null, add pet.name to names.
  3. Return names.
Input:
  - (none)
Output:
  - List<String>
      A list of pet names; empty if the house has no pets.
Pre‑condition:
  - The House instance exists and its internal list `pets` is initialized.
Post‑condition:
  - The House and its pet collection remain unchanged., org.eclipse.emf.ecore.impl.EOperationImpl@634de03e (name: removePet) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Removes a specified Pet from this House.
Algorithm:
  1. If pet is null, return false.
  2. Search for pet in this.pets (reference equality).
  3. If not found, return false.
  4. Remove pet from this.pets.
  5. Set pet.home = null.
  6. Return true.
Input:
  - pet: Pet
      The pet instance that should be removed from this house.
Output:
  - boolean
      true  – the pet was found in this house and removed.
      false – the pet was not found in this house or null.
Pre‑condition:
  - The House instance exists and its internal list `pets` is initialized.
Post‑condition:
  - If true is returned, `pet` is no longer present in `this.pets` and its `home` reference is null.
  - If false is returned, the collection `this.pets` and `pet.home` remain unchanged., org.eclipse.emf.ecore.impl.EOperationImpl@5ca29f17 (name: getPetCount) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Returns the number of pets of a specific type ("dog" or "cat") living in this House.
Algorithm:
 . Normalize `type` to lower case.
  2. If type is "dog" and not "cat", return 0.
  3. Initialise counter = 0.
  4. Iterate over each pet in this.pets:
       a. If type == "dog" and pet is instance of Dog, increment counter.
       b. If type == "cat" and pet is instance of Cat, increment counter.
  5. Return counter.
Input:
  - type: String
      Expected values: "dog" or "cat" (case‑insensitive). Any other value yields 0.
Output:
  - int
      The count of pets of the requested type; 0 if none or if `type` is invalid.
Pre‑condition:
  - The House instance exists and its internal list `pets` is initialized.
Post‑condition:
  - The state of the House and its pets remains unchanged., org.eclipse.emf.ecore.impl.EOperationImpl@66f965a (name: getPetsByType) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary:
  Retrieves a list of pets of the specified type ("dog" or "cat") that live in this House.
Algorithm:
  1. Normalize `type` to lower case.
  2. If type is not "dog" and not "cat", return an empty list.
  3. Create an empty List<Pet> result.
  4. Iterate over each pet in this.pets:
       a. If type == "dog" and pet instanceof Dog, add pet to result.
       b. If type == "cat" and pet instanceof Cat, add pet to result.
  5. Return result.
Input:
  - type: String
      Expected values: "dog" or "cat" (case‑insensitive). Any other string yields an empty list.
Output:
  - List<Pet>
      A list containing all pets of the requested type; empty if none or if `type` is invalid.
Pre‑condition:
  - The House instance exists and its internal list `pets` is initialized.
Post‑condition:
  - The House and its pets are not modified., org.eclipse.emf.ecore.impl.EOperationImpl@140a2add (name: makeNoise) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Causes the animal to emit its characteristic sound.
Algorithm (abstract):
  - Sub‑classes must implement this method to produce the appropriate noise.
Input:
  - (none)
Output:
  - (none) – side effect is an audible or logged noise.
Pre‑condition:
  - The Pet instance exists.
Post‑condition:
  - The specific noise associated with the concrete subclass is produced.
Note:
  - Dog implementation: prints or logs "Woof!".
  - Cat implementation: prints or logs "Meow!"., org.eclipse.emf.ecore.impl.EOperationImpl@4d3a7025 (name: addPet) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary:
  Adds a given Pet (Dog or Cat) to this House.
Algorithm:
. If pet is null, return false.
  2. If pet.name is null or empty, return false.
  3. If pet already has a home (pet.home != null), return false.
  4. Append pet to this.pets.
  5. Set pet.home = this.
  6. Return true.
Input:
  - pet: Pet
      The pet instance to be added. Must be non‑null and have a non‑empty name.
Output:
  - boolean
      true  – the pet was successfully added.
      false – the pet is null, has no name, or already belongs to a house.
Pre‑condition:
  - The House instance exists and its internal list `pets` is initialized.
Post‑condition:
  - If true is returned, `pet` is contained in `this.pets` and `pet.home` references this House.
  - If false is returned, the state of `this.pets` and `pet.home` remains unchanged.}
280762 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
280778 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../Pets/src-gen/edu/pets
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getPets <em>Pets</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Pet> pets;

  protected House()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Pet> getPets()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns a list of the names of all pets (dogs and cats) residing in this House.
   * Algorithm:
   *   1. Create an empty List<String> names.
   *   2. For each pet in this.pets:
   *        a. If pet.name is non‑null, add pet.name to names.
   *   3. Return names.
   * Input:
   *   - (none)
   * Output:
   *   - List<String>
   *       A list of pet names; empty if the house has no pets.
   * Pre‑condition:
   *   - The House instance exists and its internal list `pets` is initialized.
   * Post‑condition:
   *   - The House and its pet collection remain unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<String> retrievePetNames()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Adds a given Pet (Dog or Cat) to this House.
   * Algorithm:
   * . If pet is null, return false.
   *   2. If pet.name is null or empty, return false.
   *   3. If pet already has a home (pet.home != null), return false.
   *   4. Append pet to this.pets.
   *   5. Set pet.home = this.
   *   6. Return true.
   * Input:
   *   - pet: Pet
   *       The pet instance to be added. Must be non‑null and have a non‑empty name.
   * Output:
   *   - boolean
   *       true  – the pet was successfully added.
   *       false – the pet is null, has no name, or already belongs to a house.
   * Pre‑condition:
   *   - The House instance exists and its internal list `pets` is initialized.
   * Post‑condition:
   *   - If true is returned, `pet` is contained in `this.pets` and `pet.home` references this House.
   *   - If false is returned, the state of `this.pets` and `pet.home` remains unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean addPet(final Pet pet)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Removes a specified Pet from this House.
   * Algorithm:
   *   1. If pet is null, return false.
   *   2. Search for pet in this.pets (reference equality).
   *   3. If not found, return false.
   *   4. Remove pet from this.pets.
   *   5. Set pet.home = null.
   *   6. Return true.
   * Input:
   *   - pet: Pet
   *       The pet instance that should be removed from this house.
   * Output:
   *   - boolean
   *       true  – the pet was found in this house and removed.
   *       false – the pet was not found in this house or null.
   * Pre‑condition:
   *   - The House instance exists and its internal list `pets` is initialized.
   * Post‑condition:
   *   - If true is returned, `pet` is no longer present in `this.pets` and its `home` reference is null.
   *   - If false is returned, the collection `this.pets` and `pet.home` remain unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void removePet(final Pet pet)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves a list of pets of the specified type ("dog" or "cat") that live in this House.
   * Algorithm:
   *   1. Normalize `type` to lower case.
   *   2. If type is not "dog" and not "cat", return an empty list.
   *   3. Create an empty List<Pet> result.
   *   4. Iterate over each pet in this.pets:
   *        a. If type == "dog" and pet instanceof Dog, add pet to result.
   *        b. If type == "cat" and pet instanceof Cat, add pet to result.
   *   5. Return result.
   * Input:
   *   - type: String
   *       Expected values: "dog" or "cat" (case‑insensitive). Any other string yields an empty list.
   * Output:
   *   - List<Pet>
   *       A list containing all pets of the requested type; empty if none or if `type` is invalid.
   * Pre‑condition:
   *   - The House instance exists and its internal list `pets` is initialized.
   * Post‑condition:
   *   - The House and its pets are not modified.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<Pet> getPetsByType(final String type)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns the number of pets of a specific type ("dog" or "cat") living in this House.
   * Algorithm:
   *  . Normalize `type` to lower case.
   *   2. If type is "dog" and not "cat", return 0.
   *   3. Initialise counter = 0.
   *   4. Iterate over each pet in this.pets:
   *        a. If type == "dog" and pet is instance of Dog, increment counter.
   *        b. If type == "cat" and pet is instance of Cat, increment counter.
   *   5. Return counter.
   * Input:
   *   - type: String
   *       Expected values: "dog" or "cat" (case‑insensitive). Any other value yields 0.
   * Output:
   *   - int
   *       The count of pets of the requested type; 0 if none or if `type` is invalid.
   * Pre‑condition:
   *   - The House instance exists and its internal list `pets` is initialized.
   * Post‑condition:
   *   - The state of the House and its pets remains unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int getPetCount(final String type)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // House
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Pet` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Public methods: public void makeNoise()
  + Getter methods: public String getName()
  + Setter methods: public void setName(String newName)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getPets <em>Pets</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Pet> pets;

  protected House()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Pet> getPets()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns a list of the names of all pets (dogs and cats) residing in this House.
   * Algorithm:
   *   1. Create an empty List<String> names.
   *   2. For each pet in this.pets:
   *        a. If pet.name is non‑null, add pet.name to names.
   *   3. Return names.
   * Input:
   *   - (none)
   * Output:
   *   - List<String>
   *       A list of pet names; empty if the house has no pets.
   * Pre‑condition:
   *   - House instance exists and its internal list `pets` is.
   * Post‑condition:
   *   - The House and its pet remain unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> retrievePetNames()
  {
    BasicEList<String> names = new BasicEList<>();
    if (pets != null) {
      for (Pet pet : pets {
        String name = pet.getName();
        if (name != null) {
          names.add(name);
        }
      }
    }
    names;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Adds a given Pet (Dog or Cat) to this House.
   * Algorithm:
   * . If pet is null, return false.
   *   2. If pet.name is null or empty, return false.
   *   3. If pet already has a home (pet.home != null), return false.
   *   4. Append pet to this.pets.
   *   5. Set pet.home = this.
   *   6. Return true.
   * Input:
   *   - pet: Pet
   *       The pet instance to be added. Must be non‑null and have a non‑empty name.
   * Output:
   *   - boolean
   *       true  – the pet was successfully added.
   *       false – the pet is null, has no name, or already belongs to a house.
   * Pre‑condition:
   *   - The House instance exists and its internal list `pets` is initialized.
   * Post‑condition:
   *   - If true is returned, `pet` is contained in `this.pets` and `pet.home` references this House.
   *   - If false is returned, the state of `this.pets` and `pet.home` remains unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean addPet(final Pet pet)
  {
    if (pet == null) {
      return false;
    }
    String name = pet.getName();
    if (name == null || name.isEmpty()) {
      return false;
    }
    // In EMF, a containment reference means the container is the eContainer of the object.
    // If the pet already has a container (i.e., a home), we must not add it again.
    if (pet.eContainer() != null) {
      return false;
    }
    if (pets == null) {
      pets = new EObjectContainmentEList<>(Pet.class, this, PetsPackage.HOUSE__PETS);
    }
    pets.add(pet);
    // The containment relationship automatically sets the eContainer (home) of the pet.
    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Removes a specified Pet from this House.
   * Algorithm:
   *   1. If pet is null, return false.
   *   2. Search for pet in this.pets (reference equality).
   *   3. If not found, return false.
   *   4. Remove pet from this.pets.
   *   5. Set pet.home = null.
   *   6. Return true.
   * Input:
   *   - pet: Pet
   *       The pet instance that should be removed from this house.
   * Output:
   *   - boolean
   *       true  – the pet was found in this house and removed.
   *       false – the pet was not found in this house or null.
   * Pre‑condition:
   *   - The House instance exists and its internal list `pets` is initialized.
   * Post‑condition:
   *   - If true is returned, `pet` is no longer present in `this.pets` and its `home` reference is null.
   *   - If false is returned, the collection `this.pets` and `pet.home` remain unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void removePet(final Pet pet)
  {
    if (pet == null) {
      return;
    }
    if (pets != null && pets.contains(pet)) {
      pets.remove(pet);
      // Removal from the containment list clears the pet's container (home) automatically.
    }
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves a list of pets of the specified type ("dog" orcat") that live in this House.
   * Algorithm:
   *   1. Normalize `type` to lower case.
   *   2. If type is not "dog" and not "cat", return an empty list.
   *   3. Create an empty List<Pet> result.
   *   4. Iterate over each pet in this.pets:
   *        a. If type == "dog" and pet instanceof Dog, add pet to result.
   *        b. If type == "cat" and pet instanceof Cat, add pet to result.
   *   5. Return result.
   * Input:
   *   - type: String
   *       Expected values: "dog" or "cat (case‑insensitive). Any other string yields an empty list.
   * Output:
   *   - List<Pet>
   *       A list containing all pets of the requested type; empty if none or if `type` is invalid.
   * Pre‑condition:
   *   - The House instance exists and its internal list `pets` is initialized.
   * Post‑condition:
   *   - The House and its pets are not modified.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Pet> getPetsByType(final String type)
  {
    BasicEList<Pet> result = new BasicEList<>();
    if (type == null) {
      return result;
    }
    String norm = type.toLowerCase();
    if (!"dog".equals(norm) && !"cat".equals(norm)) {
      return result;
    }
    if (pets != null) {
      for (Pet pet : pets) {
        if ("dog".equals(norm) && pet instanceof Dog) {
          result.add(pet);
        } else if ("cat".equals(norm) && pet instanceof Cat) {
          result.add(pet);
        }
      }
    }
    return result;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns the number of pets of a specific type ("dog" or "cat") living in this House.
   * Algorithm:
   *  . Normalize `type` to lower case.
   *   2. If type is "dog" and not "cat", return 0.
   *   3. Initialise counter = 0.
   *   4. Iterate over each pet in this.pets:
   *        a. If type == "dog" and pet is instance of Dog, increment counter.
   *        b. If type == "cat" and pet is instance of Cat, increment counter.
   *   5. Return counter.
   * Input:
   *   - type: String
   *       Expected values: "dog" or "cat" (case‑insensitive). Any other value yields 0.
   * Output:
   *   - int
   *       The count of pets of the requested type; 0 if none or if `type` is invalid.
   * Pre‑condition:
   *   - The House instance exists and its internal list `pets` is initialized.
   * Post‑condition:
   *   - The state of the House and its pets remains unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
 @generated NOT
   */
  public int getPetCount(final String type)
  {
    if (type == null) {
      return 0;
    }
    String norm = type.toLowerCase();
    if (!"dog".equals(norm) && !"cat".equals(norm)) {
      return 0;
    }
    int count = 0;
    if (pets != null) {
      for (Pet pet : pets) {
        if ("dog".equals(norm) && pet instanceof Dog) {
          count++;
        } else if ("cat".equals(norm) && pet instanceof Cat) {
          count++;
        }
      }
    }
    return count;
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // House
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Causes the animal to emit its characteristic sound.
   * Algorithm (abstract):
   *   - Sub‑classes must implement this method to produce the appropriate noise.
   * Input:
   *   - (none)
   * Output:
   *   - (none) – side effect is an audible or logged noise.
   * Pre‑condition:
   *   - The Pet instance exists.
   * Post‑condition:
   *   - The specific noise associated with the concrete subclass is produced.
   * Note:
   *   - Dog implementation: prints or logs "Woof!".
   *   - Cat implementation: prints or logs "Meow!".
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void makeNoise()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<emb>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { /* omitted */ }

  public String getName()
  { /* omitted */ }

  public void setName(String newName)
  { /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Causes the animal to emit its characteristic sound.
   * Algorithm (abstract):
   *   - Sub‑classes must implement this method to produce the appropriate noise.
   * Input:
   *   - (none)
   * Output:
   *   - (none) – side effect is an audible or logged noise.
   * Pre‑condition:
   *   - The Pet instance exists.
   * Post‑condition:
   *   - The specific noise associated with the concrete subclass is produced.
   * Note:
   *   - Dog implementation: prints or logs "Woof!".
   *   - Cat implementation: prints or logs "Meow!".
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void makeNoise()
  {
    // Default implementation does nothing.
    // Sub‑classes should override this method to emit the appropriate sound.
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { /* omitted */ }

  @Override
  public String toString()
  { /* omitted */ }

} // Pet
304433 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../Pets/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../Pets/src-gen/edu/pets/
304521 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
304521 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - ----------
1. ERROR in D:\EclipseWorkspace\Pets\src-gen\edu\pets\House.java (at line 118)
	for (Pet pet : pets {
	               ^^^^
Syntax error, insert ")" to complete EnhancedForStatementHeader
----------
2. ERROR in D:\EclipseWorkspace\Pets\src-gen\edu\pets\House.java (at line 125)
	names;
	^^^^^
Syntax error, insert "VariableDeclarators" to complete LocalVariableDeclaration
----------
2 problems (2 errors)

304522 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - File: D:\EclipseWorkspace\Pets\src-gen\edu\pets\House.java
Line: 118
Type: ERROR
Message: Syntax error, insert ")" to complete EnhancedForStatementHeader
Code line: 	for (Pet pet : pets {
Caret Pos: 	               ^^^^

304522 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - File: D:\EclipseWorkspace\Pets\src-gen\edu\pets\House.java
Line: 125
Type: ERROR
Message: Syntax error, insert "VariableDeclarators" to complete LocalVariableDeclaration
Code line: 	names;
Caret Pos: 	^^^^^

# Task
You will be given a **Java Class** that is originally generated by EMF code generator with `suppressInterfaces=true` and later is completed by LLMs. Your task is to fix the **Compilation Errors** by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. Read the error messages carefully.
2. Do your best to fix the errors locally without introducing new types, fields, and methods.
3. You should not remove faulty methods to eliminate compilation errors.
4. Do not change parts without errors.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;
import org.eclipse.emf.common.util.BasicEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getPets <em>Pets</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Pet> pets;

  protected House()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Pet> getPets()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns a list of the names of all pets (dogs and cats) residing in this House.
   * Algorithm:
   *   1. Create an empty List<String> names.
   *   2. For each pet in this.pets:
   *        a. If pet.name is non‑null, add pet.name to names.
   *   3. Return names.
   * Input:
   *   - (none)
   * Output:
   *   - List<String>
   *       A list of pet names; empty if the house has no pets.
   * Pre‑condition:
   *   - The House instance exists and its internal list `pets` is initialized.
   * Post‑condition:
   *   - The House and its pet collection remain unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> retrievePetNames()
  {
    BasicEList<String> names = new BasicEList<>();
    if (pets != null) {
      for (Pet pet : pets {
        String name = pet.getName();
        if (name != null) {
          names.add(name);
        }
      }
    }
    names;
  }

  public boolean addPet(final Pet pet)
  { ... /* omitted */ }

  public void removePet(final Pet pet)
  { ... /* omitted */ }

  public EList<Pet> getPetsByType(final String type)
  { ... /* omitted */ }

  public int getPetCount(final String type)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // House
```

# Compilation Errors
```
- ERROR: Syntax error, insert ")" to complete EnhancedForStatementHeader
	for (Pet pet : pets {
	               ^^^^

- ERROR: Syntax error, insert "VariableDeclarators" to complete LocalVariableDeclaration
	names;
	^^^^^
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Pet` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Public methods: public void makeNoise()
  + Getter methods: public String getName()
  + Setter methods: public void setName(String newName)

# Output Format
Just put the Java class you fixed into a single block as follows.

```result
(fixed Java class)
```

fixed code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;
import org.eclipse.emf.common.util.BasicEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getPets <em>Pets</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Pet> pets;

  protected House()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Pet> getPets()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns a list of the names of all pets (dogs and cats) residing in this House.
   * Algorithm:
   *   1. Create an empty List<String> names.
   *   2. For each pet in this.pets:
   *        a. If pet.name is non‑null, add pet.name to names.
   *   3. Return names.
   * Input:
   *   - (none)
   * Output:
   *   - List<String>
   *       A list of pet names; empty if the house has no pets.
   * Pre‑condition:
   *   - The House instance exists and its internal list `pets` is initialized.
   * Post‑condition:
   *   - The House and its pet collection remain unchanged.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> retrievePetNames()
  {
    BasicEList<String> names = new BasicEList<>();
    if (pets != null) {
      for (Pet pet : pets) {
        String name = pet.getName();
        if (name != null) {
          names.add(name);
        }
      }
    }
    return names;
  }

  public boolean addPet(final Pet pet)
  { ... /* omitted */ }

  public void removePet(final Pet pet)
  { ... /* omitted */ }

  public EList<Pet> getPetsByType(final String type)
  { /* omitted */ }

  public int getPetCount(final String type)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // House
311074 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../Pets/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../Pets/src-gen/edu/pets/
311152 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
311152 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
311152 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
311152 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
311153 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample5.mwe2 启动完成
正在拷贝 src-gen/edu/pets 到 gpt-oss-120b/pets5...
拷贝完成！

======================================
所有任务完成！
======================================

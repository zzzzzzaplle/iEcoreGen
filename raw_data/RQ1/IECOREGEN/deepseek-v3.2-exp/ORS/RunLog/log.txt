   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int calculateMonthlyPoints(final Customer customer, final String currentMonth)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Attempts to reserve specified number of seats on the trip
   * Algorithm:
   *   IF num <= numberOfSeats AND num > 0
   *     numberOfSeats = numberOfSeats - num
   *     RETURN true
   *   ELSE
   *     RETURN false
   * Input: num : int - number of seats to book (must be positive)
   * Output: boolean - true if seats successfully reserved, false otherwise
   * Pre-condition: Trip must have available seats
   * Post-condition: Available seats reduced if successful
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean bookSeats(final int num)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Finalizes booking by reserving seats and updating trip status
   * Algorithm:
   *   IF seats <= numberOfSeats AND seats > 0
   *     numberOfSeats = numberOfSeats - seats
   *     RETURN true
   *   ELSE
   *     RETURN false
   * Input: seats : int - number of seats to confirm
   * Output: boolean - true if booking confirmed, false otherwise
   * Pre-condition: Booking must be pre-validated
   * Post-condition: Available seats reduced if confirmed
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean confirmBooking(final int seats)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Returns list of all stop station names including departure and arrival
   * Algorithm:
   *   stations = new List<String>()
   *   stations.add(departureStation)
   *   FOR each stop in stops
   *     stations.add(stop.stopStation)
   *   stations.add(arrivalStation)
   *   RETURN stations
   * Input: None
   * Output: List<String> - ordered list of all station names
   * Pre-condition: Stops list must be initialized
   * Post-condition: No state changes
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<String> getStopStations()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Checks if proposed time window conflicts with this trip's schedule
   * Algorithm:
   *   RETURN (newDepartureTime < this.arrivalTime AND newArrivalTime > this.departureTime)
   * Input:
   *   newDepartureTime : String - proposed departure time in "HH:MM" format
   *   newArrivalTime : String - proposed arrival time in "HH:MM" format
   * Output: boolean - true if time windows overlap, false otherwise
   * Pre-condition: Time strings must be in valid format
   * Post-condition: No state changes
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean isTimeConflicting(final String newDepartureTime, final String newArrivalTime)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Trip
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Booking` contains the following methods.
  + Instance creation: Use `RideshareFactory.eINSTANCE.createBooking()`
  + Public methods: public boolean isBookingEligible(), public void updateTripSeats(), public boolean overlapsWith(final Trip trip)
  + Getter methods: public int getNumberOfSeats(), public Date getBookingDate(), public Customer getCustomer(), public Trip getTrip()
  + Setter methods: public void setNumberOfSeats(int newNumberOfSeats), public void setBookingDate(Date newBookingDate), public void setCustomer(Customer newCustomer), public void setTrip(Trip newTrip)
- Class `Stop` contains the following methods.
  + Instance creation: Use `RideshareFactory.eINSTANCE.createStop()`
  + Getter methods: public String getStopStation(), public Trip getTrip()
  + Setter methods: public void setStopStation(String newStopStation), public void setTrip(Trip newTrip)
- Class `Driver` contains the following methods.
  + Instance creation: Use `RideshareFactory.eINSTANCE.createDriver()`
  + Public methods: public boolean checkStopOverlap(final Trip trip1, final Trip trip2), public boolean canPostTrip(final Trip newtrip)
  + Getter methods: , , , public EList<Trip> getTrips()
  + Setter methods: , , 
- Class `Customer` contains the following methods.
  + Instance creation: Use `RideshareFactory.eINSTANCE.createCustomer()`
  + Public methods: public int computeMonthlyRewardPoints(final String currentMonth), public void bookTrip(final Trip trip, final int numberOfSeats)
  + Getter methods: , , , public MembershipPackage getMembershipPackage(), public EList<Booking> getBookings()
  + Setter methods: , , , public void setMembershipPackage(MembershipPackage newMembershipPackage)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.rideshare;

import java.util.Collection;
import java.util.Date;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.BasicEList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Trip</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.rideshare.Trip#getDepartureStation <em>Departure Station</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getArrivalStation <em>Arrival Station</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getDepartureTime <em>Departure Time</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getArrivalTime <em>Arrival Time</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getNumberOfSeats <em>Number Of Seats</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getDepartureDate <em>Departure Date</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getPrice <em>Price</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getBookings <em>Bookings</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getStops <em>Stops</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getDriver <em>Driver</em>}</li>
 * </ul>
 *
 * @see edu.rideshare.RidesharePackage#getTrip()
 * @model kind="class"
 * @generated
 */
public class Trip extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String DEPARTURE_STATION_EDEFAULT = null;

  protected String departureStation = DEPARTURE_STATION_EDEFAULT;

  protected static final String ARRIVAL_STATION_EDEFAULT = null;

  protected String arrivalStation = ARRIVAL_STATION_EDEFAULT;

  protected static final String DEPARTURE_TIME_EDEFAULT = null;

  protected String departureTime = DEPARTURE_TIME_EDEFAULT;

  protected static final String ARRIVAL_TIME_EDEFAULT = null;

  protected String arrivalTime = ARRIVAL_TIME_EDEFAULT;

  protected static final int NUMBER_OF_SEATS_EDEFAULT = 0;

  protected int numberOfSeats = NUMBER_OF_SEATS_EDEFAULT;

  protected static final Date DEPARTURE_DATE_EDEFAULT = null;

  protected Date departureDate = DEPARTURE_DATE_EDEFAULT;

  protected static final double PRICE_EDEFAULT = 0.0;

  protected double price = PRICE_EDEFAULT;

  protected EList<Booking> bookings;

  protected EList<Stop> stops;

  protected Trip()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getDepartureStation()
  { ... /* omitted */ }

  public void setDepartureStation(String newDepartureStation)
  { ... /* omitted */ }

  public String getArrivalStation()
  { ... /* omitted */ }

  public void setArrivalStation(String newArrivalStation)
  { ... /* omitted */ }

  public String getDepartureTime()
  { ... /* omitted */ }

  public void setDepartureTime(String newDepartureTime)
  { ... /* omitted */ }

  public String getArrivalTime()
  { ... /* omitted */ }

  public void setArrivalTime(String newArrivalTime)
  { ... /* omitted */ }

  public int getNumberOfSeats()
  { ... /* omitted */ }

  public void setNumberOfSeats(int newNumberOfSeats)
  { ... /* omitted */ }

  public Date getDepartureDate()
  { ... /* omitted */ }

  public void setDepartureDate(Date newDepartureDate)
  { ... /* omitted */ }

  public double getPrice()
  { ... /* omitted */ }

  public void setPrice(double newPrice)
  { ... /* omitted */ }

  public EList<Booking> getBookings()
  { ... /* omitted */ }

  public EList<Stop> getStops()
  { ... /* omitted */ }

  public Driver getDriver()
  { ... /* omitted */ }

  public NotificationChain basicSetDriver(Driver newDriver, NotificationChain msgs)
  { ... /* omitted */ }

  public void setDriver(Driver newDriver)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates final price for customer after applying membership discounts
   * Algorithm:
   *   basePrice = this.price
   *   discountRate = 0.0
   *   IF customer.membershipPackage.hasAward(DISCOUNTS)
   *     discountRate = 0.1  // 10% discount for members
   *   finalPrice = basePrice * (1 - discountRate)
   *   RETURN finalPrice
   * Input: 
   *   customer : Customer - the customer requesting price
   *   bookingTime : String - time of booking (for potential time-based discounts)
   * Output: double - discounted price (rounded to 2 decimal places)
   * Pre-condition: Customer must have valid membership package
   * Post-condition: No state changes
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateDiscountedPrice(final Customer customer, final String bookingTime)
  {
    double basePrice = this.price;
    double discountRate = 0.0;
    
    if (customer.getMembershipPackage() != null && customer.getMembershipPackage().hasAward("DISCOUNTS")) {
      discountRate = 0.1;
    }
    
    double finalPrice = basePrice * (1 - discountRate);
    return Math.round(finalPrice * 100.0) / 100.0;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates reward points earned for this trip in specified month
   * Algorithm:
   *   points = 0
   *   IF trip.departureDate.month = currentMonth
   *     basePoints = this.price * 0.01  // 1 point per dollar spent
   *     IF customer.membershipPackage.hasAward(POINTS)
   *       bonusMultiplier = 1.5  // 50% bonus for members
   *       points = basePoints * bonusMultiplier
   *     ELSE
   *       points = basePoints
   *   RETURN floor(points)
   * Input:
   *   customer : Customer - the customer earning points
   *   currentMonth : String - month in "YYYY-MM" format
   * Output: int - reward points earned (rounded down)
   * Pre-condition: Trip must have valid price and departure date
   * Post-condition: No state changes
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateMonthlyPoints(final Customer customer, final String currentMonth)
  {
    if (this.departureDate == null) {
      return 0;
    }
    
    String tripMonth = String.format("%tY-%tm", this.departureDate, this.departureDate);
    if (!tripMonth.equals(currentMonth)) {
      return 0;
    }
    
    double basePoints = this.price * 0.01;
    double points = basePoints;
    
    if (customer.getMembershipPackage() != null && customer.getMembershipPackage().hasAward("POINTS")) {
      double bonusMultiplier = 1.5;
      points = basePoints * bonusMultiplier;
    }
    
    return (int) Math.floor(points);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Attempts to reserve specified number of seats on the trip
   * Algorithm:
   *   IF num <= numberOfSeats AND num > 0
   *     numberOfSeats = numberOfSeats - num
   *     RETURN true
   *   ELSE
   *     RETURN false
   * Input: num : int - number of seats to book (must be positive)
   * Output: boolean - true if seats successfully reserved, false otherwise
   * Pre-condition: Trip must have available seats
   * Post-condition: Available seats reduced if successful
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean bookSeats(final int num)
  {
    if (num <= this.numberOfSeats && num > 0) {
      this.numberOfSeats = this.numberOfSeats - num;
      return true;
    } else {
      return false;
    }
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Finalizes booking by reserving seats and updating trip status
   * Algorithm:
   *   IF seats <= numberOfSeats AND seats > 0
   *     numberOfSeats = numberOfSeats - seats
   *     RETURN true
   *   ELSE
   *     RETURN false
   * Input: seats : int - number of seats to confirm
   * Output: boolean - true if booking confirmed, false otherwise
   * Pre-condition: Booking must be pre-validated
   * Post-condition: Available seats reduced if confirmed
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean confirmBooking(final int seats)
  {
    if (seats <= this.numberOfSeats && seats > 0) {
      this.numberOfSeats = this.numberOfSeats - seats;
      return true;
    } else {
      return false;
    }
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Returns list of all stop station names including departure and arrival
   * Algorithm:
   *   stations = new List<String>()
   *   stations.add(departureStation)
   *   FOR each stop in stops
   *     stations.add(stop.stopStation)
   *   stations.add(arrivalStation)
   *   RETURN stations
   * Input: None
   * Output: List<String> - ordered list of all station names
   * Pre-condition: Stops list must be initialized
   * Post-condition: No state changes
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> getStopStations()
  {
    EList<String> stations = new BasicEList<String>();
    stations.add(this.departureStation);
    
    if (this.stops != null) {
      for (Stop stop : this.stops) {
        stations.add(stop.getStopStation());
      }
    }
    
    stations.add(this.arrivalStation);
    return stations;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Checks if proposed time window conflicts with this trip's schedule
   * Algorithm:
   *   RETURN (newDepartureTime < this.arrivalTime AND newArrivalTime > this.departureTime)
   * Input:
   *   newDepartureTime : String - proposed departure time in "HH:MM" format
   *   newArrivalTime : String - proposed arrival time in "HH:MM" format
   * Output: boolean - true if time windows overlap, false otherwise
   * Pre-condition: Time strings must be in valid format
   * Post-condition: No state changes
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean isTimeConflicting(final String newDepartureTime, final String newArrivalTime)
  {
    return newDepartureTime.compareTo(this.arrivalTime) < 0 && newArrivalTime.compareTo(this.departureTime) > 0;
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Trip
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.rideshare;

import java.util.Date;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Booking</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.rideshare.Booking#getNumberOfSeats <em>Number Of Seats</em>}</li>
 *   <li>{@link edu.rideshare.Booking#getBookingDate <em>Booking Date</em>}</li>
 *   <li>{@link edu.rideshare.Booking#getCustomer <em>Customer</em>}</li>
 *   <li>{@link edu.rideshare.Booking#getTrip <em>Trip</em>}</li>
 * </ul>
 *
 * @see edu.rideshare.RidesharePackage#getBooking()
 * @model kind="class"
 * @generated
 */
public class Booking extends MinimalEObjectImpl.Container implements EObject
{
  protected static final int NUMBER_OF_SEATS_EDEFAULT = 0;

  protected int numberOfSeats = NUMBER_OF_SEATS_EDEFAULT;

  protected static final Date BOOKING_DATE_EDEFAULT = null;

  protected Date bookingDate = BOOKING_DATE_EDEFAULT;

  protected Customer customer;

  protected Booking()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public int getNumberOfSeats()
  { ... /* omitted */ }

  public void setNumberOfSeats(int newNumberOfSeats)
  { ... /* omitted */ }

  public Date getBookingDate()
  { ... /* omitted */ }

  public void setBookingDate(Date newBookingDate)
  { ... /* omitted */ }

  public Customer getCustomer()
  { ... /* omitted */ }

  public Customer basicGetCustomer()
  { ... /* omitted */ }

  public NotificationChain basicSetCustomer(Customer newCustomer, NotificationChain msgs)
  { ... /* omitted */ }

  public void setCustomer(Customer newCustomer)
  { ... /* omitted */ }

  public Trip getTrip()
  { ... /* omitted */ }

  public NotificationChain basicSetTrip(Trip newTrip, NotificationChain msgs)
  { ... /* omitted */ }

  public void setTrip(Trip newTrip)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Validates if the booking meets all eligibility criteria including available seats, no time conflicts, and customer membership validity
   * Algorithm:
   *   1. Check if requested seats <= trip.availableSeats
   *   2. Check if booking doesn't overlap with customer's existing bookings
   *   3. Check if customer has valid membership package
   *   4. Return true only if all conditions are met
   * Input: None (uses instance attributes: numberOfSeats, customer, trip)
   * Output: boolean - true if booking is eligible, false otherwise
   * Pre-condition: Booking must be initialized with valid customer and trip references
   * Post-condition: No state changes - pure validation function
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean isBookingEligible()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Updates the available seats in the associated trip after booking confirmation
   * Algorithm:
   *   trip.numberOfSeats = trip.numberOfSeats - this.numberOfSeats
   * Input: None
   * Output: void
   * Pre-condition: Booking must be confirmed and numberOfSeats must be valid
   * Post-condition: Trip's available seats are reduced by booked seats
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void updateTripSeats()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Checks if this booking's trip overlaps with another given trip in time and route
   * Algorithm:
   *   1. Compare departure and arrival stations between trips
   *   2. Check if time windows overlap using trip time comparison
   *   3. Return true if both route and time overlap
   * Input: trip : Trip - the trip to check for overlap with
   * Output: boolean - true if trips overlap, false otherwise
   * Pre-condition: Both trips must have valid departure/arrival times and stations
   * Post-condition: No state changes
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean overlapsWith(final Trip trip)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Booking
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Customer` contains the following methods.
  + Instance creation: Use `RideshareFactory.eINSTANCE.createCustomer()`
  + Public methods: public int computeMonthlyRewardPoints(final String currentMonth), public void bookTrip(final Trip trip, final int numberOfSeats)
  + Getter methods: , , , public MembershipPackage getMembershipPackage(), public EList<Booking> getBookings()
  + Setter methods: , , , public void setMembershipPackage(MembershipPackage newMembershipPackage)
- Class `Trip` contains the following methods.
  + Instance creation: Use `RideshareFactory.eINSTANCE.createTrip()`
  + Public methods: public double calculateDiscountedPrice(final Customer customer, final String bookingTime), public int calculateMonthlyPoints(final Customer customer, final String currentMonth), public boolean bookSeats(final int num), public boolean confirmBooking(final int seats), public EList<String> getStopStations(), public boolean isTimeConflicting(final String newDepartureTime, final String newArrivalTime)
  + Getter methods: public String getDepartureStation(), public String getArrivalStation(), public String getDepartureTime(), public String getArrivalTime(), public int getNumberOfSeats(), public Date getDepartureDate(), public double getPrice(), public EList<Booking> getBookings(), public EList<Stop> getStops(), public Driver getDriver()
  + Setter methods: public void setDepartureStation(String newDepartureStation), public void setArrivalStation(String newArrivalStation), public void setDepartureTime(String newDepartureTime), public void setArrivalTime(String newArrivalTime), public void setNumberOfSeats(int newNumberOfSeats), public void setDepartureDate(Date newDepartureDate), public void setPrice(double newPrice), public void setDriver(Driver newDriver)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.rideshare;

import java.util.Date;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;
import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;
import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Booking</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.rideshare.Booking#getNumberOfSeats <em>Number Of Seats</em>}</li>
 *   <li>{@link edu.rideshare.Booking#getBookingDate <em>Booking Date</em>}</li>
 *   <li>{@link edu.rideshare.Booking#getCustomer <em>Customer</em>}</li>
 *   <li>{@link edu.rideshare.Booking#getTrip <em>Trip</em>}</li>
 * </ul>
 *
 * @see edu.rideshare.RidesharePackage#getBooking()
 * @model kind="class"
 * @generated
 */
public class Booking extends MinimalEObjectImpl.Container implements EObject
{
  protected static final int NUMBER_OF_SEATS_EDEFAULT = 0;

  protected int numberOfSeats = NUMBER_OF_SEATS_EDEFAULT;

  protected static final Date BOOKING_DATE_EDEFAULT = null;

  protected Date bookingDate = BOOKING_DATE_EDEFAULT;

  protected Customer customer;

  protected Booking()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public int getNumberOfSeats()
  { ... /* omitted */ }

  public void setNumberOfSeats(int newNumberOfSeats)
  { ... /* omitted */ }

  public Date getBookingDate()
  { ... /* omitted */ }

  public void setBookingDate(Date newBookingDate)
  { ... /* omitted */ }

  public Customer getCustomer()
  { ... /* omitted */ }

  public Customer basicGetCustomer()
  { ... /* omitted */ }

  public NotificationChain basicSetCustomer(Customer newCustomer, NotificationChain msgs)
  { ... /* omitted */ }

  public void setCustomer(Customer newCustomer)
  { ... /* omitted */ }

  public Trip getTrip()
  { ... /* omitted */ }

  public NotificationChain basicSetTrip(Trip newTrip, NotificationChain msgs)
  { ... /* omitted */ }

  public void setTrip(Trip newTrip)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Validates if the booking meets all eligibility criteria including available seats, no time conflicts, and customer membership validity
   * Algorithm:
   *   1. Check if requested seats <= trip.availableSeats
   *   2. Check if booking doesn't overlap with customer's existing bookings
   *   3. Check if customer has valid membership package
   *   4. Return true only if all conditions are met
   * Input: None (uses instance attributes: numberOfSeats, customer, trip)
   * Output: boolean - true if booking is eligible, false otherwise
   * Pre-condition: Booking must be initialized with valid customer and trip references
   * Post-condition: No state changes - pure validation function
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean isBookingEligible()
  {
    // Check if requested seats <= trip.availableSeats
    if (numberOfSeats > getTrip().getNumberOfSeats()) {
      return false;
    }
    
    // Check if booking doesn't overlap with customer's existing bookings
    EList<Booking> customerBookings = getCustomer().getBookings();
    for (Booking existingBooking : customerBookings) {
      if (existingBooking != this && existingBooking.overlapsWith(getTrip())) {
        return false;
      }
    }
    
    // Check if customer has valid membership package
    if (getCustomer().getMembershipPackage() == null) {
      return false;
    }
    
    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Updates the available seats in the associated trip after booking confirmation
   * Algorithm:
   *   trip.numberOfSeats = trip.numberOfSeats - this.numberOfSeats
   * Input: None
   * Output: void
   * Pre-condition: Booking must be confirmed and numberOfSeats must be valid
   * Post-condition: Trip's available seats are reduced by booked seats
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void updateTripSeats()
  {
    Trip trip = getTrip();
    int currentSeats = trip.getNumberOfSeats();
    trip.setNumberOfSeats(currentSeats - numberOfSeats);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Checks if this booking's trip overlaps with another given trip in time and route
   * Algorithm:
   *   1. Compare departure and arrival stations between trips
   *   2. Check if time windows overlap using trip time comparison
   *   3. Return true if both route and time overlap
   * Input: trip : Trip - the trip to check for overlap with
   * Output: boolean - true if trips overlap, false otherwise
   * Pre-condition: Both trips must have valid departure/arrival times and stations
   * Post-condition: No state changes
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean overlapsWith(final Trip trip)
  {
    Trip currentTrip = getTrip();
    
    // Compare departure and arrival stations between trips
    if (!currentTrip.getDepartureStation().equals(trip.getDepartureStation()) || 
        !currentTrip.getArrivalStation().equals(trip.getArrivalStation())) {
      return false;
    }
    
    // Check if time windows overlap using trip time comparison
    return currentTrip.isTimeConflicting(trip.getDepartureTime(), trip.getArrivalTime());
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Booking
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.rideshare;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EDataTypeUniqueEList;
import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Membership Package</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.rideshare.MembershipPackage#getAwards <em>Awards</em>}</li>
 *   <li>{@link edu.rideshare.MembershipPackage#getCustomer <em>Customer</em>}</li>
 * </ul>
 *
 * @see edu.rideshare.RidesharePackage#getMembershipPackage()
 * @model kind="class"
 * @generated
 */
public class MembershipPackage extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Award> awards;

  protected MembershipPackage()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Award> getAwards()
  { ... /* omitted */ }

  public Customer getCustomer()
  { ... /* omitted */ }

  public NotificationChain basicSetCustomer(Customer newCustomer, NotificationChain msgs)
  { ... /* omitted */ }

  public void setCustomer(Customer newCustomer)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Checks if membership package includes specified award type
   * Algorithm:
   *   RETURN awards.contains(award)
   * Input: award : Award - the award type to check (CASHBACK, DISCOUNTS, or POINTS)
   * Output: boolean - true if award is included in package
   * Pre-condition: Awards list must be initialized
   * Post-condition: No state changes
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean hasAward(final Award award)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // MembershipPackage
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Customer` contains the following methods.
  + Instance creation: Use `RideshareFactory.eINSTANCE.createCustomer()`
  + Public methods: public int computeMonthlyRewardPoints(final String currentMonth), public void bookTrip(final Trip trip, final int numberOfSeats)
  + Getter methods: , , , public MembershipPackage getMembershipPackage(), public EList<Booking> getBookings()
  + Setter methods: , , , public void setMembershipPackage(MembershipPackage newMembershipPackage)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.rideshare;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EDataTypeUniqueEList;
import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Membership Package</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.rideshare.MembershipPackage#getAwards <em>Awards</em>}</li>
 *   <li>{@link edu.rideshare.MembershipPackage#getCustomer <em>Customer</em>}</li>
 * </ul>
 *
 * @see edu.rideshare.RidesharePackage#getMembershipPackage()
 * @model kind="class"
 * @generated
 */
public class MembershipPackage extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Award> awards;

  protected MembershipPackage()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Award> getAwards()
  { ... /* omitted */ }

  public Customer getCustomer()
  { ... /* omitted */ }

  public NotificationChain basicSetCustomer(Customer newCustomer, NotificationChain msgs)
  { ... /* omitted */ }

  public void setCustomer(Customer newCustomer)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Checks if membership package includes specified award type
   * Algorithm:
   *   RETURN awards.contains(award)
   * Input: award : Award - the award type to check (CASHBACK, DISCOUNTS, or POINTS)
   * Output: boolean - true if award is included in package
   * Pre-condition: Awards list must be initialized
   * Post-condition: No state changes
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean hasAward(final Award award)
  {
    return getAwards().contains(award);
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // MembershipPackage
2128888 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../ORS/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../ORS/src-gen/edu/rideshare/
2129047 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
2129047 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - ----------
1. ERROR in D:\EclipseWorkspace\ORS\src-gen\edu\rideshare\Customer.java (at line 224)
	booking.setBookingDate(new Date()); // Use current date
	                           ^^^^
Date cannot be resolved to a type
----------
----------
2. ERROR in D:\EclipseWorkspace\ORS\src-gen\edu\rideshare\Trip.java (at line 575)
	if (customer.getMembershipPackage() != null && customer.getMembershipPackage().hasAward("DISCOUNTS")) {
	                                                                               ^^^^^^^^
The method hasAward(Award) in the type MembershipPackage is not applicable for the arguments (String)
----------
3. ERROR in D:\EclipseWorkspace\ORS\src-gen\edu\rideshare\Trip.java (at line 622)
	if (customer.getMembershipPackage() != null && customer.getMembershipPackage().hasAward("POINTS")) {
	                                                                               ^^^^^^^^
The method hasAward(Award) in the type MembershipPackage is not applicable for the arguments (String)
----------
3 problems (3 errors)

2129047 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - File: D:\EclipseWorkspace\ORS\src-gen\edu\rideshare\Customer.java
Line: 224
Type: ERROR
Message: Date cannot be resolved to a type
Code line: 	booking.setBookingDate(new Date()); // Use current date
Caret Pos: 	                           ^^^^

2129047 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - File: D:\EclipseWorkspace\ORS\src-gen\edu\rideshare\Trip.java
Line: 575
Type: ERROR
Message: The method hasAward(Award) in the type MembershipPackage is not applicable for the arguments (String)
Code line: 	if (customer.getMembershipPackage() != null && customer.getMembershipPackage().hasAward("DISCOUNTS")) {
Caret Pos: 	                                                                               ^^^^^^^^

2129047 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - File: D:\EclipseWorkspace\ORS\src-gen\edu\rideshare\Trip.java
Line: 622
Type: ERROR
Message: The method hasAward(Award) in the type MembershipPackage is not applicable for the arguments (String)
Code line: 	if (customer.getMembershipPackage() != null && customer.getMembershipPackage().hasAward("POINTS")) {
Caret Pos: 	                                                                               ^^^^^^^^

# Task
You will be given a **Java Class** that is originally generated by EMF code generator with `suppressInterfaces=true` and later is completed by LLMs. Your task is to fix the **Compilation Errors** by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. Read the error messages carefully.
2. Do your best to fix the errors locally without introducing new types, fields, and methods.
3. You should not remove faulty methods to eliminate compilation errors.
4. Do not change parts without errors.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.rideshare;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;

import org.eclipse.emf.ecore.util.EObjectWithInverseResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Customer</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.rideshare.Customer#getMembershipPackage <em>Membership Package</em>}</li>
 *   <li>{@link edu.rideshare.Customer#getBookings <em>Bookings</em>}</li>
 * </ul>
 *
 * @see edu.rideshare.RidesharePackage#getCustomer()
 * @model kind="class"
 * @generated
 */
public class Customer extends User
{
  protected MembershipPackage membershipPackage;

  protected EList<Booking> bookings;

  protected Customer()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public MembershipPackage getMembershipPackage()
  { ... /* omitted */ }

  public NotificationChain basicSetMembershipPackage(MembershipPackage newMembershipPackage, NotificationChain msgs)
  { ... /* omitted */ }

  public void setMembershipPackage(MembershipPackage newMembershipPackage)
  { ... /* omitted */ }

  public EList<Booking> getBookings()
  { ... /* omitted */ }

  public int computeMonthlyRewardPoints(final String currentMonth)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Creates a new booking for a trip with specified number of seats
   * Algorithm:
   *   1. Create new Booking object
   *   2. Check booking eligibility using isBookingEligible()
   *   3. If eligible: add to bookings list, update trip seats
   *   4. If not eligible: throw exception or return error
   * Input: 
   *   trip : Trip - the trip to book
   *   numberOfSeats : int - number of seats to book (must be > 0)
   * Output: void
   * Pre-condition: Customer must have valid membership, trip must have available seats
   * Post-condition: New booking created and added to customer's bookings
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void bookTrip(final Trip trip, final int numberOfSeats)
  {
    if (numberOfSeats <= 0) {
      throw new IllegalArgumentException("Number of seats must be greater than 0");
    }
    
    Booking booking = RideshareFactory.eINSTANCE.createBooking();
    booking.setTrip(trip);
    booking.setNumberOfSeats(numberOfSeats);
    booking.setCustomer(this);
    booking.setBookingDate(new Date()); // Use current date
    
    if (booking.isBookingEligible()) {
      getBookings().add(booking);
      booking.updateTripSeats();
    } else {
      throw new IllegalStateException("Booking is not eligible");
    }
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Customer
```

# Compilation Errors
```
- ERROR: Date cannot be resolved to a type
	booking.setBookingDate(new Date()); // Use current date
	                           ^^^^
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `User` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: public String getID(), public String getEmail(), public String getPhoneNumber()
  + Setter methods: public void setID(String newID), public void setEmail(String newEmail), public void setPhoneNumber(String newPhoneNumber)
- Class `MembershipPackage` contains the following methods.
  + Instance creation: Use `RideshareFactory.eINSTANCE.createMembershipPackage()`
  + Public methods: public boolean hasAward(final Award award)
  + Getter methods: public EList<Award> getAwards(), public Customer getCustomer()
  + Setter methods: public void setCustomer(Customer newCustomer)
- Class `Booking` contains the following methods.
  + Instance creation: Use `RideshareFactory.eINSTANCE.createBooking()`
  + Public methods: public boolean isBookingEligible(), public void updateTripSeats(), public boolean overlapsWith(final Trip trip)
  + Getter methods: public int getNumberOfSeats(), public Date getBookingDate(), public Customer getCustomer(), public Trip getTrip()
  + Setter methods: public void setNumberOfSeats(int newNumberOfSeats), public void setBookingDate(Date newBookingDate), public void setCustomer(Customer newCustomer), public void setTrip(Trip newTrip)
- Class `Trip` contains the following methods.
  + Instance creation: Use `RideshareFactory.eINSTANCE.createTrip()`
  + Public methods: public double calculateDiscountedPrice(final Customer customer, final String bookingTime), public int calculateMonthlyPoints(final Customer customer, final String currentMonth), public boolean bookSeats(final int num), public boolean confirmBooking(final int seats), public EList<String> getStopStations(), public boolean isTimeConflicting(final String newDepartureTime, final String newArrivalTime)
  + Getter methods: public String getDepartureStation(), public String getArrivalStation(), public String getDepartureTime(), public String getArrivalTime(), public int getNumberOfSeats(), public Date getDepartureDate(), public double getPrice(), public EList<Booking> getBookings(), public EList<Stop> getStops(), public Driver getDriver()
  + Setter methods: public void setDepartureStation(String newDepartureStation), public void setArrivalStation(String newArrivalStation), public void setDepartureTime(String newDepartureTime), public void setArrivalTime(String newArrivalTime), public void setNumberOfSeats(int newNumberOfSeats), public void setDepartureDate(Date newDepartureDate), public void setPrice(double newPrice), public void setDriver(Driver newDriver)

# Output Format
Just put the Java class you fixed into a single block as follows.

```result
(fixed Java class)
```

fixed code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.rideshare;

import java.util.Collection;
import java.util.Date;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;

import org.eclipse.emf.ecore.util.EObjectWithInverseResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Customer</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.rideshare.Customer#getMembershipPackage <em>Membership Package</em>}</li>
 *   <li>{@link edu.rideshare.Customer#getBookings <em>Bookings</em>}</li>
 * </ul>
 *
 * @see edu.rideshare.RidesharePackage#getCustomer()
 * @model kind="class"
 * @generated
 */
public class Customer extends User
{
  protected MembershipPackage membershipPackage;

  protected EList<Booking> bookings;

  protected Customer()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public MembershipPackage getMembershipPackage()
  { ... /* omitted */ }

  public NotificationChain basicSetMembershipPackage(MembershipPackage newMembershipPackage, NotificationChain msgs)
  { ... /* omitted */ }

  public void setMembershipPackage(MembershipPackage newMembershipPackage)
  { ... /* omitted */ }

  public EList<Booking> getBookings()
  { ... /* omitted */ }

  public int computeMonthlyRewardPoints(final String currentMonth)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Creates a new booking for a trip with specified number of seats
   * Algorithm:
   *   1. Create new Booking object
   *   2. Check booking eligibility using isBookingEligible()
   *   3. If eligible: add to bookings list, update trip seats
   *   4. If not eligible: throw exception or return error
   * Input: 
   *   trip : Trip - the trip to book
   *   numberOfSeats : int - number of seats to book (must be > 0)
   * Output: void
   * Pre-condition: Customer must have valid membership, trip must have available seats
   * Post-condition: New booking created and added to customer's bookings
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void bookTrip(final Trip trip, final int numberOfSeats)
  {
    if (numberOfSeats <= 0) {
      throw new IllegalArgumentException("Number of seats must be greater than 0");
    }
    
    Booking booking = RideshareFactory.eINSTANCE.createBooking();
    booking.setTrip(trip);
    booking.setNumberOfSeats(numberOfSeats);
    booking.setCustomer(this);
    booking.setBookingDate(new Date()); // Use current date
    
    if (booking.isBookingEligible()) {
      getBookings().add(booking);
      booking.updateTripSeats();
    } else {
      throw new IllegalStateException("Booking is not eligible");
    }
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // Customer
# Task
You will be given a **Java Class** that is originally generated by EMF code generator with `suppressInterfaces=true` and later is completed by LLMs. Your task is to fix the **Compilation Errors** by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. Read the error messages carefully.
2. Do your best to fix the errors locally without introducing new types, fields, and methods.
3. You should not remove faulty methods to eliminate compilation errors.
4. Do not change parts without errors.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.rideshare;

import java.util.Collection;
import java.util.Date;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.util.InternalEList;
import org.eclipse.emf.common.util.BasicEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Trip</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.rideshare.Trip#getDepartureStation <em>Departure Station</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getArrivalStation <em>Arrival Station</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getDepartureTime <em>Departure Time</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getArrivalTime <em>Arrival Time</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getNumberOfSeats <em>Number Of Seats</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getDepartureDate <em>Departure Date</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getPrice <em>Price</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getBookings <em>Bookings</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getStops <em>Stops</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getDriver <em>Driver</em>}</li>
 * </ul>
 *
 * @see edu.rideshare.RidesharePackage#getTrip()
 * @model kind="class"
 * @generated
 */
public class Trip extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String DEPARTURE_STATION_EDEFAULT = null;

  protected String departureStation = DEPARTURE_STATION_EDEFAULT;

  protected static final String ARRIVAL_STATION_EDEFAULT = null;

  protected String arrivalStation = ARRIVAL_STATION_EDEFAULT;

  protected static final String DEPARTURE_TIME_EDEFAULT = null;

  protected String departureTime = DEPARTURE_TIME_EDEFAULT;

  protected static final String ARRIVAL_TIME_EDEFAULT = null;

  protected String arrivalTime = ARRIVAL_TIME_EDEFAULT;

  protected static final int NUMBER_OF_SEATS_EDEFAULT = 0;

  protected int numberOfSeats = NUMBER_OF_SEATS_EDEFAULT;

  protected static final Date DEPARTURE_DATE_EDEFAULT = null;

  protected Date departureDate = DEPARTURE_DATE_EDEFAULT;

  protected static final double PRICE_EDEFAULT = 0.0;

  protected double price = PRICE_EDEFAULT;

  protected EList<Booking> bookings;

  protected EList<Stop> stops;

  protected Trip()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getDepartureStation()
  { ... /* omitted */ }

  public void setDepartureStation(String newDepartureStation)
  { ... /* omitted */ }

  public String getArrivalStation()
  { ... /* omitted */ }

  public void setArrivalStation(String newArrivalStation)
  { ... /* omitted */ }

  public String getDepartureTime()
  { ... /* omitted */ }

  public void setDepartureTime(String newDepartureTime)
  { ... /* omitted */ }

  public String getArrivalTime()
  { ... /* omitted */ }

  public void setArrivalTime(String newArrivalTime)
  { ... /* omitted */ }

  public int getNumberOfSeats()
  { ... /* omitted */ }

  public void setNumberOfSeats(int newNumberOfSeats)
  { ... /* omitted */ }

  public Date getDepartureDate()
  { ... /* omitted */ }

  public void setDepartureDate(Date newDepartureDate)
  { ... /* omitted */ }

  public double getPrice()
  { ... /* omitted */ }

  public void setPrice(double newPrice)
  { ... /* omitted */ }

  public EList<Booking> getBookings()
  { ... /* omitted */ }

  public EList<Stop> getStops()
  { ... /* omitted */ }

  public Driver getDriver()
  { ... /* omitted */ }

  public NotificationChain basicSetDriver(Driver newDriver, NotificationChain msgs)
  { ... /* omitted */ }

  public void setDriver(Driver newDriver)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates final price for customer after applying membership discounts
   * Algorithm:
   *   basePrice = this.price
   *   discountRate = 0.0
   *   IF customer.membershipPackage.hasAward(DISCOUNTS)
   *     discountRate = 0.1  // 10% discount for members
   *   finalPrice = basePrice * (1 - discountRate)
   *   RETURN finalPrice
   * Input: 
   *   customer : Customer - the customer requesting price
   *   bookingTime : String - time of booking (for potential time-based discounts)
   * Output: double - discounted price (rounded to 2 decimal places)
   * Pre-condition: Customer must have valid membership package
   * Post-condition: No state changes
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateDiscountedPrice(final Customer customer, final String bookingTime)
  {
    double basePrice = this.price;
    double discountRate = 0.0;
    
    if (customer.getMembershipPackage() != null && customer.getMembershipPackage().hasAward("DISCOUNTS")) {
      discountRate = 0.1;
    }
    
    double finalPrice = basePrice * (1 - discountRate);
    return Math.round(finalPrice * 100.0) / 100.0;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates reward points earned for this trip in specified month
   * Algorithm:
   *   points = 0
   *   IF trip.departureDate.month = currentMonth
   *     basePoints = this.price * 0.01  // 1 point per dollar spent
   *     IF customer.membershipPackage.hasAward(POINTS)
   *       bonusMultiplier = 1.5  // 50% bonus for members
   *       points = basePoints * bonusMultiplier
   *     ELSE
   *       points = basePoints
   *   RETURN floor(points)
   * Input:
   *   customer : Customer - the customer earning points
   *   currentMonth : String - month in "YYYY-MM" format
   * Output: int - reward points earned (rounded down)
   * Pre-condition: Trip must have valid price and departure date
   * Post-condition: No state changes
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateMonthlyPoints(final Customer customer, final String currentMonth)
  {
    if (this.departureDate == null) {
      return 0;
    }
    
    String tripMonth = String.format("%tY-%tm", this.departureDate, this.departureDate);
    if (!tripMonth.equals(currentMonth)) {
      return 0;
    }
    
    double basePoints = this.price * 0.01;
    double points = basePoints;
    
    if (customer.getMembershipPackage() != null && customer.getMembershipPackage().hasAward("POINTS")) {
      double bonusMultiplier = 1.5;
      points = basePoints * bonusMultiplier;
    }
    
    return (int) Math.floor(points);
  }

  public boolean bookSeats(final int num)
  { ... /* omitted */ }

  public boolean confirmBooking(final int seats)
  { ... /* omitted */ }

  public EList<String> getStopStations()
  { ... /* omitted */ }

  public boolean isTimeConflicting(final String newDepartureTime, final String newArrivalTime)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Trip
```

# Compilation Errors
```
- ERROR: The method hasAward(Award) in the type MembershipPackage is not applicable for the arguments (String)
	if (customer.getMembershipPackage() != null && customer.getMembershipPackage().hasAward("DISCOUNTS")) {
	                                                                               ^^^^^^^^

- ERROR: The method hasAward(Award) in the type MembershipPackage is not applicable for the arguments (String)
	if (customer.getMembershipPackage() != null && customer.getMembershipPackage().hasAward("POINTS")) {
	                                                                               ^^^^^^^^
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Booking` contains the following methods.
  + Instance creation: Use `RideshareFactory.eINSTANCE.createBooking()`
  + Public methods: public boolean isBookingEligible(), public void updateTripSeats(), public boolean overlapsWith(final Trip trip)
  + Getter methods: public int getNumberOfSeats(), public Date getBookingDate(), public Customer getCustomer(), public Trip getTrip()
  + Setter methods: public void setNumberOfSeats(int newNumberOfSeats), public void setBookingDate(Date newBookingDate), public void setCustomer(Customer newCustomer), public void setTrip(Trip newTrip)
- Class `Stop` contains the following methods.
  + Instance creation: Use `RideshareFactory.eINSTANCE.createStop()`
  + Getter methods: public String getStopStation(), public Trip getTrip()
  + Setter methods: public void setStopStation(String newStopStation), public void setTrip(Trip newTrip)
- Class `Driver` contains the following methods.
  + Instance creation: Use `RideshareFactory.eINSTANCE.createDriver()`
  + Public methods: public boolean checkStopOverlap(final Trip trip1, final Trip trip2), public boolean canPostTrip(final Trip newtrip)
  + Getter methods: , , , public EList<Trip> getTrips()
  + Setter methods: , , 
- Class `Customer` contains the following methods.
  + Instance creation: Use `RideshareFactory.eINSTANCE.createCustomer()`
  + Public methods: public int computeMonthlyRewardPoints(final String currentMonth), public void bookTrip(final Trip trip, final int numberOfSeats)
  + Getter methods: , , , public MembershipPackage getMembershipPackage(), public EList<Booking> getBookings()
  + Setter methods: , , , public void setMembershipPackage(MembershipPackage newMembershipPackage)

# Output Format
Just put the Java class you fixed into a single block as follows.

```result
(fixed Java class)
```

fixed code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.rideshare;

import java.util.Collection;
import java.util.Date;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.util.InternalEList;
import org.eclipse.emf.common.util.BasicEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Trip</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.rideshare.Trip#getDepartureStation <em>Departure Station</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getArrivalStation <em>Arrival Station</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getDepartureTime <em>Departure Time</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getArrivalTime <em>Arrival Time</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getNumberOfSeats <em>Number Of Seats</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getDepartureDate <em>Departure Date</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getPrice <em>Price</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getBookings <em>Bookings</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getStops <em>Stops</em>}</li>
 *   <li>{@link edu.rideshare.Trip#getDriver <em>Driver</em>}</li>
 * </ul>
 *
 * @see edu.rideshare.RidesharePackage#getTrip()
 * @model kind="class"
 * @generated
 */
public class Trip extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String DEPARTURE_STATION_EDEFAULT = null;

  protected String departureStation = DEPARTURE_STATION_EDEFAULT;

  protected static final String ARRIVAL_STATION_EDEFAULT = null;

  protected String arrivalStation = ARRIVAL_STATION_EDEFAULT;

  protected static final String DEPARTURE_TIME_EDEFAULT = null;

  protected String departureTime = DEPARTURE_TIME_EDEFAULT;

  protected static final String ARRIVAL_TIME_EDEFAULT = null;

  protected String arrivalTime = ARRIVAL_TIME_EDEFAULT;

  protected static final int NUMBER_OF_SEATS_EDEFAULT = 0;

  protected int numberOfSeats = NUMBER_OF_SEATS_EDEFAULT;

  protected static final Date DEPARTURE_DATE_EDEFAULT = null;

  protected Date departureDate = DEPARTURE_DATE_EDEFAULT;

  protected static final double PRICE_EDEFAULT = 0.0;

  protected double price = PRICE_EDEFAULT;

  protected EList<Booking> bookings;

  protected EList<Stop> stops;

  protected Trip()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getDepartureStation()
  { ... /* omitted */ }

  public void setDepartureStation(String newDepartureStation)
  { ... /* omitted */ }

  public String getArrivalStation()
  { ... /* omitted */ }

  public void setArrivalStation(String newArrivalStation)
  { ... /* omitted */ }

  public String getDepartureTime()
  { ... /* omitted */ }

  public void setDepartureTime(String newDepartureTime)
  { ... /* omitted */ }

  public String getArrivalTime()
  { ... /* omitted */ }

  public void setArrivalTime(String newArrivalTime)
  { ... /* omitted */ }

  public int getNumberOfSeats()
  { ... /* omitted */ }

  public void setNumberOfSeats(int newNumberOfSeats)
  { ... /* omitted */ }

  public Date getDepartureDate()
  { ... /* omitted */ }

  public void setDepartureDate(Date newDepartureDate)
  { ... /* omitted */ }

  public double getPrice()
  { ... /* omitted */ }

  public void setPrice(double newPrice)
  { ... /* omitted */ }

  public EList<Booking> getBookings()
  { ... /* omitted */ }

  public EList<Stop> getStops()
  { ... /* omitted */ }

  public Driver getDriver()
  { ... /* omitted */ }

  public NotificationChain basicSetDriver(Driver newDriver, NotificationChain msgs)
  { ... /* omitted */ }

  public void setDriver(Driver newDriver)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates final price for customer after applying membership discounts
   * Algorithm:
   *   basePrice = this.price
   *   discountRate = 0.0
   *   IF customer.membershipPackage.hasAward(DISCOUNTS)
   *     discountRate = 0.1  // 10% discount for members
   *   finalPrice = basePrice * (1 - discountRate)
   *   RETURN finalPrice
   * Input: 
   *   customer : Customer - the customer requesting price
   *   bookingTime : String - time of booking (for potential time-based discounts)
   * Output: double - discounted price (rounded to 2 decimal places)
   * Pre-condition: Customer must have valid membership package
   * Post-condition: No state changes
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateDiscountedPrice(final Customer customer, final String bookingTime)
  {
    double basePrice = this.price;
    double discountRate = 0.0;
    
    if (customer.getMembershipPackage() != null && customer.getMembershipPackage().hasAward(Award.DISCOUNTS)) {
      discountRate = 0.1;
    }
    
    double finalPrice = basePrice * (1 - discountRate);
    return Math.round(finalPrice * 100.0) / 100.0;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates reward points earned for this trip in specified month
   * Algorithm:
   *   points = 0
   *   IF trip.departureDate.month = currentMonth
   *     basePoints = this.price * 0.01  // 1 point per dollar spent
   *     IF customer.membershipPackage.hasAward(POINTS)
   *       bonusMultiplier = 1.5  // 50% bonus for members
   *       points = basePoints * bonusMultiplier
   *     ELSE
   *       points = basePoints
   *   RETURN floor(points)
   * Input:
   *   customer : Customer - the customer earning points
   *   currentMonth : String - month in "YYYY-MM" format
   * Output: int - reward points earned (rounded down)
   * Pre-condition: Trip must have valid price and departure date
   * Post-condition: No state changes
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateMonthlyPoints(final Customer customer, final String currentMonth)
  {
    if (this.departureDate == null) {
      return 0;
    }
    
    String tripMonth = String.format("%tY-%tm", this.departureDate, this.departureDate);
    if (!tripMonth.equals(currentMonth)) {
      return 0;
    }
    
    double basePoints = this.price * 0.01;
    double points = basePoints;
    
    if (customer.getMembershipPackage() != null && customer.getMembershipPackage().hasAward(Award.POINTS)) {
      double bonusMultiplier = 1.5;
      points = basePoints * bonusMultiplier;
    }
    
    return (int) Math.floor(points);
  }

  public boolean bookSeats(final int num)
  { ... /* omitted */ }

  public boolean confirmBooking(final int seats)
  { ... /* omitted */ }

  public EList<String> getStopStations()
  { ... /* omitted */ }

  public boolean isTimeConflicting(final String newDepartureTime, final String newArrivalTime)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Trip
2286397 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../ORS/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../ORS/src-gen/edu/rideshare/
2286536 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
2286536 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
2286536 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
2286537 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
2286538 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample5.mwe2 
 src-gen/edu/rideshare  deepseek-v3.2-exp/rideshare5...


======================================

======================================

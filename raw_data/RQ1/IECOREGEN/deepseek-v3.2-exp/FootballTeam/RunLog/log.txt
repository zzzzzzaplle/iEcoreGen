354854 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
354924 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../FootballTeam/src-gen/edu/footballteam
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.footballteam;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Football Team</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.footballteam.FootballTeam#getFirstEleven <em>First Eleven</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getSpareTeam <em>Spare Team</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getPlayers <em>Players</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getAnnouncements <em>Announcements</em>}</li>
 * </ul>
 *
 * @see edu.footballteam.FootballteamPackage#getFootballTeam()
 * @model kind="class"
 * @generated
 */
public class FootballTeam extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Player> firstEleven;

  protected EList<Player> spareTeam;

  protected EList<Player> players;

  protected EList<Announcement> announcements;

  protected FootballTeam()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Player> getFirstEleven()
  { ... /* omitted */ }

  public EList<Player> getSpareTeam()
  { ... /* omitted */ }

  public EList<Player> getPlayers()
  { ... /* omitted */ }

  public EList<Announcement> getAnnouncements()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts goal-scoring announcements by starting eleven forwards
   * Algorithm:
   *   count = 0
   *   FOR EACH announcement IN announcements:
   *     IF announcement.type == SCORE AND
   *        announcement.player.position == FORWARD AND
   *        firstEleven contains announcement.player THEN
   *       count = count + 1
   *   RETURN count
   * Input: None
   * Output: Integer count of goal announcements by first eleven forwards
   * Pre-condition: announcements and firstEleven lists must be initialized
   * Post-condition: Only counts goals by forwards in starting lineup
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int calculateTotalGoalScoringAnnouncementsForFirstEleven()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Finds midfielder player with highest jersey number
   * Algorithm:
   *   highestPlayer = null
   *   highestNumber = -1
   *   FOR EACH player IN players:
   *     IF player.position == MIDFIELD AND player.number > highestNumber THEN
   *       highestNumber = player.number
   *       highestPlayer = player
   *   RETURN highestPlayer
   * Input: None
   * Output: Player object with highest number among midfielders, null if no midfielders
   * Pre-condition: players list must be initialized
   * Post-condition: Returns correct midfielder or null if none exist
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public Player findMidfielderWithHighestNumber()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Computes the average age of players in the spare team
   * Algorithm: 
   *   IF spareTeam is empty THEN return 0.0
   *   ELSE 
   *     totalAge = sum of all player.age in spareTeam
   *     average = totalAge / size of spareTeam
   *     RETURN average as double
   * Input: None
   * Output: Average age as double (e.g., 24.7), 0.0 if spare team is empty
   * Pre-condition: spareTeam list must be initialized
   * Post-condition: Returns correct average without modifying team data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateAverageAgeOfSpareTeam()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts goal-saving announcements made by goalkeepers
   * Algorithm:
   *   count = 0
   *   FOR EACH announcement IN announcements:
   *     IF announcement.type == SAVE AND 
   *        announcement.player.position == GOALKEEPER THEN
   *       count = count + 1
   *   RETURN count
   * Input: None
   * Output: Integer count of goal-saving announcements by goalkeepers, 0 if none
   * Pre-condition: announcements list must be initialized
   * Post-condition: Count reflects all valid goalkeeper save announcements
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int calculateGoalSavingAnnouncementsByGoalkeeper()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts all announcements made by forward players
   * Algorithm:
   *   count = 0
   *   FOR EACH announcement IN announcements:
   *     IF announcement.player.position == FORWARD THEN
   *       count = count + 1
   *   RETURN count
   * Input: None
   * Output: Integer count of all announcements by forwards, 0 if none
   * Pre-condition: announcements list must be initialized
   * Post-condition: Count reflects all announcements by forward players regardless of type
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int calculateTotalAnnouncementsForForwardPlayers()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // FootballTeam
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Player` contains the following methods.
  + Instance creation: Use `FootballteamFactory.eINSTANCE.createPlayer()`
  + Getter methods: public String getName(), public int getAge(), public int getNumber(), public Position getPosition()
  + Setter methods: public void setName(String newName), public void setAge(int newAge), public void setNumber(int newNumber), public void setPosition(Position newPosition)
- Class `Announcement` contains the following methods.
  + Instance creation: Use `FootballteamFactory.eINSTANCE.createAnnouncement()`
  + Getter methods: public Date getTime(), public AnnouncementType getType(), public Player getPlayer()
  + Setter methods: public void setTime(Date newTime), public void setType(AnnouncementType newType), public void setPlayer(Player newPlayer)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.footballteam;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Football Team</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.footballteam.FootballTeam#getFirstEleven <em>First Eleven</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getSpareTeam <em>Spare Team</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getPlayers <em>Players</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getAnnouncements <em>Announcements</em>}</li>
 * </ul>
 *
 * @see edu.footballteam.FootballteamPackage#getFootballTeam()
 * @model kind="class"
 * @generated
 */
public class FootballTeam extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Player> firstEleven;

  protected EList<Player> spareTeam;

  protected EList<Player> players;

  protected EList<Announcement> announcements;

  protected FootballTeam()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Player> getFirstEleven()
  { ... /* omitted */ }

  public EList<Player> getSpareTeam()
  { ... /* omitted */ }

  public EList<Player> getPlayers()
  { ... /* omitted */ }

  public EList<Announcement> getAnnouncements()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts goal-scoring announcements by starting eleven forwards
   * Algorithm:
   *   count = 0
   *   FOR EACH announcement IN announcements:
   *     IF announcement.type == SCORE AND
   *        announcement.player.position == FORWARD AND
   *        firstEleven contains announcement.player THEN
   *       count = count + 1
   *   RETURN count
   * Input: None
   * Output: Integer count of goal announcements by first eleven forwards
   * Pre-condition: announcements and firstEleven lists must be initialized
   * Post-condition: Only counts goals by forwards in starting lineup
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateTotalGoalScoringAnnouncementsForFirstEleven()
  {
    int count = 0;
    for (Announcement announcement : getAnnouncements()) {
      if (announcement.getType() == AnnouncementType.SCORE && 
          announcement.getPlayer().getPosition() == Position.FORWARD && 
          getFirstEleven().contains(announcement.getPlayer())) {
        count++;
      }
    }
    return count;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Finds midfielder player with highest jersey number
   * Algorithm:
   *   highestPlayer = null
   *   highestNumber = -1
   *   FOR EACH player IN players:
   *     IF player.position == MIDFIELD AND player.number > highestNumber THEN
   *       highestNumber = player.number
   *       highestPlayer = player
   *   RETURN highestPlayer
   * Input: None
   * Output: Player object with highest number among midfielders, null if no midfielders
   * Pre-condition: players list must be initialized
   * Post-condition: Returns correct midfielder or null if none exist
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Player findMidfielderWithHighestNumber()
  {
    Player highestPlayer = null;
    int highestNumber = -1;
    for (Player player : getPlayers()) {
      if (player.getPosition() == Position.MIDFIELD && player.getNumber() > highestNumber) {
        highestNumber = player.getNumber();
        highestPlayer = player;
      }
    }
    return highestPlayer;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Computes the average age of players in the spare team
   * Algorithm: 
   *   IF spareTeam is empty THEN return 0.0
   *   ELSE 
   *     totalAge = sum of all player.age in spareTeam
   *     average = totalAge / size of spareTeam
   *     RETURN average as double
   * Input: None
   * Output: Average age as double (e.g., 24.7), 0.0 if spare team is empty
   * Pre-condition: spareTeam list must be initialized
   * Post-condition: Returns correct average without modifying team data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateAverageAgeOfSpareTeam()
  {
    EList<Player> spareTeam = getSpareTeam();
    if (spareTeam.isEmpty()) {
      return 0.0;
    }
    
    int totalAge = 0;
    for (Player player : spareTeam) {
      totalAge += player.getAge();
    }
    
    return (double) totalAge / spareTeam.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts goal-saving announcements made by goalkeepers
   * Algorithm:
   *   count = 0
   *   FOR EACH announcement IN announcements:
   *     IF announcement.type == SAVE AND 
   *        announcement.player.position == GOALKEEPER THEN
   *       count = count + 1
   *   RETURN count
   * Input: None
   * Output: Integer count of goal-saving announcements by goalkeepers, 0 if none
   * Pre-condition: announcements list must be initialized
   * Post-condition: Count reflects all valid goalkeeper save announcements
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateGoalSavingAnnouncementsByGoalkeeper()
  {
    int count = 0;
    for (Announcement announcement : getAnnouncements()) {
      if (announcement.getType() == AnnouncementType.SAVE && 
          announcement.getPlayer().getPosition() == Position.GOALKEEPER) {
        count++;
      }
    }
    return count;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts all announcements made by forward players
   * Algorithm:
   *   count = 0
   *   FOR EACH announcement IN announcements:
   *     IF announcement.player.position == FORWARD THEN
   *       count = count + 1
   *   RETURN count
   * Input: None
   * Output: Integer count of all announcements by forwards, 0 if none
   * Pre-condition: announcements list must be initialized
   * Post-condition: Count reflects all announcements by forward players regardless of type
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateTotalAnnouncementsForForwardPlayers()
  {
    int count = 0;
    for (Announcement announcement : getAnnouncements()) {
      if (announcement.getPlayer().getPosition() == Position.FORWARD) {
        count++;
      }
    }
    return count;
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // FootballTeam
434481 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../FootballTeam/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../FootballTeam/src-gen/edu/footballteam/
434624 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
434624 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
434624 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
434624 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
434625 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample3.mwe2 启动完成
正在拷贝 src-gen/edu/footballteam 到 deepseek-v3.2-exp/footballteam3...
拷贝完成！

======================================
正在启动 sample4.mwe2...
======================================
434817 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
434889 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project FootballTeam at 'file:/D:/EclipseWorkspace/FootballTeam/'
434892 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
434898 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@6d38a81d
434898 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
434900 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
434901 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
Turgutlu football team has more than one football player. 
The system can perform the first eleven and spare team listing operations.
Football players have team, name, age, and number information. 
Each football player has a different duty and plays football according to their position. Positions are forward, midfield, and defense. There are strikers in the forward, and they play to score goals. There is a goalkeeper in the defense, and he plays to clear the ball. There are midfielders in the midfield, distributing the ball around the pitch. On the system, when the striker scores goals, the system announces his number and name. 
When the goalkeeper saves the goal, the system announces his number and name.
Function Requirement:
+ Calculate the total number of goal-scoring announcements for the starting eleven players of a given football team. Count score announcements issued by the starting eleven. Because only forwards can generate score announcements, goals scored by other positions are ignored.
+ Identify midfielder with highest number. Find the midfielder player with the highest number within all players of a football team. Return null if no midfielders found. 
+ Calculate average age of spare team players. Compute the average age of players in the spare team of a football team. Return the value as a floating-point number (e.g., 24.7). If the reserve team is empty, return 0.0.
+ Count the number of goal-saving announcements made by all goalkeepers on the team.  Only announcements generated by players whose position is GOALKEEPER are considered. Return 0 if no such announcements exist.
+ Calculate the total number of announcements made by all forwards on the team. Return 0 if there are no forwards or no announcements.
```

# Class Diagram
```plantuml
@startuml

title footballteam Model

class Announcement {
    time : EDate
    type : AnnouncementType
    player : Player
}
class FootballTeam {
    announcements : List<Announcement>
    firstEleven : List<Player>
    players : List<Player>
    spareTeam : List<Player>
    calculateAverageAgeOfSpareTeam() : double
    calculateGoalSavingAnnouncementsByGoalkeeper() : int
    calculateTotalAnnouncementsForForwardPlayers() : int
    calculateTotalGoalScoringAnnouncementsForFirstEleven() : int
    findMidfielderWithHighestNumber() : Player
}
class Player {
    age : int
    name : String
    number : int
    position : Position
}
enum AnnouncementType {
    SCORE
    SAVE
}
enum Position {
    FORWARD
    MIDFIELD
    DEFENSE
    GOALKEEPER
}

Announcement --> Player : player
FootballTeam *-- "*" Announcement : announcements
FootballTeam --> "*" Player : firstEleven
FootballTeam *-- "*" Player : players
FootballTeam --> "*" Player : spareTeam
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

462311 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@7e0941cc (name: findMidfielderWithHighestNumber) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Finds the midfielder player with the highest jersey number from all players
Algorithm:
  1. Initialize highestMidfielder = null, highestNumber = -1
  2. For each player in players list:
      2.1 If player.position is MIDFIELD:
          2.1.1 If player.number > highestNumber:
              2.1.1.1 highestNumber = player.number
              2.1.1.2 highestMidfielder = player
  3. Return highestMidfielder
Input: None
Output: Player object (midfielder with highest number) or null if no midfielders found
Pre-condition: players list must be initialized
Post-condition: Returns correct player or null without modifying any data, org.eclipse.emf.ecore.impl.EOperationImpl@5114c8a1 (name: calculateAverageAgeOfSpareTeam) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates the average age of players in the spare team
Algorithm:
  1. If spareTeam is empty, return 0.0
  2. Initialize totalAge = 0
  3. For each player in spareTeam list:
      3.1 totalAge = totalAge + player.age
  4. average = totalAge / spareTeam.size()
  5. Return average as double
Input: None
Output: Double value representing average age (range: 0.0 or positive floating-point numbers)
Pre-condition: spareTeam list must be initialized
Post-condition: Returns correct average without modifying any data, org.eclipse.emf.ecore.impl.EOperationImpl@24d73c51 (name: calculateGoalSavingAnnouncementsByGoalkeeper) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Counts goal-saving announcements made by all goalkeepers on the team
Algorithm:
  1. Initialize count = 0
  2. For each announcement in announcements list:
      2.1 If announcement.type is SAVE AND announcement.player.position is GOALKEEPER:
          2.1.1 count = count + 1
  3. Return count
Input: None
Output: Integer representing total goal-saving announcements by goalkeepers (range: 0 to max integer)
Pre-condition: announcements list must be initialized
Post-condition: Returns correct count without modifying any data, org.eclipse.emf.ecore.impl.EOperationImpl@19d0d1ab (name: calculateTotalGoalScoringAnnouncementsForFirstEleven) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates the total number of goal-scoring announcements made by forwards in the starting eleven
Algorithm:
  1. Initialize count = 0
  2. For each player in firstEleven list:
      2.1 If player.position is FORWARD:
          2.1.1 For each announcement in announcements list:
              2.1.1.1 If announcement.player equals player AND announcement.type is SCORE:
                  2.1.1.1.1 count = count + 1
  3. Return count
Input: None
Output: Integer representing total goal-scoring announcements by starting eleven forwards (range: 0 to max integer)
Pre-condition: firstEleven list and announcements list must be initialized
Post-condition: Returns correct count without modifying any data, org.eclipse.emf.ecore.impl.EOperationImpl@3b95fce9 (name: calculateTotalAnnouncementsForForwardPlayers) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates total announcements made by all forward players on the team
Algorithm:
  1. Initialize count = 0
  2. For each announcement in announcements list:
      2.1 If announcement.player.position is FORWARD:
          2.1.1 count = count + 1
  3. Return count
Input: None
Output: Integer representing total announcements by forwards (range: 0 to max integer)
Pre-condition: announcements list must be initialized
Post-condition: Returns correct count without modifying any data}
462313 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
462334 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../FootballTeam/src-gen/edu/footballteam
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.footballteam;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Football Team</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.footballteam.FootballTeam#getFirstEleven <em>First Eleven</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getSpareTeam <em>Spare Team</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getPlayers <em>Players</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getAnnouncements <em>Announcements</em>}</li>
 * </ul>
 *
 * @see edu.footballteam.FootballteamPackage#getFootballTeam()
 * @model kind="class"
 * @generated
 */
public class FootballTeam extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Player> firstEleven;

  protected EList<Player> spareTeam;

  protected EList<Player> players;

  protected EList<Announcement> announcements;

  protected FootballTeam()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Player> getFirstEleven()
  { ... /* omitted */ }

  public EList<Player> getSpareTeam()
  { ... /* omitted */ }

  public EList<Player> getPlayers()
  { ... /* omitted */ }

  public EList<Announcement> getAnnouncements()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total number of goal-scoring announcements made by forwards in the starting eleven
   * Algorithm:
   *   1. Initialize count = 0
   *   2. For each player in firstEleven list:
   *       2.1 If player.position is FORWARD:
   *           2.1.1 For each announcement in announcements list:
   *               2.1.1.1 If announcement.player equals player AND announcement.type is SCORE:
   *                   2.1.1.1.1 count = count + 1
   *   3. Return count
   * Input: None
   * Output: Integer representing total goal-scoring announcements by starting eleven forwards (range: 0 to max integer)
   * Pre-condition: firstEleven list and announcements list must be initialized
   * Post-condition: Returns correct count without modifying any data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int calculateTotalGoalScoringAnnouncementsForFirstEleven()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Finds the midfielder player with the highest jersey number from all players
   * Algorithm:
   *   1. Initialize highestMidfielder = null, highestNumber = -1
   *   2. For each player in players list:
   *       2.1 If player.position is MIDFIELD:
   *           2.1.1 If player.number > highestNumber:
   *               2.1.1.1 highestNumber = player.number
   *               2.1.1.2 highestMidfielder = player
   *   3. Return highestMidfielder
   * Input: None
   * Output: Player object (midfielder with highest number) or null if no midfielders found
   * Pre-condition: players list must be initialized
   * Post-condition: Returns correct player or null without modifying any data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public Player findMidfielderWithHighestNumber()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the average age of players in the spare team
   * Algorithm:
   *   1. If spareTeam is empty, return 0.0
   *   2. Initialize totalAge = 0
   *   3. For each player in spareTeam list:
   *       3.1 totalAge = totalAge + player.age
   *   4. average = totalAge / spareTeam.size()
   *   5. Return average as double
   * Input: None
   * Output: Double value representing average age (range: 0.0 or positive floating-point numbers)
   * Pre-condition: spareTeam list must be initialized
   * Post-condition: Returns correct average without modifying any data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateAverageAgeOfSpareTeam()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts goal-saving announcements made by all goalkeepers on the team
   * Algorithm:
   *   1. Initialize count = 0
   *   2. For each announcement in announcements list:
   *       2.1 If announcement.type is SAVE AND announcement.player.position is GOALKEEPER:
   *           2.1.1 count = count + 1
   *   3. Return count
   * Input: None
   * Output: Integer representing total goal-saving announcements by goalkeepers (range: 0 to max integer)
   * Pre-condition: announcements list must be initialized
   * Post-condition: Returns correct count without modifying any data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int calculateGoalSavingAnnouncementsByGoalkeeper()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates total announcements made by all forward players on the team
   * Algorithm:
   *   1. Initialize count = 0
   *   2. For each announcement in announcements list:
   *       2.1 If announcement.player.position is FORWARD:
   *           2.1.1 count = count + 1
   *   3. Return count
   * Input: None
   * Output: Integer representing total announcements by forwards (range: 0 to max integer)
   * Pre-condition: announcements list must be initialized
   * Post-condition: Returns correct count without modifying any data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int calculateTotalAnnouncementsForForwardPlayers()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // FootballTeam
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Player` contains the following methods.
  + Instance creation: Use `FootballteamFactory.eINSTANCE.createPlayer()`
  + Getter methods: public String getName(), public int getAge(), public int getNumber(), public Position getPosition()
  + Setter methods: public void setName(String newName), public void setAge(int newAge), public void setNumber(int newNumber), public void setPosition(Position newPosition)
- Class `Announcement` contains the following methods.
  + Instance creation: Use `FootballteamFactory.eINSTANCE.createAnnouncement()`
  + Getter methods: public Date getTime(), public AnnouncementType getType(), public Player getPlayer()
  + Setter methods: public void setTime(Date newTime), public void setType(AnnouncementType newType), public void setPlayer(Player newPlayer)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

580903 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - Cannot invoke "java.lang.Iterable.iterator()" because "iterable" is null
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.footballteam;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Football Team</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.footballteam.FootballTeam#getFirstEleven <em>First Eleven</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getSpareTeam <em>Spare Team</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getPlayers <em>Players</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getAnnouncements <em>Announcements</em>}</li>
 * </ul>
 *
 * @see edu.footballteam.FootballteamPackage#getFootballTeam()
 * @model kind="class"
 * @generated
 */
public class FootballTeam extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Player> firstEleven;

  protected EList<Player> spareTeam;

  protected EList<Player> players;

  protected EList<Announcement> announcements;

  protected FootballTeam()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Player> getFirstEleven()
  { ... /* omitted */ }

  public EList<Player> getSpareTeam()
  { ... /* omitted */ }

  public EList<Player> getPlayers()
  { ... /* omitted */ }

  public EList<Announcement> getAnnouncements()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total number of goal-scoring announcements made by forwards in the starting eleven
   * Algorithm:
   *   1. Initialize count = 0
   *   2. For each player in firstEleven list:
   *       2.1 If player.position is FORWARD:
   *           2.1.1 For each announcement in announcements list:
   *               2.1.1.1 If announcement.player equals player AND announcement.type is SCORE:
   *                   2.1.1.1.1 count = count + 1
   *   3. Return count
   * Input: None
   * Output: Integer representing total goal-scoring announcements by starting eleven forwards (range: 0 to max integer)
   * Pre-condition: firstEleven list and announcements list must be initialized
   * Post-condition: Returns correct count without modifying any data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int calculateTotalGoalScoringAnnouncementsForFirstEleven()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Finds the midfielder player with the highest jersey number from all players
   * Algorithm:
   *   1. Initialize highestMidfielder = null, highestNumber = -1
   *   2. For each player in players list:
   *       2.1 If player.position is MIDFIELD:
   *           2.1.1 If player.number > highestNumber:
   *               2.1.1.1 highestNumber = player.number
   *               2.1.1.2 highestMidfielder = player
   *   3. Return highestMidfielder
   * Input: None
   * Output: Player object (midfielder with highest number) or null if no midfielders found
   * Pre-condition: players list must be initialized
   * Post-condition: Returns correct player or null without modifying any data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public Player findMidfielderWithHighestNumber()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the average age of players in the spare team
   * Algorithm:
   *   1. If spareTeam is empty, return 0.0
   *   2. Initialize totalAge = 0
   *   3. For each player in spareTeam list:
   *       3.1 totalAge = totalAge + player.age
   *   4. average = totalAge / spareTeam.size()
   *   5. Return average as double
   * Input: None
   * Output: Double value representing average age (range: 0.0 or positive floating-point numbers)
   * Pre-condition: spareTeam list must be initialized
   * Post-condition: Returns correct average without modifying any data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateAverageAgeOfSpareTeam()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts goal-saving announcements made by all goalkeepers on the team
   * Algorithm:
   *   1. Initialize count = 0
   *   2. For each announcement in announcements list:
   *       2.1 If announcement.type is SAVE AND announcement.player.position is GOALKEEPER:
   *           2.1.1 count = count + 1
   *   3. Return count
   * Input: None
   * Output: Integer representing total goal-saving announcements by goalkeepers (range: 0 to max integer)
   * Pre-condition: announcements list must be initialized
   * Post-condition: Returns correct count without modifying any data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int calculateGoalSavingAnnouncementsByGoalkeeper()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates total announcements made by all forward players on the team
   * Algorithm:
   *   1. Initialize count = 0
   *   2. For each announcement in announcements list:
   *       2.1 If announcement.player.position is FORWARD:
   *           2.1.1 count = count + 1
   *   3. Return count
   * Input: None
   * Output: Integer representing total announcements by forwards (range: 0 to max integer)
   * Pre-condition: announcements list must be initialized
   * Post-condition: Returns correct count without modifying any data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int calculateTotalAnnouncementsForForwardPlayers()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // FootballTeam
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Player` contains the following methods.
  + Instance creation: Use `FootballteamFactory.eINSTANCE.createPlayer()`
  + Getter methods: public String getName(), public int getAge(), public int getNumber(), public Position getPosition()
  + Setter methods: public void setName(String newName), public void setAge(int newAge), public void setNumber(int newNumber), public void setPosition(Position newPosition)
- Class `Announcement` contains the following methods.
  + Instance creation: Use `FootballteamFactory.eINSTANCE.createAnnouncement()`
  + Getter methods: public Date getTime(), public AnnouncementType getType(), public Player getPlayer()
  + Setter methods: public void setTime(Date newTime), public void setType(AnnouncementType newType), public void setPlayer(Player newPlayer)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.footballteam;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Football Team</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.footballteam.FootballTeam#getFirstEleven <em>First Eleven</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getSpareTeam <em>Spare Team</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getPlayers <em>Players</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getAnnouncements <em>Announcements</em>}</li>
 * </ul>
 *
 * @see edu.footballteam.FootballteamPackage#getFootballTeam()
 * @model kind="class"
 * @generated
 */
public class FootballTeam extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Player> firstEleven;

  protected EList<Player> spareTeam;

  protected EList<Player> players;

  protected EList<Announcement> announcements;

  protected FootballTeam()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Player> getFirstEleven()
  { ... /* omitted */ }

  public EList<Player> getSpareTeam()
  { ... /* omitted */ }

  public EList<Player> getPlayers()
  { ... /* omitted */ }

  public EList<Announcement> getAnnouncements()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total number of goal-scoring announcements made by forwards in the starting eleven
   * Algorithm:
   *   1. Initialize count = 0
   *   2. For each player in firstEleven list:
   *       2.1 If player.position is FORWARD:
   *           2.1.1 For each announcement in announcements list:
   *               2.1.1.1 If announcement.player equals player AND announcement.type is SCORE:
   *                   2.1.1.1.1 count = count + 1
   *   3. Return count
   * Input: None
   * Output: Integer representing total goal-scoring announcements by starting eleven forwards (range: 0 to max integer)
   * Pre-condition: firstEleven list and announcements list must be initialized
   * Post-condition: Returns correct count without modifying any data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateTotalGoalScoringAnnouncementsForFirstEleven()
  {
    int count = 0;
    if (getFirstEleven() != null && getAnnouncements() != null) {
      for (Player player : getFirstEleven()) {
        if (player.getPosition() == Position.FORWARD) {
          for (Announcement announcement : getAnnouncements()) {
            if (announcement.getPlayer() == player && announcement.getType() == AnnouncementType.SCORE) {
              count++;
            }
          }
        }
      }
    }
    return count;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Finds the midfielder player with the highest jersey number from all players
   * Algorithm:
   *   1. Initialize highestMidfielder = null, highestNumber = -1
   *   2. For each player in players list:
   *       2.1 If player.position is MIDFIELD:
   *           2.1.1 If player.number > highestNumber:
   *               2.1.1.1 highestNumber = player.number
   *               2.1.1.2 highestMidfielder = player
   *   3. Return highestMidfielder
   * Input: None
   * Output: Player object (midfielder with highest number) or null if no midfielders found
   * Pre-condition: players list must be initialized
   * Post-condition: Returns correct player or null without modifying any data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Player findMidfielderWithHighestNumber()
  {
    Player highestMidfielder = null;
    int highestNumber = -1;
    if (getPlayers() != null) {
      for (Player player : getPlayers()) {
        if (player.getPosition() == Position.MIDFIELD) {
          int currentNumber = player.getNumber();
          if (currentNumber > highestNumber) {
            highestNumber = currentNumber;
            highestMidfielder = player;
          }
        }
      }
    }
    return highestMidfielder;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the average age of players in the spare team
   * Algorithm:
   *   1. If spareTeam is empty, return 0.0
   *   2. Initialize totalAge = 0
   *   3. For each player in spareTeam list:
   *       3.1 totalAge = totalAge + player.age
   *   4. average = totalAge / spareTeam.size()
   *   5. Return average as double
   * Input: None
   * Output: Double value representing average age (range: 0.0 or positive floating-point numbers)
   * Pre-condition: spareTeam list must be initialized
   * Post-condition: Returns correct average without modifying any data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateAverageAgeOfSpareTeam()
  {
    if (getSpareTeam() == null || getSpareTeam().isEmpty()) {
      return 0.0;
    }
    
    int totalAge = 0;
    for (Player player : getSpareTeam()) {
      totalAge += player.getAge();
    }
    
    return (double) totalAge / getSpareTeam().size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts goal-saving announcements made by all goalkeepers on the team
   * Algorithm:
   *   1. Initialize count = 0
   *   2. For each announcement in announcements list:
   *       2.1 If announcement.type is SAVE AND announcement.player.position is GOALKEEPER:
   *           2.1.1 count = count + 1
   *   3. Return count
   * Input: None
   * Output: Integer representing total goal-saving announcements by goalkeepers (range: 0 to max integer)
   * Pre-condition: announcements list must be initialized
   * Post-condition: Returns correct count without modifying any data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateGoalSavingAnnouncementsByGoalkeeper()
  {
    int count = 0;
    if (getAnnouncements() != null) {
      for (Announcement announcement : getAnnouncements()) {
        if (announcement.getType() == AnnouncementType.SAVE && 
            announcement.getPlayer().getPosition() == Position.GOALKEEPER) {
          count++;
        }
      }
    }
    return count;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates total announcements made by all forward players on the team
   * Algorithm:
   *   1. Initialize count = 0
   *   2. For each announcement in announcements list:
   *       2.1 If announcement.player.position is FORWARD:
   *           2.1.1 count = count + 1
   *   3. Return count
   * Input: None
   * Output: Integer representing total announcements by forwards (range: 0 to max integer)
   * Pre-condition: announcements list must be initialized
   * Post-condition: Returns correct count without modifying any data
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateTotalAnnouncementsForForwardPlayers()
  {
    int count = 0;
    if (getAnnouncements() != null) {
      for (Announcement announcement : getAnnouncements()) {
        if (announcement.getPlayer().getPosition() == Position.FORWARD) {
          count++;
        }
      }
    }
    return count;
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // FootballTeam
655141 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../FootballTeam/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../FootballTeam/src-gen/edu/footballteam/
655260 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
655260 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
655260 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
655261 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
655262 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample4.mwe2 启动完成
正在拷贝 src-gen/edu/footballteam 到 deepseek-v3.2-exp/footballteam4...
拷贝完成！

======================================
正在启动 sample5.mwe2...
======================================
655580 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
655672 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project FootballTeam at 'file:/D:/EclipseWorkspace/FootballTeam/'
655676 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
655687 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@66e44f9f
655687 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
655692 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
655693 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
Turgutlu football team has more than one football player. 
The system can perform the first eleven and spare team listing operations.
Football players have team, name, age, and number information. 
Each football player has a different duty and plays football according to their position. Positions are forward, midfield, and defense. There are strikers in the forward, and they play to score goals. There is a goalkeeper in the defense, and he plays to clear the ball. There are midfielders in the midfield, distributing the ball around the pitch. On the system, when the striker scores goals, the system announces his number and name. 
When the goalkeeper saves the goal, the system announces his number and name.
Function Requirement:
+ Calculate the total number of goal-scoring announcements for the starting eleven players of a given football team. Count score announcements issued by the starting eleven. Because only forwards can generate score announcements, goals scored by other positions are ignored.
+ Identify midfielder with highest number. Find the midfielder player with the highest number within all players of a football team. Return null if no midfielders found. 
+ Calculate average age of spare team players. Compute the average age of players in the spare team of a football team. Return the value as a floating-point number (e.g., 24.7). If the reserve team is empty, return 0.0.
+ Count the number of goal-saving announcements made by all goalkeepers on the team.  Only announcements generated by players whose position is GOALKEEPER are considered. Return 0 if no such announcements exist.
+ Calculate the total number of announcements made by all forwards on the team. Return 0 if there are no forwards or no announcements.
```

# Class Diagram
```plantuml
@startuml

title footballteam Model

class Announcement {
    time : EDate
    type : AnnouncementType
    player : Player
}
class FootballTeam {
    announcements : List<Announcement>
    firstEleven : List<Player>
    players : List<Player>
    spareTeam : List<Player>
    calculateAverageAgeOfSpareTeam() : double
    calculateGoalSavingAnnouncementsByGoalkeeper() : int
    calculateTotalAnnouncementsForForwardPlayers() : int
    calculateTotalGoalScoringAnnouncementsForFirstEleven() : int
    findMidfielderWithHighestNumber() : Player
}
class Player {
    age : int
    name : String
    number : int
    position : Position
}
enum AnnouncementType {
    SCORE
    SAVE
}
enum Position {
    FORWARD
    MIDFIELD
    DEFENSE
    GOALKEEPER
}

Announcement --> Player : player
FootballTeam *-- "*" Announcement : announcements
FootballTeam --> "*" Player : firstEleven
FootballTeam *-- "*" Player : players
FootballTeam --> "*" Player : spareTeam
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

698486 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@38568876 (name: calculateAverageAgeOfSpareTeam) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Computes the average age of all players in the spare team.
Algorithm:
  1. If spareTeam is empty: return 0.0
  2. Initialize totalAge = 0
  3. For each player in spareTeam:
       totalAge += player.age
  4. Return totalAge / spareTeam.size() as double
Input: None
Output: Average age of spare team players (double, >= 0.0)
Pre-condition: spareTeam list must be initialized
Post-condition: Returns average age or 0.0 if spare team is empty, org.eclipse.emf.ecore.impl.EOperationImpl@6c4c32ff (name: calculateTotalAnnouncementsForForwardPlayers) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates total announcements (both SCORE and SAVE) made by all forward players.
Algorithm:
  1. Initialize count = 0
  2. For each announcement in announcements:
       a. If announcement.player.position == FORWARD:
           count++
  3. Return count
Input: None
Output: Total count of all announcements by forwards (integer, >= 0)
Pre-condition: announcements list must be initialized
Post-condition: Returns sum of all announcements for forward players, org.eclipse.emf.ecore.impl.EOperationImpl@5799b8a2 (name: calculateTotalGoalScoringAnnouncementsForFirstEleven) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates the total number of goal-scoring announcements made by starting eleven players who are forwards.
Algorithm:
  1. Initialize count = 0
  2. For each player in firstEleven:
       a. If player.position == FORWARD:
           i. For each announcement in announcements:
               - If announcement.player == player AND announcement.type == SCORE:
                   count++
  3. Return count
Input: None
Output: Total count of goal-scoring announcements by forwards in first eleven (integer, >= 0)
Pre-condition: firstEleven list must be initialized
Post-condition: Returns sum of valid SCORE announcements for forward players in first eleven, org.eclipse.emf.ecore.impl.EOperationImpl@5f662dd (name: findMidfielderWithHighestNumber) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Finds the midfielder player with the highest jersey number from all players in the team.
Algorithm:
  1. Initialize highestPlayer = null
  2. For each player in players:
       a. If player.position == MIDFIELD:
           i. If highestPlayer is null OR player.number > highestPlayer.number:
               highestPlayer = player
  3. Return highestPlayer
Input: None
Output: Midfielder player with highest number (Player object) or null if no midfielders exist
Pre-condition: players list must be initialized
Post-condition: Returns either the midfielder with max number or null, org.eclipse.emf.ecore.impl.EOperationImpl@760ac834 (name: calculateGoalSavingAnnouncementsByGoalkeeper) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Counts all goal-saving announcements made by goalkeepers in the team.
Algorithm:
  1. Initialize count = 0
  2. For each announcement in announcements:
       a. If announcement.type == SAVE AND announcement.player.position == GOALKEEPER:
           count++
  3. Return count
Input: None
Output: Total count of SAVE announcements by goalkeepers (integer, >= 0)
Pre-condition: announcements list must be initialized
Post-condition: Returns sum of valid SAVE announcements for goalkeeper players}
698488 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
698547 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../FootballTeam/src-gen/edu/footballteam
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.footballteam;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Football Team</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.footballteam.FootballTeam#getFirstEleven <em>First Eleven</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getSpareTeam <em>Spare Team</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getPlayers <em>Players</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getAnnouncements <em>Announcements</em>}</li>
 * </ul>
 *
 * @see edu.footballteam.FootballteamPackage#getFootballTeam()
 * @model kind="class"
 * @generated
 */
public class FootballTeam extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Player> firstEleven;

  protected EList<Player> spareTeam;

  protected EList<Player> players;

  protected EList<Announcement> announcements;

  protected FootballTeam()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Player> getFirstEleven()
  { ... /* omitted */ }

  public EList<Player> getSpareTeam()
  { ... /* omitted */ }

  public EList<Player> getPlayers()
  { ... /* omitted */ }

  public EList<Announcement> getAnnouncements()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total number of goal-scoring announcements made by starting eleven players who are forwards.
   * Algorithm:
   *   1. Initialize count = 0
   *   2. For each player in firstEleven:
   *        a. If player.position == FORWARD:
   *            i. For each announcement in announcements:
   *                - If announcement.player == player AND announcement.type == SCORE:
   *                    count++
   *   3. Return count
   * Input: None
   * Output: Total count of goal-scoring announcements by forwards in first eleven (integer, >= 0)
   * Pre-condition: firstEleven list must be initialized
   * Post-condition: Returns sum of valid SCORE announcements for forward players in first eleven
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int calculateTotalGoalScoringAnnouncementsForFirstEleven()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Finds the midfielder player with the highest jersey number from all players in the team.
   * Algorithm:
   *   1. Initialize highestPlayer = null
   *   2. For each player in players:
   *        a. If player.position == MIDFIELD:
   *            i. If highestPlayer is null OR player.number > highestPlayer.number:
   *                highestPlayer = player
   *   3. Return highestPlayer
   * Input: None
   * Output: Midfielder player with highest number (Player object) or null if no midfielders exist
   * Pre-condition: players list must be initialized
   * Post-condition: Returns either the midfielder with max number or null
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public Player findMidfielderWithHighestNumber()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Computes the average age of all players in the spare team.
   * Algorithm:
   *   1. If spareTeam is empty: return 0.0
   *   2. Initialize totalAge = 0
   *   3. For each player in spareTeam:
   *        totalAge += player.age
   *   4. Return totalAge / spareTeam.size() as double
   * Input: None
   * Output: Average age of spare team players (double, >= 0.0)
   * Pre-condition: spareTeam list must be initialized
   * Post-condition: Returns average age or 0.0 if spare team is empty
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double calculateAverageAgeOfSpareTeam()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts all goal-saving announcements made by goalkeepers in the team.
   * Algorithm:
   *   1. Initialize count = 0
   *   2. For each announcement in announcements:
   *        a. If announcement.type == SAVE AND announcement.player.position == GOALKEEPER:
   *            count++
   *   3. Return count
   * Input: None
   * Output: Total count of SAVE announcements by goalkeepers (integer, >= 0)
   * Pre-condition: announcements list must be initialized
   * Post-condition: Returns sum of valid SAVE announcements for goalkeeper players
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int calculateGoalSavingAnnouncementsByGoalkeeper()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates total announcements (both SCORE and SAVE) made by all forward players.
   * Algorithm:
   *   1. Initialize count = 0
   *   2. For each announcement in announcements:
   *        a. If announcement.player.position == FORWARD:
   *            count++
   *   3. Return count
   * Input: None
   * Output: Total count of all announcements by forwards (integer, >= 0)
   * Pre-condition: announcements list must be initialized
   * Post-condition: Returns sum of all announcements for forward players
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int calculateTotalAnnouncementsForForwardPlayers()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // FootballTeam
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Player` contains the following methods.
  + Instance creation: Use `FootballteamFactory.eINSTANCE.createPlayer()`
  + Getter methods: public String getName(), public int getAge(), public int getNumber(), public Position getPosition()
  + Setter methods: public void setName(String newName), public void setAge(int newAge), public void setNumber(int newNumber), public void setPosition(Position newPosition)
- Class `Announcement` contains the following methods.
  + Instance creation: Use `FootballteamFactory.eINSTANCE.createAnnouncement()`
  + Getter methods: public Date getTime(), public AnnouncementType getType(), public Player getPlayer()
  + Setter methods: public void setTime(Date newTime), public void setType(AnnouncementType newType), public void setPlayer(Player newPlayer)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.footballteam;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Football Team</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.footballteam.FootballTeam#getFirstEleven <em>First Eleven</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getSpareTeam <em>Spare Team</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getPlayers <em>Players</em>}</li>
 *   <li>{@link edu.footballteam.FootballTeam#getAnnouncements <em>Announcements</em>}</li>
 * </ul>
 *
 * @see edu.footballteam.FootballteamPackage#getFootballTeam()
 * @model kind="class"
 * @generated
 */
public class FootballTeam extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Player> firstEleven;

  protected EList<Player> spareTeam;

  protected EList<Player> players;

  protected EList<Announcement> announcements;

  protected FootballTeam()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Player> getFirstEleven()
  { ... /* omitted */ }

  public EList<Player> getSpareTeam()
  { ... /* omitted */ }

  public EList<Player> getPlayers()
  { ... /* omitted */ }

  public EList<Announcement> getAnnouncements()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total number of goal-scoring announcements made by starting eleven players who are forwards.
   * Algorithm:
   *   1. Initialize count = 0
   *   2. For each player in firstEleven:
   *        a. If player.position == FORWARD:
   *            i. For each announcement in announcements:
   *                - If announcement.player == player AND announcement.type == SCORE:
   *                    count++
   *   3. Return count
   * Input: None
   * Output: Total count of goal-scoring announcements by forwards in first eleven (integer, >= 0)
   * Pre-condition: firstEleven list must be initialized
   * Post-condition: Returns sum of valid SCORE announcements for forward players in first eleven
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateTotalGoalScoringAnnouncementsForFirstEleven()
  {
    int count = 0;
    if (getFirstEleven() != null && getAnnouncements() != null) {
      for (Player player : getFirstEleven()) {
        if (player.getPosition() == Position.FORWARD) {
          for (Announcement announcement : getAnnouncements()) {
            if (announcement.getPlayer() == player && announcement.getType() == AnnouncementType.SCORE) {
              count++;
            }
          }
        }
      }
    }
    return count;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Finds the midfielder player with the highest jersey number from all players in the team.
   * Algorithm:
   *   1. Initialize highestPlayer = null
   *   2. For each player in players:
   *        a. If player.position == MIDFIELD:
   *            i. If highestPlayer is null OR player.number > highestPlayer.number:
   *                highestPlayer = player
   *   3. Return highestPlayer
   * Input: None
   * Output: Midfielder player with highest number (Player object) or null if no midfielders exist
   * Pre-condition: players list must be initialized
   * Post-condition: Returns either the midfielder with max number or null
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Player findMidfielderWithHighestNumber()
  {
    Player highestPlayer = null;
    if (getPlayers() != null) {
      for (Player player : getPlayers()) {
        if (player.getPosition() == Position.MIDFIELD) {
          if (highestPlayer == null || player.getNumber() > highestPlayer.getNumber()) {
            highestPlayer = player;
          }
        }
      }
    }
    return highestPlayer;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Computes the average age of all players in the spare team.
   * Algorithm:
   *   1. If spareTeam is empty: return 0.0
   *   2. Initialize totalAge = 0
   *   3. For each player in spareTeam:
   *        totalAge += player.age
   *   4. Return totalAge / spareTeam.size() as double
   * Input: None
   * Output: Average age of spare team players (double, >= 0.0)
   * Pre-condition: spareTeam list must be initialized
   * Post-condition: Returns average age or 0.0 if spare team is empty
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateAverageAgeOfSpareTeam()
  {
    if (getSpareTeam() == null || getSpareTeam().isEmpty()) {
      return 0.0;
    }
    
    int totalAge = 0;
    for (Player player : getSpareTeam()) {
      totalAge += player.getAge();
    }
    
    return (double) totalAge / getSpareTeam().size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts all goal-saving announcements made by goalkeepers in the team.
   * Algorithm:
   *   1. Initialize count = 0
   *   2. For each announcement in announcements:
   *        a. If announcement.type == SAVE AND announcement.player.position == GOALKEEPER:
   *            count++
   *   3. Return count
   * Input: None
   * Output: Total count of SAVE announcements by goalkeepers (integer, >= 0)
   * Pre-condition: announcements list must be initialized
   * Post-condition: Returns sum of valid SAVE announcements for goalkeeper players
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateGoalSavingAnnouncementsByGoalkeeper()
  {
    int count = 0;
    if (getAnnouncements() != null) {
      for (Announcement announcement : getAnnouncements()) {
        if (announcement.getType() == AnnouncementType.SAVE && 
            announcement.getPlayer() != null && 
            announcement.getPlayer().getPosition() == Position.GOALKEEPER) {
          count++;
        }
      }
    }
    return count;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates total announcements (both SCORE and SAVE) made by all forward players.
   * Algorithm:
   *   1. Initialize count = 0
   *   2. For each announcement in announcements:
   *        a. If announcement.player.position == FORWARD:
   *            count++
   *   3. Return count
   * Input: None
   * Output: Total count of all announcements by forwards (integer, >= 0)
   * Pre-condition: announcements list must be initialized
   * Post-condition: Returns sum of all announcements for forward players
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateTotalAnnouncementsForForwardPlayers()
  {
    int count = 0;
    if (getAnnouncements() != null) {
      for (Announcement announcement : getAnnouncements()) {
        if (announcement.getPlayer() != null && announcement.getPlayer().getPosition() == Position.FORWARD) {
          count++;
        }
      }
    }
    return count;
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // FootballTeam
769129 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../FootballTeam/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../FootballTeam/src-gen/edu/footballteam/
769256 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
769256 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
769256 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
769257 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
769258 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample5.mwe2 启动完成
正在拷贝 src-gen/edu/footballteam 到 deepseek-v3.2-exp/footballteam5...
拷贝完成！

======================================
所有任务完成！
======================================

/**
 * generated by Enhanced EcoreGen
 */
package edu.fs;

import java.util.Collection;
import java.util.Date;
import java.util.Map;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;
import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EMap;
import org.eclipse.emf.common.util.BasicEMap;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>File System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.fs.FileSystem#getDocuments <em>Documents</em>}</li>
 *   <li>{@link edu.fs.FileSystem#getEditors <em>Editors</em>}</li>
 * </ul>
 *
 * @see edu.fs.FsPackage#getFileSystem()
 * @model kind="class"
 * @generated
 */
public class FileSystem extends MinimalEObjectImpl.Container implements EObject
{
  /**
   * The cached value of the '{@link #getDocuments() <em>Documents</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getDocuments()
   * @generated
   * @ordered
   */
  protected EList<Document> documents;

  /**
   * The cached value of the '{@link #getEditors() <em>Editors</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getEditors()
   * @generated
   * @ordered
   */
  protected EList<Editor> editors;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected FileSystem()
  {
    super();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  protected EClass eStaticClass()
  {
    return FsPackage.Literals.FILE_SYSTEM;
  }

  /**
   * Returns the value of the '<em><b>Documents</b></em>' containment reference list.
   * The list contents are of type {@link edu.fs.Document}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Documents</em>' containment reference list.
   * @see edu.fs.FsPackage#getFileSystem_Documents()
   * @model containment="true"
   * @generated
   */
  public EList<Document> getDocuments()
  {
    if (documents == null)
    {
      documents = new EObjectContainmentEList<Document>(Document.class, this, FsPackage.FILE_SYSTEM__DOCUMENTS);
    }
    return documents;
  }

  /**
   * Returns the value of the '<em><b>Editors</b></em>' containment reference list.
   * The list contents are of type {@link edu.fs.Editor}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Editors</em>' containment reference list.
   * @see edu.fs.FsPackage#getFileSystem_Editors()
   * @model containment="true"
   * @generated
   */
  public EList<Editor> getEditors()
  {
    if (editors == null)
    {
      editors = new EObjectContainmentEList<Editor>(Editor.class, this, FsPackage.FILE_SYSTEM__EDITORS);
    }
    return editors;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: This operation calculates the total size of all documents in the file system.
   * 
   * Algorithm: Iterate through all documents in the file system and sum up their sizes.
   * 
   * Input: None
   * 
   * Output: The total size of all documents in the file system. The output is an integer value representing the total size. If there are no documents, it returns 0.
   * 
   * Pre-condition: The file system is properly initialized with a list of documents.
   * Post-condition: The total size of all documents is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateTotalDocumentSize()
  {
    int totalSize = 0;
    for (Document document : getDocuments()) {
      totalSize += document.getSize();
    }
    return totalSize;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: This operation computes the average size of all documents for each editor (Text Editor, Image Editor, and Video Editor) in the file system.
   * 
   * Algorithm: For each editor in the file system, sum up the sizes of all documents associated with it and divide by the number of documents. Store the average sizes in a map with the editor type as the key.
   * 
   * Input: None
   * 
   * Output: A map (EMap) where the keys are the types of editors (TextEditor, ImageEditor, VideoEditor) and the values are the corresponding average sizes of documents. If there are no documents for an editor type, the average size will be 0.
   * 
   * Pre-condition: The file system is properly initialized with a list of editors and documents.
   * Post-condition: A map containing the average size of documents for each editor type is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EMap<String, Float> findAverageSizePerEditor()
  {
    EMap<String, Float> averageSizes = new BasicEMap<String, Float>();
    for (Editor editor : getEditors()) {
      String editorType = editor.getName(); 
      EList<Document> documentsForEditor = editor.getDocuments();
      int totalSize = 0;
      for (Document document : documentsForEditor) {
        totalSize += document.getSize();
      }
      float averageSize = documentsForEditor.isEmpty() ? 0 : (float) totalSize / documentsForEditor.size();
      averageSizes.put(editorType, averageSize);
    }
    return averageSizes;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: This operation counts the number of documents in the file system that were created after a specified date.
   * 
   * Algorithm: Iterate through all documents in the file system and count the ones with a creation date later than the specified date.
   * 
   * Input: 
   *   - date: The specified date to compare with the document creation dates. The date should be in a valid date format (EDate).
   * 
   * Output: The number of documents created after the specified date. The output is an integer value. If there are no documents or no documents after the specified date, it returns 0.
   * 
   * Pre-condition: The file system is properly initialized with a list of documents, and the input date is a valid EDate object.
   * Post-condition: The count of documents created after the specified date is returned.
   * <!-- end-model-doc -->
   * @model dateRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int countDocumentsAfterDate(final Date date)
  {
    int count = 0;
    for (Document document : getDocuments()) {
      if (document.getCreateDate().after(date)) {
        count++;
      }
    }
    return count;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: This operation retrieves the names of all authors whose documents are edited with a specified editor in the file system.
   * 
   * Algorithm: Iterate through all documents associated with the specified editor and collect the authors' names in a list.
   * 
   * Input: 
   *   - editor: The editor for which to retrieve the authors. The input should be a valid Editor object (TextEditor, ImageEditor, or VideoEditor).
   * 
   * Output: A list of authors' names (List<String>) whose documents are edited with the specified editor. If there are no documents associated with the editor, an empty list is returned.
   * 
   * Pre-condition: The file system is properly initialized with a list of editors and documents, and the input editor is a valid Editor object.
   * Post-condition: A list of authors' names associated with the specified editor is returned.
   * <!-- end-model-doc -->
   * @model editorRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> getAuthorsByEditor(final Editor editor)
  {
    EList<String> authors = new BasicEList<String>();
    for (Document document : editor.getDocuments()) {
      authors.add(document.getAuthor());
    }
    return authors;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: This operation counts the number of documents for each editor type (TextEditor, ImageEditor, VideoEditor) in the file system.
   * 
   * Algorithm: Iterate through all editors in the file system, and for each editor, count the number of documents associated with it. Store the counts in a map with the editor type as the key.
   * 
   * Input: None
   * 
   * Output: A map (EMap) where the keys are the types of editors (TextEditor, ImageEditor, VideoEditor) and the values are the corresponding counts of documents. If there are no documents for an editor type, the count will be 0.
   * 
   * Pre-condition: The file system is properly initialized with a list of editors and documents.
   * Post-condition: A map containing the count of documents for each editor type is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EMap<String, Integer> countDocumentsPerEditorType()
  {
    EMap<String, Integer> documentCounts = new BasicEMap<String, Integer>();
    for (Editor editor : getEditors()) {
      String editorType = editor.getName(); 
      int count = editor.getDocuments().size();
      documentCounts.put(editorType, count);
    }
    return documentCounts;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        return ((InternalEList<?>)getDocuments()).basicRemove(otherEnd, msgs);
      case FsPackage.FILE_SYSTEM__EDITORS:
        return ((InternalEList<?>)getEditors()).basicRemove(otherEnd, msgs);
    }
    return super.eInverseRemove(otherEnd, featureID, msgs);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        return getDocuments();
      case FsPackage.FILE_SYSTEM__EDITORS:
        return getEditors();
    }
    return super.eGet(featureID, resolve, coreType);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        getDocuments().clear();
        getDocuments().addAll((Collection<? extends Document>)newValue);
        return;
      case FsPackage.FILE_SYSTEM__EDITORS:
        getEditors().clear();
        getEditors().addAll((Collection<? extends Editor>)newValue);
        return;
    }
    super.eSet(featureID, newValue);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public void eUnset(int featureID)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        getDocuments().clear();
        return;
      case FsPackage.FILE_SYSTEM__EDITORS:
        getEditors().clear();
        return;
    }
    super.eUnset(featureID);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public boolean eIsSet(int featureID)
  {
    switch (featureID)
    {
      case FsPackage.FILE_SYSTEM__DOCUMENTS:
        return documents != null && !documents.isEmpty();
      case FsPackage.FILE_SYSTEM__EDITORS:
        return editors != null && !editors.isEmpty();
    }
    return super.eIsSet(featureID);
  }

} // FileSystem

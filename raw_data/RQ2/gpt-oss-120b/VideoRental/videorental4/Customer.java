/**
 * generated by Enhanced EcoreGen
 */
package edu.videorental;

import java.util.Collection;
import java.util.Date;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.EObjectWithInverseResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;
import java.util.Calendar;
import org.eclipse.emf.common.util.BasicEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Customer</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.videorental.Customer#getId <em>Id</em>}</li>
 *   <li>{@link edu.videorental.Customer#getRentals <em>Rentals</em>}</li>
 *   <li>{@link edu.videorental.Customer#getTransactions <em>Transactions</em>}</li>
 * </ul>
 *
 * @see edu.videorental.VideorentalPackage#getCustomer()
 * @model kind="class"
 * @generated
 */
public class Customer extends MinimalEObjectImpl.Container implements EObject
{
  /**
   * The default value of the '{@link #getId() <em>Id</em>}' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getId()
   * @generated
   * @ordered
   */
  protected static final String ID_EDEFAULT = null;

  /**
   * The cached value of the '{@link #getId() <em>Id</em>}' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getId()
   * @generated
   * @ordered
   */
  protected String id = ID_EDEFAULT;

  /**
   * The cached value of the '{@link #getRentals() <em>Rentals</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getRentals()
   * @generated
   * @ordered
   */
  protected EList<VideoRental> rentals;

  /**
   * The cached value of the '{@link #getTransactions() <em>Transactions</em>}' reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getTransactions()
   * @generated
   * @ordered
   */
  protected EList<RentalTransaction> transactions;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected Customer()
  {
    super();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  protected EClass eStaticClass()
  {
    return VideorentalPackage.Literals.CUSTOMER;
  }

  /**
   * Returns the value of the '<em><b>Id</b></em>' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Id</em>' attribute.
   * @see #setId(String)
   * @see edu.videorental.VideorentalPackage#getCustomer_Id()
   * @model
   * @generated
   */
  public String getId()
  {
    return id;
  }

  /**
   * Sets the value of the '{@link edu.videorental.Customer#getId <em>Id</em>}' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @param newId the new value of the '<em>Id</em>' attribute.
   * @see #getId()
   * @generated
   */
  public void setId(String newId)
  {
    String oldId = id;
    id = newId;
    if (eNotificationRequired())
      eNotify(new ENotificationImpl(this, Notification.SET, VideorentalPackage.CUSTOMER__ID, oldId, id));
  }

  /**
   * Returns the value of the '<em><b>Rentals</b></em>' containment reference list.
   * The list contents are of type {@link edu.videorental.VideoRental}.
   * It is bidirectional and its opposite is '{@link edu.videorental.VideoRental#getCustomer <em>Customer</em>}'.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Rentals</em>' containment reference list.
   * @see edu.videorental.VideorentalPackage#getCustomer_Rentals()
   * @see edu.videorental.VideoRental#getCustomer
   * @model opposite="customer" containment="true" upper="20"
   * @generated
   */
  public EList<VideoRental> getRentals()
  {
    if (rentals == null)
    {
      rentals = new EObjectContainmentWithInverseEList<VideoRental>(VideoRental.class, this, VideorentalPackage.CUSTOMER__RENTALS, VideorentalPackage.VIDEO_RENTAL__CUSTOMER);
    }
    return rentals;
  }

  /**
   * Returns the value of the '<em><b>Transactions</b></em>' reference list.
   * The list contents are of type {@link edu.videorental.RentalTransaction}.
   * It is bidirectional and its opposite is '{@link edu.videorental.RentalTransaction#getCustomer <em>Customer</em>}'.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Transactions</em>' reference list.
   * @see edu.videorental.VideorentalPackage#getCustomer_Transactions()
   * @see edu.videorental.RentalTransaction#getCustomer
   * @model opposite="customer"
   * @generated
   */
  public EList<RentalTransaction> getTransactions()
  {
    if (transactions == null)
    {
      transactions = new EObjectWithInverseResolvingEList<RentalTransaction>(RentalTransaction.class, this, VideorentalPackage.CUSTOMER__TRANSACTIONS, VideorentalPackage.RENTAL_TRANSACTION__CUSTOMER);
    }
    return transactions;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Attempts to create a new VideoRental for the given tape on behalf of this
   *   customer at the supplied currentDate. The operation succeeds only if the
   *   customer has fewer than 20 active rentals, has no outstanding past‑due
   *   amount, and the tape is available on currentDate.
   * Algorithm:
   *   1. Verify that the number of active rentals (rentals with returnDate == null)
   *      belonging to this customer is < 20.
   *   2. Call this.calculateTotalPastDueAmount(currentDate); if the returned
   *      amount > 0.0, reject the operation.
   *   3. Call tape.isAvailable(currentDate); if false, reject the operation.
   *   4. Create a new VideoRental instance:
   *        rental.tape        = tape
   *        rental.customer    = this
   *        rental.transaction = a new RentalTransaction (or the currently open one)
   *        rental.dueDate     = currentDate plus default rental period (e.g., 7 days)
   *        rental.returnDate  = null
   *        rental.ownedPastDueAmount = 0.0
   *   5. Add rental to this.rentals, tape.rentals, and transaction.rentals.
   *   6. Return true.
   * Input:
   *   tape        – Tape object to be rented; must not be null.
   *   currentDate – EDate representing the system date/time of the rental
   *                 (format "yyyy-MM-dd HH:mm:ss").
   * Output:
   *   boolean – true if the rental is successfully created; false otherwise.
   * Pre‑condition:
   *   - The customer record exists and is loaded.
   *   - The tape object exists in inventory.
   * Post‑condition:
   *   - If true is returned, a new active VideoRental links the customer and tape,
   *     and both the customer's and tape's rental collections are updated.
   *   - If false is returned, no changes are made to any collections.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean addVedioTapeRental(final Tape tape, final Date currentDate)
  {
    // Validate input
    if (tape == null || currentDate == null) {
      return false;
    }

    // 1. Check active rentals count (<20)
    int activeCount = 0;
    for (VideoRental vr : getRentals()) {
      if (vr.getReturnDate() == null) {
        activeCount++;
      }
    }
    if (activeCount >= 20) {
      return false;
    }

    // 2. Check past‑due amount
    if (calculateTotalPastDueAmount(currentDate) > 0.0) {
      return false;
    }

    // 3. Check tape availability
    if (!tape.isAvailable(currentDate)) {
      return false;
    }

    // 4. Create a new VideoRental
    VideoRental rental = VideorentalFactory.eINSTANCE.createVideoRental();
    rental.setTape(tape);
    rental.setCustomer(this);

    // Create a new RentalTransaction
    RentalTransaction transaction = VideorentalFactory.eINSTANCE.createRentalTransaction();
    transaction.setCustomer(this);
    transaction.setRentalDate(currentDate);
    // Add transaction to customer's collection
    getTransactions().add(transaction);
    // Link rental to transaction
    rental.setTransaction(transaction);
    // Add rental to transaction's list
    transaction.getRentals().add(rental);

    // Set due date (currentDate + 7 days)
    Calendar cal = Calendar.getInstance();
    cal.setTime(currentDate);
    cal.add(Calendar.DAY_OF_MONTH, 7);
    rental.setDueDate(cal.getTime());

    // Initialize remaining fields
    rental.setReturnDate(null);
    rental.setOwnedPastDueAmount(0.0);

    // 5. Update collections
    getRentals().add(rental);
    tape.getRentals().add(rental);

    // 6. Success
    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves a list of all Tape objects that this customer has rented but not
   *   yet returned (i.e., rentals where returnDate is null).
   * Algorithm:
   *   1. Create empty list result.
   *   2. Iterate over each VideoRental r in this.rentals:
   *        if r.returnDate == null:
   *            add r.tape to result.
   *   3. Return result (may be empty).
   * Input:
   *   (none)
   * Output:
   *   List<Tape> – List containing zero or more Tape objects that are currently
   *                outstanding for this customer.
   * Pre‑condition:
   *   - this.rentals is not null.
   * Post‑condition:
   *   - Returned list is a new collection; modifications to it do not affect the
   *     internal state of the Customer.
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Tape> getUnreturnedTapes()
  {
    BasicEList<Tape> result = new BasicEList<Tape>();
    for (VideoRental rental : getRentals()) {
      if (rental.getReturnDate() == null) {
        result.add(rental.getTape());
      }
    }
    return result;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes the total past‑due amount for all rentals of this customer as of
   *   currentDate. The calculation follows the rule:
   *     overdue fee = overdue days × $0.50, rounded to two decimals.
   * Algorithm:
   *   1. Initialize total = 0.0.
   *   2. For each VideoRental r in this.rentals:
   *        a. Call r.calculateOwnedPastDueAmount(currentDate) → fee.
   *        b. total = total + fee.
   *   3. Round total to two decimal places.
   *   4. Return total.
   * Input:
   *   currentDate – EDate representing the date/time at which the calculation is
   *                 performed (format "yyyy-MM-dd HH:mm:ss").
   * Output:
   *   double – Sum of overdue fees for all rentals (including those not yet
   *            returned). Value rounded to two decimal places; never negative.
   * Pre‑condition:
   *   - this.rentals collection is initialized.
   * Post‑condition:
   *   - No mutation of any object state; pure calculation.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateTotalPastDueAmount(final Date currentDate)
  {
    double total = 0.0;
    for (VideoRental rental : getRentals()) {
      total += rental.calculateOwnedPastDueAmount(currentDate);
    }
    // Round to two decimal places
    total = Math.round(total * 100.0) / 100.0;
    return total;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  {
    switch (featureID)
    {
      case VideorentalPackage.CUSTOMER__RENTALS:
        return ((InternalEList<InternalEObject>)(InternalEList<?>)getRentals()).basicAdd(otherEnd, msgs);
      case VideorentalPackage.CUSTOMER__TRANSACTIONS:
        return ((InternalEList<InternalEObject>)(InternalEList<?>)getTransactions()).basicAdd(otherEnd, msgs);
    }
    return super.eInverseAdd(otherEnd, featureID, msgs);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  {
    switch (featureID)
    {
      case VideorentalPackage.CUSTOMER__RENTALS:
        return ((InternalEList<?>)getRentals()).basicRemove(otherEnd, msgs);
      case VideorentalPackage.CUSTOMER__TRANSACTIONS:
        return ((InternalEList<?>)getTransactions()).basicRemove(otherEnd, msgs);
    }
    return super.eInverseRemove(otherEnd, featureID, msgs);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  {
    switch (featureID)
    {
      case VideorentalPackage.CUSTOMER__ID:
        return getId();
      case VideorentalPackage.CUSTOMER__RENTALS:
        return getRentals();
      case VideorentalPackage.CUSTOMER__TRANSACTIONS:
        return getTransactions();
    }
    return super.eGet(featureID, resolve, coreType);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  {
    switch (featureID)
    {
      case VideorentalPackage.CUSTOMER__ID:
        setId((String)newValue);
        return;
      case VideorentalPackage.CUSTOMER__RENTALS:
        getRentals().clear();
        getRentals().addAll((Collection<? extends VideoRental>)newValue);
        return;
      case VideorentalPackage.CUSTOMER__TRANSACTIONS:
        getTransactions().clear();
        getTransactions().addAll((Collection<? extends RentalTransaction>)newValue);
        return;
    }
    super.eSet(featureID, newValue);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public void eUnset(int featureID)
  {
    switch (featureID)
    {
      case VideorentalPackage.CUSTOMER__ID:
        setId(ID_EDEFAULT);
        return;
      case VideorentalPackage.CUSTOMER__RENTALS:
        getRentals().clear();
        return;
      case VideorentalPackage.CUSTOMER__TRANSACTIONS:
        getTransactions().clear();
        return;
    }
    super.eUnset(featureID);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public boolean eIsSet(int featureID)
  {
    switch (featureID)
    {
      case VideorentalPackage.CUSTOMER__ID:
        return ID_EDEFAULT == null ? id != null : !ID_EDEFAULT.equals(id);
      case VideorentalPackage.CUSTOMER__RENTALS:
        return rentals != null && !rentals.isEmpty();
      case VideorentalPackage.CUSTOMER__TRANSACTIONS:
        return transactions != null && !transactions.isEmpty();
    }
    return super.eIsSet(featureID);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public String toString()
  {
    if (eIsProxy()) return super.toString();

    StringBuilder result = new StringBuilder(super.toString());
    result.append(" (id: ");
    result.append(id);
    result.append(')');
    return result.toString();
  }

} // Customer

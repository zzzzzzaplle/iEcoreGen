/**
 * generated by Enhanced EcoreGen
 */
package edu.carrental;

import java.util.Collection;
import java.util.Date;
import java.util.Map;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.Collections;
import java.util.Comparator;
import org.eclipse.emf.common.util.BasicEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Store</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.carrental.Store#getCars <em>Cars</em>}</li>
 *   <li>{@link edu.carrental.Store#getRentals <em>Rentals</em>}</li>
 *   <li>{@link edu.carrental.Store#getNotices <em>Notices</em>}</li>
 * </ul>
 *
 * @see edu.carrental.CarrentalPackage#getStore()
 * @model kind="class"
 * @generated
 */
public class Store extends MinimalEObjectImpl.Container implements EObject
{
  /**
   * The cached value of the '{@link #getCars() <em>Cars</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getCars()
   * @generated
   * @ordered
   */
  protected EList<Car> cars;

  /**
   * The cached value of the '{@link #getRentals() <em>Rentals</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getRentals()
   * @generated
   * @ordered
   */
  protected EList<Rental> rentals;

  /**
   * The cached value of the '{@link #getNotices() <em>Notices</em>}' containment reference list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getNotices()
   * @generated
   * @ordered
   */
  protected EList<OverdueNotice> notices;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected Store()
  {
    super();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  protected EClass eStaticClass()
  {
    return CarrentalPackage.Literals.STORE;
  }

  /**
   * Returns the value of the '<em><b>Cars</b></em>' containment reference list.
   * The list contents are of type {@link edu.carrental.Car}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Cars</em>' containment reference list.
   * @see edu.carrental.CarrentalPackage#getStore_Cars()
   * @model containment="true"
   * @generated
   */
  public EList<Car> getCars()
  {
    if (cars == null)
    {
      cars = new EObjectContainmentEList<Car>(Car.class, this, CarrentalPackage.STORE__CARS);
    }
    return cars;
  }

  /**
   * Returns the value of the '<em><b>Rentals</b></em>' containment reference list.
   * The list contents are of type {@link edu.carrental.Rental}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Rentals</em>' containment reference list.
   * @see edu.carrental.CarrentalPackage#getStore_Rentals()
   * @model containment="true"
   * @generated
   */
  public EList<Rental> getRentals()
  {
    if (rentals == null)
    {
      rentals = new EObjectContainmentEList<Rental>(Rental.class, this, CarrentalPackage.STORE__RENTALS);
    }
    return rentals;
  }

  /**
   * Returns the value of the '<em><b>Notices</b></em>' containment reference list.
   * The list contents are of type {@link edu.carrental.OverdueNotice}.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @return the value of the '<em>Notices</em>' containment reference list.
   * @see edu.carrental.CarrentalPackage#getStore_Notices()
   * @model containment="true"
   * @generated
   */
  public EList<OverdueNotice> getNotices()
  {
    if (notices == null)
    {
      notices = new EObjectContainmentEList<OverdueNotice>(OverdueNotice.class, this, CarrentalPackage.STORE__NOTICES);
    }
    return notices;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Returns a list of cars that are currently not rented, sorted by their daily price in ascending order.
   * Algorithm:
   *   1. Initialize an empty list `availableCars`.
   *   2. For each `car` in `this.cars`:
   *        a. Assume the car is available.
   *        b. Iterate through `this.rentals`:
   *             i. If a rental's `car.plate` equals `car.plate` AND the rental's `backDate` is null
   *                (i.e., the car has not been returned), mark the car as not available and break.
   *        c. If still marked as available, add `car` to `availableCars`.
   *   3. Sort `availableCars` by `dailyPrice` using a stable ascending comparator.
   *   4. Return `availableCars`. If no car meets the criteria, the list will be empty.
   * Input:
   *   None.
   * Output:
   *   List<Car> – a list containing the available `Car` objects sorted by `dailyPrice` (lowest first).
   *   The list may be empty when all cars are rented.
   * Pre-condition:
   *   - `this.cars` and `this.rentals` are initialized (may be empty).
   * Post-condition:
   *   - The returned list contains exactly those cars that have no active rental (i.e., no rental with a null `backDate`).
   *   - The list is sorted in non‑decreasing order of `dailyPrice`.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Car> identifyAvailableCars()
  {
    // 1. initialize result list
    BasicEList<Car> availableCars = new BasicEList<>();

    // 2. iterate over all cars
    for (Car car : this.cars) {
      boolean isAvailable = true;

      // 2b. check rentals for an active rental of the same car
      for (Rental rental : this.rentals) {
        Car rentedCar = rental.getCar();
        if (rentedCar != null
            && rentedCar.getPlate() != null
            && rentedCar.getPlate().equals(car.getPlate())
            && rental.getBackDate() == null) {
          // active rental found, car not available
          isAvailable = false;
          break;
        }
      }

      // 2c. add if still available
      if (isAvailable) {
        availableCars.add(car);
      }
    }

    // 3. sort by dailyPrice ascending, stable
    Collections.sort(availableCars, new Comparator<Car>() {
      @Override
      public int compare(Car c1, Car c2) {
        return Double.compare(c1.getDailyPrice(), c2.getDailyPrice());
      }
    });

    // 4. return the list
    return availableCars;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Computes the total revenue generated by all completed rentals in the store.
   * Algorithm:
   *   1. Initialize `totalRevenue` to 0.0.
   *   2. For each `rental` in `this.rentals`:
   *        a. If `rental.backDate` is not null (the rental has been returned):
   *             i. Add `rental.totalPrice` to `totalRevenue`.
   *   3. Return `totalRevenue`.
   * Input:
   *   None.
   * Output:
   *   double – the sum of `totalPrice` of all rentals that have a non‑null `backDate`.
   *   If there are no completed rentals, the value returned is 0.0.
   * Pre-condition:
   *   - `this.rentals` is initialized.
   * Post-condition:
   *   - Returned value equals Σ `rental.totalPrice` for all rentals with a recorded `backDate`.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double calculateTotalRevenue()
  {
    double totalRevenue = 0.0;

    for (Rental rental : this.rentals) {
      if (rental.getBackDate() != null) {
        totalRevenue += rental.getTotalPrice();
      }
    }

    return totalRevenue;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Retrieves all customers whose rentals are overdue as of the supplied `currentDate`.
   * Algorithm:
   *   1. Create an empty set `overdueCustomers`.
   *   2. For each `rental` in `this.rentals`:
   *        a. If `rental.backDate` is null (car not yet returned) AND
   *           `currentDate` > `rental.dueDate` (lexicographic/date comparison):
   *               i. Add `rental.customer` to `overdueCustomers`.
   *   3. Convert `overdueCustomers` to a List<Customer> preserving insertion order or sort by name.
   *   4. Return the list (empty if no overdue rentals).
   * Input:
   *   - currentDate : EDate
   *       * Meaning: the date against which overdue status is evaluated.
   *       * Format: string following ISO‑8601 date pattern `yyyy-MM-dd`.
   *       * Range: any valid calendar date; must be parsable.
   * Output:
   *   List<Customer> – list of distinct customers with at least one overdue rental.
   *   The list may be empty.
   * Pre-condition:
   *   - `currentDate` is a valid, non‑null date string conforming to `yyyy-MM-dd`.
   *   - `this.rentals` is initialized.
   * Post-condition:
   *   - Every customer in the returned list satisfies: exists a rental with null `backDate` and `dueDate` < `currentDate`.
   *   - No customer without an overdue rental appears in the list.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Customer> findCustomersWithOverdueRentals(final Date currentDate)
  {
    // 1. collect distinct customers
    Set<Customer> overdueSet = new HashSet<>();

    for (Rental rental : this.rentals) {
      if (rental.getBackDate() == null && currentDate.after(rental.getDueDate())) {
        Customer cust = rental.getCustomer();
        if (cust != null) {
          overdueSet.add(cust);
        }
      }
    }

    // 2. convert to list and sort by name then surname for deterministic order
    List<Customer> resultList = new ArrayList<>(overdueSet);
    Collections.sort(resultList, new Comparator<Customer>() {
      @Override
      public int compare(Customer c1, Customer c2) {
        int nameCmp = c1.getName().compareTo(c2.getName());
        if (nameCmp != 0) return nameCmp;
        return c1.getSurname().compareTo(c2.getSurname());
      }
    });

    // 3. return as EList
    BasicEList<Customer> eResult = new BasicEList<>(resultList);
    return eResult;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Calculates the average daily price of all cars stored in the gallery.
   * Algorithm:
   *   1. If `this.cars` is empty, return 0.0.
   *   2. Initialize `sumPrice` to 0.0.
   *   3. For each `car` in `this.cars`, add `car.dailyPrice` to `sumPrice`.
   *   4. Compute `average = sumPrice / this.cars.size()`.
   *   5. Return `average`.
   * Input:
   *   None.
   * Output:
   *   double – the arithmetic mean of `dailyPrice` values of all cars.
   *   Returns 0.0 when the store contains no cars.
   * Pre-condition:
   *   - `this.cars` is initialized.
   * Post-condition:
   *   - If `this.cars` is non‑empty, `output = ( Σ car.dailyPrice ) / N`, where N = number of cars.
   *   - If `this.cars` is empty, output = 0.0.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double determineAverageDailyPrice()
  {
    if (this.cars.isEmpty()) {
      return 0.0;
    }

    double sumPrice = 0.0;
    for (Car car : this.cars) {
      sumPrice += car.getDailyPrice();
    }

    return sumPrice / this.cars.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary:
   *   Produces a collection mapping each customer to the number of cars they have rented (including ongoing rentals).
   * Algorithm:
   *   1. Create an empty map `customerCountMap` keyed by `Customer` with Integer values.
   *   2. For each `rental` in `this.rentals`:
   *        a. Let `cust` = `rental.customer`.
   *        b. If `customerCountMap` already contains `cust`, increment its value by 1.
   *        c. Otherwise, insert `cust` with value 1.
   *   3. Convert `customerCountMap` into a List<EMap> where each `EMap` entry holds:
   *        - key: the `Customer` object,
   *        - value: the rental count (int).
   *   4. Return the list (empty if no rentals exist).
   * Input:
   *   None.
   * Output:
   *   List<EMap> – each element represents a pair (`Customer`, rentalCount). 
   *   The list may be empty.
   * Pre-condition:
   *   - `this.rentals` is initialized.
   * Post-condition:
   *   - For every customer `c` that appears in at least one rental, there is exactly one map entry with value equal to the number of rentals associated with `c`.
   *   - No entries exist for customers that have never rented a car.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Map<Customer, Integer>> countCarsRentedPerCustomer()
  {
    // 1. aggregate counts per customer
    Map<Customer, Integer> customerCountMap = new HashMap<>();

    for (Rental rental : this.rentals) {
      Customer cust = rental.getCustomer();
      if (cust != null) {
        Integer current = customerCountMap.get(cust);
        if (current == null) {
          customerCountMap.put(cust, 1);
        } else {
          customerCountMap.put(cust, current + 1);
        }
      }
    }

    // 2. transform each entry into a single‑entry map and add to result list
    BasicEList<Map<Customer, Integer>> result = new BasicEList<>();
    for (Map.Entry<Customer, Integer> entry : customerCountMap.entrySet()) {
      Map<Customer, Integer> singleEntryMap = new HashMap<>();
      singleEntryMap.put(entry.getKey(), entry.getValue());
      result.add(singleEntryMap);
    }

    return result;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  {
    switch (featureID)
    {
      case CarrentalPackage.STORE__CARS:
        return ((InternalEList<?>)getCars()).basicRemove(otherEnd, msgs);
      case CarrentalPackage.STORE__RENTALS:
        return ((InternalEList<?>)getRentals()).basicRemove(otherEnd, msgs);
      case CarrentalPackage.STORE__NOTICES:
        return ((InternalEList<?>)getNotices()).basicRemove(otherEnd, msgs);
    }
    return super.eInverseRemove(otherEnd, featureID, msgs);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  {
    switch (featureID)
    {
      case CarrentalPackage.STORE__CARS:
        return getCars();
      case CarrentalPackage.STORE__RENTALS:
        return getRentals();
      case CarrentalPackage.STORE__NOTICES:
        return getNotices();
    }
    return super.eGet(featureID, resolve, coreType);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  {
    switch (featureID)
    {
      case CarrentalPackage.STORE__CARS:
        getCars().clear();
        getCars().addAll((Collection<? extends Car>)newValue);
        return;
      case CarrentalPackage.STORE__RENTALS:
        getRentals().clear();
        getRentals().addAll((Collection<? extends Rental>)newValue);
        return;
      case CarrentalPackage.STORE__NOTICES:
        getNotices().clear();
        getNotices().addAll((Collection<? extends OverdueNotice>)newValue);
        return;
    }
    super.eSet(featureID, newValue);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public void eUnset(int featureID)
  {
    switch (featureID)
    {
      case CarrentalPackage.STORE__CARS:
        getCars().clear();
        return;
      case CarrentalPackage.STORE__RENTALS:
        getRentals().clear();
        return;
      case CarrentalPackage.STORE__NOTICES:
        getNotices().clear();
        return;
    }
    super.eUnset(featureID);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public boolean eIsSet(int featureID)
  {
    switch (featureID)
    {
      case CarrentalPackage.STORE__CARS:
        return cars != null && !cars.isEmpty();
      case CarrentalPackage.STORE__RENTALS:
        return rentals != null && !rentals.isEmpty();
      case CarrentalPackage.STORE__NOTICES:
        return notices != null && !notices.isEmpty();
    }
    return super.eIsSet(featureID);
  }

} // Store

      documentCounts.put(editor.getName(), editor.getDocuments().size());
    }
    return documentCounts;
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // FileSystem
124852 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../FileManager/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../FileManager/src-gen/edu/fs/
125113 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
125114 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
125114 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
125114 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
125116 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample2.mwe2 启动完成
正在拷贝 src-gen/edu/fs 到 mistral-small-3.2-24b-instruct/fs2...
拷贝完成！

======================================
正在启动 sample3.mwe2...
======================================
125700 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
125831 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project FileManager at 'file:/D:/EclipseWorkspace/FileManager/'
125835 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
125848 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@25c8c71e
125848 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
125850 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
125851 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
A file system contains information from multiple documents. The document can be added and removed from the file system, and all the documents can be listed. Each document uses an editor suitable for creation. A document contains the document's name, creation date, author information, and size. The user determines the assignment of the editor to the documents. Each editor has a name. The system has three editors that allow you to manage documents: Text Editor, Image Editor, and Video Editor.
Function requirement:
+ Calculate the total size of all documents in the file system. Output the sum of all document sizes. Return 0 if there is no document.

+ Compute the average size of all documents for each editor (Text Editor, Image Editor, and Video Editor) in the file system.Return 0 if there is no document.

+ Count the number of documents in the file system that were created after a specified date.

+ Count the number of documents for each editor (TextEditor, ImageEditor, VideoEditor) in the file system.

+ Retrieve the names of all authors whose documents are edited with a specified editor in the file system.
```

# Class Diagram
```plantuml
@startuml

title fs Model

class Document {
    author : String
    createDate : EDate
    name : String
    size : int
    editor : Editor
}
abstract class Editor {
    name : String
    documents : List<Document>
}
class FileSystem {
    documents : List<Document>
    editors : List<Editor>
    calculateTotalDocumentSize() : int
    countDocumentsAfterDate(date : EDate) : int
    countDocumentsPerEditorType() : EMap
    findAverageSizePerEditor() : EMap
    getAuthorsByEditor(editor : Editor) : List<String>
}
class ImageEditor {
}
class TextEditor {
}
class VideoEditor {
}

Document --> Editor : editor  'opposite: documents
Editor --> "*" Document : documents  'opposite: editor
FileSystem *-- "*" Document : documents
FileSystem *-- "*" Editor : editors
ImageEditor --|> Editor
TextEditor --|> Editor
VideoEditor --|> Editor
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

147011 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@1479ed5a (name: getAuthorsByEditor) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary: Retrieves the names of all authors whose documents are edited with a specified editor.
Algorithm:
  1. Initialize a list to store author names.
  2. For each document in the file system:
     a. If the document's editor matches the specified editor:
        i. Add the document's author to the list.
  3. Return the list.
Input: editor (Editor) - The editor to filter documents by. Must be a valid editor.
Output: List<String> - A list of author names whose documents are edited with the specified editor. Returns an empty list if no documents meet the criteria.
Pre-condition: The file system must be initialized, and the input editor must be valid.
Post-condition: The list of author names is returned., org.eclipse.emf.ecore.impl.EOperationImpl@2573b149 (name: findAverageSizePerEditor) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Computes the average size of all documents for each editor type in the file system.
Algorithm:
  1. Initialize a map to store editor types and their average document sizes.
  2. For each editor in the file system:
     a. Get the list of documents associated with the editor.
     b. If the list is not empty:
        i. Calculate the sum of the sizes of all documents in the list.
        ii. Divide the sum by the number of documents to get the average.
        iii. Store the average in the map with the editor's name as the key.
     c. If the list is empty, store 0 in the map.
  3. Return the map.
Input: None
Output: EMap - A map where keys are editor names and values are the average sizes of documents for each editor. Returns a map with 0 for all editors if there are no documents.
Pre-condition: The file system must be initialized.
Post-condition: The map of average document sizes per editor type is returned., org.eclipse.emf.ecore.impl.EOperationImpl@759f45f1 (name: countDocumentsPerEditorType) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Counts the number of documents for each editor type in the file system.
Algorithm:
  1. Initialize a map to store editor types and their document counts.
  2. For each editor in the file system:
     a. Get the editor's name.
     b. Count the number of documents associated with the editor.
     c. Store the count in the map with the editor's name as the key.
  3. Return the map.
Input: None
Output: EMap - A map where keys are editor names and values are the counts of documents for each editor. Returns an empty map if there are no documents.
Pre-condition: The file system must be initialized.
Post-condition: The map of document counts per editor type is returned., org.eclipse.emf.ecore.impl.EOperationImpl@3921135e (name: calculateTotalDocumentSize) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates the total size of all documents in the file system.
Algorithm:
  1. Initialize total size to 0.
  2. For each document in the file system:
     a. Add the document's size to the total.
  3. Return the total size.
Input: None
Output: int - The sum of all document sizes. Returns 0 if there are no documents.
Pre-condition: The file system must be initialized.
Post-condition: The total size of all documents is returned., org.eclipse.emf.ecore.impl.EOperationImpl@3a239dac (name: countDocumentsAfterDate) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Counts the number of documents created after a specified date.
Algorithm:
  1. Initialize count to 0.
  2. For each document in the file system:
     a. If the document's creation date is after the specified date:
        i. Increment the count.
  3. Return the count.
Input: date (EDate) - The date to compare against. Must be a valid date.
Output: int - The number of documents created after the specified date. Returns 0 if no documents meet the criteria.
Pre-condition: The file system must be initialized, and the input date must be valid.
Post-condition: The count of documents created after the specified date is returned.}
147014 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
147049 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../FileManager/src-gen/edu/fs
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.fs;

import java.util.Collection;
import java.util.Date;
import java.util.Map;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>File System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.fs.FileSystem#getDocuments <em>Documents</em>}</li>
 *   <li>{@link edu.fs.FileSystem#getEditors <em>Editors</em>}</li>
 * </ul>
 *
 * @see edu.fs.FsPackage#getFileSystem()
 * @model kind="class"
 * @generated
 */
public class FileSystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Document> documents;

  protected EList<Editor> editors;

  protected FileSystem()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Document> getDocuments()
  { ... /* omitted */ }

  public EList<Editor> getEditors()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total size of all documents in the file system.
   * Algorithm:
   *   1. Initialize total size to 0.
   *   2. For each document in the file system:
   *      a. Add the document's size to the total.
   *   3. Return the total size.
   * Input: None
   * Output: int - The sum of all document sizes. Returns 0 if there are no documents.
   * Pre-condition: The file system must be initialized.
   * Post-condition: The total size of all documents is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int calculateTotalDocumentSize()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Computes the average size of all documents for each editor type in the file system.
   * Algorithm:
   *   1. Initialize a map to store editor types and their average document sizes.
   *   2. For each editor in the file system:
   *      a. Get the list of documents associated with the editor.
   *      b. If the list is not empty:
   *         i. Calculate the sum of the sizes of all documents in the list.
   *         ii. Divide the sum by the number of documents to get the average.
   *         iii. Store the average in the map with the editor's name as the key.
   *      c. If the list is empty, store 0 in the map.
   *   3. Return the map.
   * Input: None
   * Output: EMap - A map where keys are editor names and values are the average sizes of documents for each editor. Returns a map with 0 for all editors if there are no documents.
   * Pre-condition: The file system must be initialized.
   * Post-condition: The map of average document sizes per editor type is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public Map<String, Float> findAverageSizePerEditor()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the number of documents created after a specified date.
   * Algorithm:
   *   1. Initialize count to 0.
   *   2. For each document in the file system:
   *      a. If the document's creation date is after the specified date:
   *         i. Increment the count.
   *   3. Return the count.
   * Input: date (EDate) - The date to compare against. Must be a valid date.
   * Output: int - The number of documents created after the specified date. Returns 0 if no documents meet the criteria.
   * Pre-condition: The file system must be initialized, and the input date must be valid.
   * Post-condition: The count of documents created after the specified date is returned.
   * <!-- end-model-doc -->
   * @model dateRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int countDocumentsAfterDate(final Date date)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves the names of all authors whose documents are edited with a specified editor.
   * Algorithm:
   *   1. Initialize a list to store author names.
   *   2. For each document in the file system:
   *      a. If the document's editor matches the specified editor:
   *         i. Add the document's author to the list.
   *   3. Return the list.
   * Input: editor (Editor) - The editor to filter documents by. Must be a valid editor.
   * Output: List<String> - A list of author names whose documents are edited with the specified editor. Returns an empty list if no documents meet the criteria.
   * Pre-condition: The file system must be initialized, and the input editor must be valid.
   * Post-condition: The list of author names is returned.
   * <!-- end-model-doc -->
   * @model editorRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<String> getAuthorsByEditor(final Editor editor)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the number of documents for each editor type in the file system.
   * Algorithm:
   *   1. Initialize a map to store editor types and their document counts.
   *   2. For each editor in the file system:
   *      a. Get the editor's name.
   *      b. Count the number of documents associated with the editor.
   *      c. Store the count in the map with the editor's name as the key.
   *   3. Return the map.
   * Input: None
   * Output: EMap - A map where keys are editor names and values are the counts of documents for each editor. Returns an empty map if there are no documents.
   * Pre-condition: The file system must be initialized.
   * Post-condition: The map of document counts per editor type is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public Map<String, Integer> countDocumentsPerEditorType()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // FileSystem
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Document` contains the following methods.
  + Instance creation: Use `FsFactory.eINSTANCE.createDocument()`
  + Getter methods: public String getName(), public Date getCreateDate(), public String getAuthor(), public int getSize(), public Editor getEditor()
  + Setter methods: public void setName(String newName), public void setCreateDate(Date newCreateDate), public void setAuthor(String newAuthor), public void setSize(int newSize), public void setEditor(Editor newEditor)
- Class `Editor` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: public String getName(), public EList<Document> getDocuments()
  + Setter methods: public void setName(String newName)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/** generated by Enhanced EcoreGen */
package edu.fs;

import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;

/** A representation of the model object '<em><b>File System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.fs.FileSystem#getDocuments <em>Documents</em>}</li>
 *   <li>{@link edu.fs.FileSystem#getEditors <em>Editors</em>}</li>
 * </ul>
 *
 * @see edu.fs.FsPackage#getFileSystem()
 * @model kind="class"
 * @generated
 */
public class FileSystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Document> documents;

  protected EList<Editor> editors;

  protected FileSystem()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Document> getDocuments()
  { ... /* omitted */ }

  public EList<Editor> getEditors()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total size of all documents in the file system.
   * Algorithm:
   *   1. Initialize total size to 0.
   *   2. For each document in the file system:
   *      a. Add the document's size to the total.
   *   3. Return the total size.
   * Input: None
   * Output: int - The sum of all document sizes. Returns 0 if there are no documents.
   * Pre-condition: The file system must be initialized.
   * Post-condition: The total size of all documents is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateTotalDocumentSize()
  {
    int totalSize = 0;
    for (Document document : getDocuments()) {
      totalSize += document.getSize();
    }
    return totalSize;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Computes the average size of all documents for each editor type in the file system.
   * Algorithm:
   *   1. Initialize a map to store editor types and their average document sizes.
   *   2. For each editor in the file system:
   *      a. Get the list of documents associated with the editor.
   *      b. If the list is not empty:
   *         i. Calculate the sum of the sizes of all documents in the list.
   *         ii. Divide the sum by the number of documents to get the average.
   *         iii. Store the average in the map with the editor's name as the key.
   *      c. If the list is empty, store 0 in the map.
   *   3. Return the map.
   * Input: None
   * Output: EMap - A map where keys are editor names and values are the average sizes of documents for each editor. Returns a map with 0 for all editors if there are no documents.
   * Pre-condition: The file system must be initialized.
   * Post-condition: The map of average document sizes per editor type is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Map<String, Float> findAverageSizePerEditor()
  {
    Map<String, Float> averageSizes = new HashMap<>();
    for (Editor editor : getEditors()) {
      EList<Document> documents = editor.getDocuments();
      if (documents.isEmpty()) {
        averageSizes.put(editor.getName(), 0.0f);
      } else {
        int totalSize = 0;
        for (Document document : documents) {
          totalSize += document.getSize();
        }
        float average = (float) totalSize / documents.size();
        averageSizes.put(editor.getName(), average);
      }
    }
    return averageSizes;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the number of documents created after a specified date.
   * Algorithm:
   *   1. Initialize count to 0.
   *   2. For each document in the file system:
   *      a. If the document's creation date is after the specified date:
   *         i. Increment the count.
   *   3. Return the count.
   * Input: date (EDate) - The date to compare against. Must be a valid date.
   * Output: int - The number of documents created after the specified date. Returns 0 if no documents meet the criteria.
   * Pre-condition: The file system must be initialized, and the input date must be valid.
   * Post-condition: The count of documents created after the specified date is returned.
   * <!-- end-model-doc -->
   * @model dateRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int countDocumentsAfterDate(final Date date)
  {
    int count = 0;
    for (Document document : getDocuments()) {
      if (document.getCreateDate().after(date)) {
        count++;
      }
    }
    return count;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves the names of all authors whose documents are edited with a specified editor.
   * Algorithm:
   *   1. Initialize a list to store author names.
   *   2. For each document in the file system:
   *      a. If the document's editor matches the specified editor:
   *         i. Add the document's author to the list.
   *   3. Return the list.
   * Input: editor (Editor) - The editor to filter documents by. Must be a valid editor.
   * Output: List<String> - A list of author names whose documents are edited with the specified editor. Returns an empty list if no documents meet the criteria.
   * Pre-condition: The file system must be initialized, and the input editor must be valid.
   * Post-condition: The list of author names is returned.
   * <!-- end-model-doc -->
   * @model editorRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> getAuthorsByEditor(final Editor editor)
  {
    BasicEList<String> authors = new BasicEList<>();
    for (Document document : getDocuments()) {
      if (document.getEditor() == editor) {
        authors.add(document.getAuthor());
      }
    }
    return authors;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the number of documents for each editor type in the file system.
   * Algorithm:
   *   1. Initialize a map to store editor types and their document counts.
   *   2. For each editor in the file system:
   *      a. Get the editor's name.
   *      b. Count the number of documents associated with the editor.
   *      c. Store the count in the map with the editor's name as the key.
   *   3. Return the map.
   * Input: None
   * Output: EMap - A map where keys are editor names and values are the counts of documents for each editor. Returns an empty map if there are no documents.
   * Pre-condition: The file system must be initialized.
   * Post-condition: The map of document counts per editor type is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Map<String, Integer> countDocumentsPerEditorType()
  {
    Map<String, Integer> documentCounts = new HashMap<>();
    for (Editor editor : getEditors()) {
      EList<Document> documents = editor.getDocuments();
      documentCounts.put(editor.getName(), documents.size());
    }
    return documentCounts;
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // FileSystem
206877 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../FileManager/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../FileManager/src-gen/edu/fs/
207047 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
207047 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
207047 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
207047 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
207050 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample3.mwe2 启动完成
正在拷贝 src-gen/edu/fs 到 mistral-small-3.2-24b-instruct/fs3...
拷贝完成！

======================================
正在启动 sample4.mwe2...
======================================
207333 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
207418 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project FileManager at 'file:/D:/EclipseWorkspace/FileManager/'
207420 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
207425 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@3321fb65
207425 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
207427 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
207428 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
A file system contains information from multiple documents. The document can be added and removed from the file system, and all the documents can be listed. Each document uses an editor suitable for creation. A document contains the document's name, creation date, author information, and size. The user determines the assignment of the editor to the documents. Each editor has a name. The system has three editors that allow you to manage documents: Text Editor, Image Editor, and Video Editor.
Function requirement:
+ Calculate the total size of all documents in the file system. Output the sum of all document sizes. Return 0 if there is no document.

+ Compute the average size of all documents for each editor (Text Editor, Image Editor, and Video Editor) in the file system.Return 0 if there is no document.

+ Count the number of documents in the file system that were created after a specified date.

+ Count the number of documents for each editor (TextEditor, ImageEditor, VideoEditor) in the file system.

+ Retrieve the names of all authors whose documents are edited with a specified editor in the file system.
```

# Class Diagram
```plantuml
@startuml

title fs Model

class Document {
    author : String
    createDate : EDate
    name : String
    size : int
    editor : Editor
}
abstract class Editor {
    name : String
    documents : List<Document>
}
class FileSystem {
    documents : List<Document>
    editors : List<Editor>
    calculateTotalDocumentSize() : int
    countDocumentsAfterDate(date : EDate) : int
    countDocumentsPerEditorType() : EMap
    findAverageSizePerEditor() : EMap
    getAuthorsByEditor(editor : Editor) : List<String>
}
class ImageEditor {
}
class TextEditor {
}
class VideoEditor {
}

Document --> Editor : editor  'opposite: documents
Editor --> "*" Document : documents  'opposite: editor
FileSystem *-- "*" Document : documents
FileSystem *-- "*" Editor : editors
ImageEditor --|> Editor
TextEditor --|> Editor
VideoEditor --|> Editor
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

222775 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@7a14ab66 (name: countDocumentsAfterDate) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Counts the number of documents created after a specified date.
Algorithm:
  1. Initialize count to 0.
  2. For each document in the documents list:
     a. If the document's creation date is after the specified date:
        i. Increment count by 1.
  3. Return count.
Input: date (EDate) - The date to compare against. Must be a valid date.
Output: int - The number of documents created after the specified date. Returns 0 if no documents are found.
Pre-condition: The documents list must be initialized.
Post-condition: The count of documents created after the specified date is returned., org.eclipse.emf.ecore.impl.EOperationImpl@54780c40 (name: countDocumentsPerEditorType) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Counts the number of documents for each editor type in the file system.
Algorithm:
  1. Initialize an empty map to store editor types and their document counts.
  2. For each editor in the editors list:
     a. For each document in the editor's documents list:
        i. Increment the count for the editor's type in the map.
  3. Return the map.
Input: None.
Output: EMap - A map where keys are editor types (TextEditor, ImageEditor, VideoEditor) and values are the counts of documents for each type.
Pre-condition: The editors list must be initialized.
Post-condition: The map of document counts per editor type is returned., org.eclipse.emf.ecore.impl.EOperationImpl@4d91d2da (name: getAuthorsByEditor) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary: Retrieves the names of all authors whose documents are edited with a specified editor.
Algorithm:
  1. Initialize an empty list to store author names.
  2. For each document in the editor's documents list:
     a. Add the document's author to the list if not already present.
  3. Return the list.
Input: editor (Editor) - The editor to filter documents by. Must be a valid editor instance.
Output: List<String> - A list of unique author names whose documents are edited with the specified editor. Returns an empty list if no documents are found.
Pre-condition: The editor's documents list must be initialized.
Post-condition: The list of unique author names is returned., org.eclipse.emf.ecore.impl.EOperationImpl@9c5d76b (name: calculateTotalDocumentSize) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates the total size of all documents in the file system.
Algorithm:
  1. Initialize total size to 0.
  2. For each document in the documents list:
     a. Add the document's size to the total size.
  3. Return the total size.
Input: None.
Output: int - The sum of all document sizes. Returns 0 if there are no documents.
Pre-condition: The documents list must be initialized.
Post-condition: The total size of all documents is returned., org.eclipse.emf.ecore.impl.EOperationImpl@6ac83e67 (name: findAverageSizePerEditor) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Computes the average size of all documents for each editor type in the file system.
Algorithm:
  1. Initialize an empty map to store editor types and their average document sizes.
  2. For each editor in the editors list:
     a. Initialize sum and count to 0.
     b. For each document in the editor's documents list:
        i. Add the document's size to sum.
        ii. Increment count by 1.
     c. If count > 0:
        i. Calculate average size as sum / count.
        ii. Add the average size to the map for the editor's type.
     d. Else:
        i. Add 0 to the map for the editor's type.
  3. Return the map.
Input: None.
Output: EMap - A map where keys are editor types (TextEditor, ImageEditor, VideoEditor) and values are the average document sizes for each type. Returns 0 for editors with no documents.
Pre-condition: The editors list must be initialized.
Post-condition: The map of average document sizes per editor type is returned.}
222778 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
222797 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../FileManager/src-gen/edu/fs
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.fs;

import java.util.Collection;
import java.util.Date;
import java.util.Map;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>File System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.fs.FileSystem#getDocuments <em>Documents</em>}</li>
 *   <li>{@link edu.fs.FileSystem#getEditors <em>Editors</em>}</li>
 * </ul>
 *
 * @see edu.fs.FsPackage#getFileSystem()
 * @model kind="class"
 * @generated
 */
public class FileSystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Document> documents;

  protected EList<Editor> editors;

  protected FileSystem()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Document> getDocuments()
  { ... /* omitted */ }

  public EList<Editor> getEditors()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total size of all documents in the file system.
   * Algorithm:
   *   1. Initialize total size to 0.
   *   2. For each document in the documents list:
   *      a. Add the document's size to the total size.
   *   3. Return the total size.
   * Input: None.
   * Output: int - The sum of all document sizes. Returns 0 if there are no documents.
   * Pre-condition: The documents list must be initialized.
   * Post-condition: The total size of all documents is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int calculateTotalDocumentSize()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Computes the average size of all documents for each editor type in the file system.
   * Algorithm:
   *   1. Initialize an empty map to store editor types and their average document sizes.
   *   2. For each editor in the editors list:
   *      a. Initialize sum and count to 0.
   *      b. For each document in the editor's documents list:
   *         i. Add the document's size to sum.
   *         ii. Increment count by 1.
   *      c. If count > 0:
   *         i. Calculate average size as sum / count.
   *         ii. Add the average size to the map for the editor's type.
   *      d. Else:
   *         i. Add 0 to the map for the editor's type.
   *   3. Return the map.
   * Input: None.
   * Output: EMap - A map where keys are editor types (TextEditor, ImageEditor, VideoEditor) and values are the average document sizes for each type. Returns 0 for editors with no documents.
   * Pre-condition: The editors list must be initialized.
   * Post-condition: The map of average document sizes per editor type is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public Map<String, Float> findAverageSizePerEditor()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the number of documents created after a specified date.
   * Algorithm:
   *   1. Initialize count to 0.
   *   2. For each document in the documents list:
   *      a. If the document's creation date is after the specified date:
   *         i. Increment count by 1.
   *   3. Return count.
   * Input: date (EDate) - The date to compare against. Must be a valid date.
   * Output: int - The number of documents created after the specified date. Returns 0 if no documents are found.
   * Pre-condition: The documents list must be initialized.
   * Post-condition: The count of documents created after the specified date is returned.
   * <!-- end-model-doc -->
   * @model dateRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int countDocumentsAfterDate(final Date date)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves the names of all authors whose documents are edited with a specified editor.
   * Algorithm:
   *   1. Initialize an empty list to store author names.
   *   2. For each document in the editor's documents list:
   *      a. Add the document's author to the list if not already present.
   *   3. Return the list.
   * Input: editor (Editor) - The editor to filter documents by. Must be a valid editor instance.
   * Output: List<String> - A list of unique author names whose documents are edited with the specified editor. Returns an empty list if no documents are found.
   * Pre-condition: The editor's documents list must be initialized.
   * Post-condition: The list of unique author names is returned.
   * <!-- end-model-doc -->
   * @model editorRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<String> getAuthorsByEditor(final Editor editor)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the number of documents for each editor type in the file system.
   * Algorithm:
   *   1. Initialize an empty map to store editor types and their document counts.
   *   2. For each editor in the editors list:
   *      a. For each document in the editor's documents list:
   *         i. Increment the count for the editor's type in the map.
   *   3. Return the map.
   * Input: None.
   * Output: EMap - A map where keys are editor types (TextEditor, ImageEditor, VideoEditor) and values are the counts of documents for each type.
   * Pre-condition: The editors list must be initialized.
   * Post-condition: The map of document counts per editor type is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public Map<String, Integer> countDocumentsPerEditorType()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // FileSystem
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Document` contains the following methods.
  + Instance creation: Use `FsFactory.eINSTANCE.createDocument()`
  + Getter methods: public String getName(), public Date getCreateDate(), public String getAuthor(), public int getSize(), public Editor getEditor()
  + Setter methods: public void setName(String newName), public void setCreateDate(Date newCreateDate), public void setAuthor(String newAuthor), public void setSize(int newSize), public void setEditor(Editor newEditor)
- Class `Editor` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: public String getName(), public EList<Document> getDocuments()
  + Setter methods: public void setName(String newName)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/***
 * generated by Enhanced EcoreGen
 */
package edu.fs;

import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import org.eclipse.emf.common.notify.NotificationChain;
import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;
import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;

/***
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>File System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.fs.FileSystem#getDocuments <em>Documents</em>}</li>
 *   <li>{@link edu.fs.FileSystem#getEditors <em>Editors</em>}</li>
 * </ul>
 *
 * @see edu.fs.FsPackage#getFileSystem()
 * @model kind="class"
 * @generated
 */
public class FileSystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Document> documents;

  protected EList<Editor> editors;

  protected FileSystem()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Document> getDocuments()
  { ... /* omitted */ }

  public EList<Editor> getEditors()
  { ... /* omitted */ }

  /***
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total size of all documents in the file system.
   * Algorithm:
   *   1. Initialize total size to 0.
   *   2. For each document in the documents list:
   *      a. Add the document's size to the total size.
   *   3. Return the total size.
   * Input: None.
   * Output: int - The sum of all document sizes. Returns 0 if there are no documents.
   * Pre-condition: The documents list must be initialized.
   * Post-condition: The total size of all documents is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateTotalDocumentSize()
  {
    int totalSize = 0;
    for (Document document : getDocuments()) {
      totalSize += document.getSize();
    }
    return totalSize;
  }

  /***
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Computes the average size of all documents for each editor type in the file system.
   * Algorithm:
   *   1. Initialize an empty map to store editor types and their average document sizes.
   *   2. For each editor in the editors list:
   *      a. Initialize sum and count to 0.
   *      b. For each document in the editor's documents list:
   *         i. Add the document's size to sum.
   *         ii. Increment count by 1.
   *      c. If count > 0:
   *         i. Calculate average size as sum / count.
   *         ii. Add the average size to the map for the editor's type.
   *      d. Else:
   *         i. Add 0 to the map for the editor's type.
   *   3. Return the map.
   * Input: None.
   * Output: EMap - A map where keys are editor types (TextEditor, ImageEditor, VideoEditor) and values are the average document sizes for each type. Returns 0 for editors with no documents.
   * Pre-condition: The editors list must be initialized.
   * Post-condition: The map of average document sizes per editor type is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Map<String, Float> findAverageSizePerEditor()
  {
    Map<String, Float> averageSizes = new HashMap<>();
    for (Editor editor : getEditors()) {
      int sum = 0;
      int count = 0;
      for (Document document : editor.getDocuments()) {
        sum += document.getSize();
        count++;
      }
      if (count > 0) {
        averageSizes.put(editor.getClass().getSimpleName(), (float) sum / count);
      } else {
        averageSizes.put(editor.getClass().getSimpleName(), 0.0f);
      }
    }
    return averageSizes;
  }

  /***
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the number of documents created after a specified date.
   * Algorithm:
   *   1. Initialize count to 0.
   *   2. For each document in the documents list:
   *      a. If the document's creation date is after the specified date:
   *         i. Increment count by 1.
   *   3. Return count.
   * Input: date (EDate) - The date to compare against. Must be a valid date.
   * Output: int - The number of documents created after the specified date. Returns 0 if no documents are found.
   * Pre-condition: The documents list must be initialized.
   * Post-condition: The count of documents created after the specified date is returned.
   * <!-- end-model-doc -->
   * @model dateRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int countDocumentsAfterDate(final Date date)
  {
    int count = 0;
    for (Document document : getDocuments()) {
      if (document.getCreateDate().after(date)) {
        count++;
      }
    }
    return count;
  }

  /***
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves the names of all authors whose documents are edited with a specified editor.
   * Algorithm:
   *   1. Initialize an empty list to store author names.
   *   2. For each document in the editor's documents list:
   *      a. Add the document's author to the list if not already present.
   *   3. Return the list.
   * Input: editor (Editor) - The editor to filter documents by. Must be a valid editor instance.
   * Output: List<String> - A list of unique author names whose documents are edited with the specified editor. Returns an empty list if no documents are found.
   * Pre-condition: The editor's documents list must be initialized.
   * Post-condition: The list of unique author names is returned.
   * <!-- end-model-doc -->
   * @model editorRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> getAuthorsByEditor(final Editor editor)
  {
    BasicEList<String> authors = new BasicEList<>();
    for (Document document : editor.getDocuments()) {
      String author = document.getAuthor();
      if (!authors.contains(author)) {
        authors.add(author);
      }
    }
    return authors;
  }

  /***
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the number of documents for each editor type in the file system.
   * Algorithm:
   *   1. Initialize an empty map to store editor types and their document counts.
   *   2. For each editor in the editors list:
   *      a. For each document in the editor's documents list:
   *         i. Increment the count for the editor's type in the map.
   *   3. Return the map.
   * Input: None.
   * Output: EMap - A map where keys are editor types (TextEditor, ImageEditor, VideoEditor) and values are the counts of documents for each type.
   * Pre-condition: The editors list must be initialized.
   * Post-condition: The map of document counts per editor type is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Map<String, Integer> countDocumentsPerEditorType()
  {
    Map<String, Integer> documentCounts = new HashMap<>();
    for (Editor editor : getEditors()) {
      String editorType = editor.getClass().getSimpleName();
      for (Document document : editor.getDocuments()) {
        documentCounts.put(editorType, documentCounts.getOrDefault(editorType, 0) + 1);
      }
    }
    return documentCounts;
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // FileSystem
270851 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../FileManager/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../FileManager/src-gen/edu/fs/
270983 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
270983 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - ----------
1. WARNING in D:\EclipseWorkspace\FileManager\src-gen\edu\fs\FileSystem.java (at line 281)
	for (Document document : editor.getDocuments()) {
	              ^^^^^^^^
The value of the local variable document is not used
----------
1 problem (1 warning)

270983 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
270983 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
270984 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample4.mwe2 启动完成
正在拷贝 src-gen/edu/fs 到 mistral-small-3.2-24b-instruct/fs4...
拷贝完成！

======================================
正在启动 sample5.mwe2...
======================================
271420 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
271516 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project FileManager at 'file:/D:/EclipseWorkspace/FileManager/'
271520 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
271530 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@63541cd4
271530 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
271532 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
271532 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
A file system contains information from multiple documents. The document can be added and removed from the file system, and all the documents can be listed. Each document uses an editor suitable for creation. A document contains the document's name, creation date, author information, and size. The user determines the assignment of the editor to the documents. Each editor has a name. The system has three editors that allow you to manage documents: Text Editor, Image Editor, and Video Editor.
Function requirement:
+ Calculate the total size of all documents in the file system. Output the sum of all document sizes. Return 0 if there is no document.

+ Compute the average size of all documents for each editor (Text Editor, Image Editor, and Video Editor) in the file system.Return 0 if there is no document.

+ Count the number of documents in the file system that were created after a specified date.

+ Count the number of documents for each editor (TextEditor, ImageEditor, VideoEditor) in the file system.

+ Retrieve the names of all authors whose documents are edited with a specified editor in the file system.
```

# Class Diagram
```plantuml
@startuml

title fs Model

class Document {
    author : String
    createDate : EDate
    name : String
    size : int
    editor : Editor
}
abstract class Editor {
    name : String
    documents : List<Document>
}
class FileSystem {
    documents : List<Document>
    editors : List<Editor>
    calculateTotalDocumentSize() : int
    countDocumentsAfterDate(date : EDate) : int
    countDocumentsPerEditorType() : EMap
    findAverageSizePerEditor() : EMap
    getAuthorsByEditor(editor : Editor) : List<String>
}
class ImageEditor {
}
class TextEditor {
}
class VideoEditor {
}

Document --> Editor : editor  'opposite: documents
Editor --> "*" Document : documents  'opposite: editor
FileSystem *-- "*" Document : documents
FileSystem *-- "*" Editor : editors
ImageEditor --|> Editor
TextEditor --|> Editor
VideoEditor --|> Editor
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

296670 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@6bd8c398 (name: countDocumentsPerEditorType) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Counts the number of documents for each editor type in the file system.
Algorithm:
  1. Initialize a map to store editor types and their document counts.
  2. For each editor in the editors list:
     a. Initialize the count for the editor type to 0.
  3. For each document in the documents list:
     a. Get the editor type of the document.
     b. Increment the count for the corresponding editor type.
  4. Return the map with editor types and their document counts.
Input: None
Output: EMap - A map where keys are editor types (TextEditor, ImageEditor, VideoEditor) and values are the counts of documents for each type. Returns an empty map if there are no documents.
Pre-condition: The editors and documents lists must be initialized.
Post-condition: The map of document counts per editor type is returned., org.eclipse.emf.ecore.impl.EOperationImpl@1f7949dc (name: countDocumentsAfterDate) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Counts the number of documents created after a specified date.
Algorithm:
  1. Initialize count to 0.
  2. For each document in the documents list:
     a. If the document's creation date is after the specified date:
        i. Increment the count.
  3. Return the count.
Input: date (EDate) - The date to compare against. Must be a valid date.
Output: int - The number of documents created after the specified date. Returns 0 if no documents meet the criteria.
Pre-condition: The documents list must be initialized, and the input date must be valid.
Post-condition: The count of documents created after the specified date is returned., org.eclipse.emf.ecore.impl.EOperationImpl@16279a5d (name: calculateTotalDocumentSize) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Calculates the total size of all documents in the file system.
Algorithm:
  1. Initialize total size to 0.
  2. For each document in the documents list:
     a. Add the document's size to the total size.
  3. Return the total size.
Input: None
Output: int - The sum of all document sizes. Returns 0 if there are no documents.
Pre-condition: The documents list must be initialized.
Post-condition: The total size of all documents is returned., org.eclipse.emf.ecore.impl.EOperationImpl@3497ecea (name: findAverageSizePerEditor) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Computes the average size of all documents for each editor type in the file system.
Algorithm:
  1. Initialize a map to store editor types and their average sizes.
  2. For each editor in the editors list:
     a. Initialize the sum of sizes and count to 0 for the editor type.
  3. For each document in the documents list:
     a. Get the editor type of the document.
     b. Add the document's size to the sum for the corresponding editor type.
     c. Increment the count for the corresponding editor type.
  4. For each editor type in the map:
     a. If the count is greater than 0:
        i. Calculate the average size as sum / count.
     b. Else:
        i. Set the average size to 0.
  5. Return the map with editor types and their average sizes.
Input: None
Output: EMap - A map where keys are editor types (TextEditor, ImageEditor, VideoEditor) and values are the average sizes of documents for each type. Returns 0 for editor types with no documents.
Pre-condition: The editors and documents lists must be initialized.
Post-condition: The map of average sizes per editor type is returned., org.eclipse.emf.ecore.impl.EOperationImpl@1e487d57 (name: getAuthorsByEditor) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary: Retrieves the names of all authors whose documents are edited with a specified editor.
Algorithm:
  1. Initialize a list to store author names.
  2. For each document in the documents list:
     a. If the document's editor matches the specified editor:
        i. Add the document's author to the list.
  3. Return the list of author names.
Input: editor (Editor) - The editor to filter documents by. Must be a valid editor.
Output: List<String> - A list of author names whose documents are edited with the specified editor. Returns an empty list if no documents meet the criteria.
Pre-condition: The documents list must be initialized, and the input editor must be valid.
Post-condition: The list of author names is returned.}
296672 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
296695 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../FileManager/src-gen/edu/fs
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.fs;

import java.util.Collection;
import java.util.Date;
import java.util.Map;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>File System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.fs.FileSystem#getDocuments <em>Documents</em>}</li>
 *   <li>{@link edu.fs.FileSystem#getEditors <em>Editors</em>}</li>
 * </ul>
 *
 * @see edu.fs.FsPackage#getFileSystem()
 * @model kind="class"
 * @generated
 */
public class FileSystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Document> documents;

  protected EList<Editor> editors;

  protected FileSystem()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Document> getDocuments()
  { ... /* omitted */ }

  public EList<Editor> getEditors()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total size of all documents in the file system.
   * Algorithm:
   *   1. Initialize total size to 0.
   *   2. For each document in the documents list:
   *      a. Add the document's size to the total size.
   *   3. Return the total size.
   * Input: None
   * Output: int - The sum of all document sizes. Returns 0 if there are no documents.
   * Pre-condition: The documents list must be initialized.
   * Post-condition: The total size of all documents is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int calculateTotalDocumentSize()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Computes the average size of all documents for each editor type in the file system.
   * Algorithm:
   *   1. Initialize a map to store editor types and their average sizes.
   *   2. For each editor in the editors list:
   *      a. Initialize the sum of sizes and count to 0 for the editor type.
   *   3. For each document in the documents list:
   *      a. Get the editor type of the document.
   *      b. Add the document's size to the sum for the corresponding editor type.
   *      c. Increment the count for the corresponding editor type.
   *   4. For each editor type in the map:
   *      a. If the count is greater than 0:
   *         i. Calculate the average size as sum / count.
   *      b. Else:
   *         i. Set the average size to 0.
   *   5. Return the map with editor types and their average sizes.
   * Input: None
   * Output: EMap - A map where keys are editor types (TextEditor, ImageEditor, VideoEditor) and values are the average sizes of documents for each type. Returns 0 for editor types with no documents.
   * Pre-condition: The editors and documents lists must be initialized.
   * Post-condition: The map of average sizes per editor type is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public Map<String, Float> findAverageSizePerEditor()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the number of documents created after a specified date.
   * Algorithm:
   *   1. Initialize count to 0.
   *   2. For each document in the documents list:
   *      a. If the document's creation date is after the specified date:
   *         i. Increment the count.
   *   3. Return the count.
   * Input: date (EDate) - The date to compare against. Must be a valid date.
   * Output: int - The number of documents created after the specified date. Returns 0 if no documents meet the criteria.
   * Pre-condition: The documents list must be initialized, and the input date must be valid.
   * Post-condition: The count of documents created after the specified date is returned.
   * <!-- end-model-doc -->
   * @model dateRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int countDocumentsAfterDate(final Date date)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves the names of all authors whose documents are edited with a specified editor.
   * Algorithm:
   *   1. Initialize a list to store author names.
   *   2. For each document in the documents list:
   *      a. If the document's editor matches the specified editor:
   *         i. Add the document's author to the list.
   *   3. Return the list of author names.
   * Input: editor (Editor) - The editor to filter documents by. Must be a valid editor.
   * Output: List<String> - A list of author names whose documents are edited with the specified editor. Returns an empty list if no documents meet the criteria.
   * Pre-condition: The documents list must be initialized, and the input editor must be valid.
   * Post-condition: The list of author names is returned.
   * <!-- end-model-doc -->
   * @model editorRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<String> getAuthorsByEditor(final Editor editor)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the number of documents for each editor type in the file system.
   * Algorithm:
   *   1. Initialize a map to store editor types and their document counts.
   *   2. For each editor in the editors list:
   *      a. Initialize the count for the editor type to 0.
   *   3. For each document in the documents list:
   *      a. Get the editor type of the document.
   *      b. Increment the count for the corresponding editor type.
   *   4. Return the map with editor types and their document counts.
   * Input: None
   * Output: EMap - A map where keys are editor types (TextEditor, ImageEditor, VideoEditor) and values are the counts of documents for each type. Returns an empty map if there are no documents.
   * Pre-condition: The editors and documents lists must be initialized.
   * Post-condition: The map of document counts per editor type is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public Map<String, Integer> countDocumentsPerEditorType()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // FileSystem
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Document` contains the following methods.
  + Instance creation: Use `FsFactory.eINSTANCE.createDocument()`
  + Getter methods: public String getName(), public Date getCreateDate(), public String getAuthor(), public int getSize(), public Editor getEditor()
  + Setter methods: public void setName(String newName), public void setCreateDate(Date newCreateDate), public void setAuthor(String newAuthor), public void setSize(int newSize), public void setEditor(Editor newEditor)
- Class `Editor` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Getter methods: public String getName(), public EList<Document> getDocuments()
  + Setter methods: public void setName(String newName)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/** generated by Enhanced EcoreGen */
package edu.fs;

import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>File System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.fs.FileSystem#getDocuments <em>Documents</em>}</li>
 *   <li>{@link edu.fs.FileSystem#getEditors <em>Editors</em>}</li>
 * </ul>
 *
 * @see edu.fs.FsPackage#getFileSystem()
 * @model kind="class"
 * @generated
 */
public class FileSystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Document> documents;

  protected EList<Editor> editors;

  protected FileSystem()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Document> getDocuments()
  { ... /* omitted */ }

  public EList<Editor> getEditors()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total size of all documents in the file system.
   * Algorithm:
   *   1. Initialize total size to 0.
   *   2. For each document in the documents list:
   *      a. Add the document's size to the total size.
   *   3. Return the total size.
   * Input: None
   * Output: int - The sum of all document sizes. Returns 0 if there are no documents.
   * Pre-condition: The documents list must be initialized.
   * Post-condition: The total size of all documents is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int calculateTotalDocumentSize()
  {
    int totalSize = 0;
    for (Document document : getDocuments()) {
      totalSize += document.getSize();
    }
    return totalSize;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Computes the average size of all documents for each editor type in the file system.
   * Algorithm:
   *   1. Initialize a map to store editor types and their average sizes.
   *   2. For each editor in the editors list:
   *      a. Initialize the sum of sizes and count to 0 for the editor type.
   *   3. For each document in the documents list:
   *      a. Get the editor type of the document.
   *      b. Add the document's size to the sum for the corresponding editor type.
   *      c. Increment the count for the corresponding editor type.
   *   4. For each editor type in the map:
   *      a. If the count is greater than 0:
   *         i. Calculate the average size as sum / count.
   *      b. Else:
   *         i. Set the average size to 0.
   *   5. Return the map with editor types and their average sizes.
   * Input: None
   * Output: EMap - A map where keys are editor types (TextEditor, ImageEditor, VideoEditor) and values are the average sizes of documents for each type. Returns 0 for editor types with no documents.
   * Pre-condition: The editors and documents lists must be initialized.
   * Post-condition: The map of average sizes per editor type is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Map<String, Float> findAverageSizePerEditor()
  {
    Map<String, Float> averageSizes = new HashMap<>();
    Map<String, Integer> sumSizes = new HashMap<>();
    Map<String, Integer> counts = new HashMap<>();

    // Initialize sums and counts for each editor type
    for (Editor editor : getEditors()) {
      String editorType = editor.getName();
      sumSizes.put(editorType, 0);
      counts.put(editorType, 0);
    }

    // Calculate sums and counts
    for (Document document : getDocuments()) {
      String editorType = document.getEditor().getName();
      sumSizes.put(editorType, sumSizes.get(editorType) + document.getSize());
      counts.put(editorType, counts.get(editorType) + 1);
    }

    // Calculate averages
    for (String editorType : sumSizes.keySet()) {
      int count = counts.get(editorType);
      if (count > 0) {
        averageSizes.put(editorType, (float) sumSizes.get(editorType) / count);
      } else {
        averageSizes.put(editorType, 0f);
      }
    }

    return averageSizes;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the number of documents created after a specified date.
   * Algorithm:
   *   1. Initialize count to 0.
   *   2. For each document in the documents list:
   *      a. If the document's creation date is after the specified date:
   *         i. Increment the count.
   *   3. Return the count.
   * Input: date (EDate) - The date to compare against. Must be a valid date.
   * Output: int - The number of documents created after the specified date. Returns 0 if no documents meet the criteria.
   * Pre-condition: The documents list must be initialized, and the input date must be valid.
   * Post-condition: The count of documents created after the specified date is returned.
   * <!-- end-model-doc -->
   * @model dateRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int countDocumentsAfterDate(final Date date)
  {
    int count = 0;
    for (Document document : getDocuments()) {
      if (document.getCreateDate().after(date)) {
        count++;
      }
    }
    return count;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves the names of all authors whose documents are edited with a specified editor.
   * Algorithm:
   *   1. Initialize a list to store author names.
   *   2. For each document in the documents list:
   *      a. If the document's editor matches the specified editor:
   *         i. Add the document's author to the list.
   *   3. Return the list of author names.
   * Input: editor (Editor) - The editor to filter documents by. Must be a valid editor.
   * Output: List<String> - A list of author names whose documents are edited with the specified editor. Returns an empty list if no documents meet the criteria.
   * Pre-condition: The documents list must be initialized, and the input editor must be valid.
   * Post-condition: The list of author names is returned.
   * <!-- end-model-doc -->
   * @model editorRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> getAuthorsByEditor(final Editor editor)
  {
    BasicEList<String> authors = new BasicEList<>();
    for (Document document : getDocuments()) {
      if (document.getEditor() == editor) {
        authors.add(document.getAuthor());
      }
    }
    return authors;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the number of documents for each editor type in the file system.
   * Algorithm:
   *   1. Initialize a map to store editor types and their document counts.
   *   2. For each editor in the editors list:
   *      a. Initialize the count for the editor type to 0.
   *   3. For each document in the documents list:
   *      a. Get the editor type of the document.
   *      b. Increment the count for the corresponding editor type.
   *   4. Return the map with editor types and their document counts.
   * Input: None
   * Output: EMap - A map where keys are editor types (TextEditor, ImageEditor, VideoEditor) and values are the counts of documents for each type. Returns an empty map if there are no documents.
   * Pre-condition: The editors and documents lists must be initialized.
   * Post-condition: The map of document counts per editor type is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public Map<String, Integer> countDocumentsPerEditorType()
  {
    Map<String, Integer> documentCounts = new HashMap<>();

    // Initialize counts for each editor type
    for (Editor editor : getEditors()) {
      String editorType = editor.getName();
      documentCounts.put(editorType, 0);
    }

    // Count documents for each editor type
    for (Document document : getDocuments()) {
      String editorType = document.getEditor().getName();
      documentCounts.put(editorType, documentCounts.get(editorType) + 1);
    }

    return documentCounts;
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // FileSystem
340647 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../FileManager/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../FileManager/src-gen/edu/fs/
340754 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
340754 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
340754 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
340754 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
340756 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample5.mwe2 启动完成
正在拷贝 src-gen/edu/fs 到 mistral-small-3.2-24b-instruct/fs5...
拷贝完成！

======================================
所有任务完成！
======================================

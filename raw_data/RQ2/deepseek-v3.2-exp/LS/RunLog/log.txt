   *   int - The total number of unique books ever borrowed by the user. Range: >= 0
   * Pre-condition: The user must exist in the system
   * Post-condition: Returns the count of distinct books across all time periods
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int totalUniqueBooksCheckedOutByUser(final User user)
  {
    Set<Book> uniqueBooks = new HashSet<Book>();
    EList<CheckOut> checkouts = user.getCheckouts();
    for (CheckOut checkout : checkouts) {
      uniqueBooks.add(checkout.getBook());
    }
    return uniqueBooks.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the average page count of the unique books borrowed by a specific user
   * Algorithm:
   *   Initialize an empty set of books
   *   Initialize totalPages = 0
   *   For each checkout in user.checkouts:
   *     Add checkout.book to the set
   *   For each book in the set:
   *     totalPages += book.numberOfPages
   *   If set is not empty:
   *     Return totalPages / set.size()
   *   Else:
   *     Return 0.0
   * Input:
   *   user: User - The user to analyze. Must be a valid user in the system
   * Output:
   *   double - The average page count of unique books borrowed by the user. Range: >= 0.0
   * Pre-condition: The user must exist in the system
   * Post-condition: The average is calculated across all unique books ever borrowed by the user
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double averageNumberOfPagesUniqueBooksByUser(final User user)
  {
    Set<Book> uniqueBooks = new HashSet<Book>();
    EList<CheckOut> checkouts = user.getCheckouts();
    for (CheckOut checkout : checkouts) {
      uniqueBooks.add(checkout.getBook());
    }
    
    if (uniqueBooks.isEmpty()) {
      return 0.0;
    }
    
    int totalPages = 0;
    for (Book book : uniqueBooks) {
      totalPages += book.getNumberOfPages();
    }
    
    return (double) totalPages / uniqueBooks.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Determines how many unique books a particular user has borrowed during a specified period
   * Algorithm:
   *   Initialize an empty set of books
   *   For each checkout in user.checkouts:
   *     If checkout.startDate >= start AND checkout.endDate <= end:
   *       Add checkout.book to the set
   *   Return the size of the set
   * Input:
   *   user: User - The user to analyze. Must be a valid user in the system
   *   start: EDate - The start date of the period (inclusive). Format: yyyy-MM-dd
   *   end: EDate - The end date of the period (inclusive). Format: yyyy-MM-dd
   * Output:
   *   int - The number of unique books borrowed by the user during the specified period. Range: >= 0
   * Pre-condition: 
   *   - The user must exist in the system
   *   - start date must be <= end date
   *   - Dates must be in valid format
   * Post-condition: Only books borrowed within the exact date range are counted
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int uniqueBooksBorrowedByUser(final User user, final Date start, final Date end)
  {
    Set<Book> uniqueBooks = new HashSet<Book>();
    EList<CheckOut> checkouts = user.getCheckouts();
    for (CheckOut checkout : checkouts) {
      Date checkoutStart = checkout.getStartDate();
      Date checkoutEnd = checkout.getEndDate();
      if (checkoutStart.compareTo(start) >= 0 && checkoutEnd.compareTo(end) <= 0) {
        uniqueBooks.add(checkout.getBook());
      }
    }
    return uniqueBooks.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the number of times a specific book has been checked out by any user
   * Algorithm:
   *   Initialize count = 0
   *   For each user in users:
   *     For each checkout in user.checkouts:
   *       If checkout.book equals the input book, then increment count
   *   Return count
   * Input: 
   *   book: Book - The book to count checkouts for. Must be a valid Book object from the system
   * Output: 
   *   int - The total number of checkouts for the specified book. Range: >= 0
   * Pre-condition: The book must exist in the library system
   * Post-condition: The returned count accurately reflects all historical checkouts of the book
   * <!-- end-model-doc -->
   * @model required="true" bookRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int countBookCheckOuts(final Book book)
  {
    int count = 0;
    for (User user : getUsers()) {
      for (CheckOut checkout : user.getCheckouts()) {
        if (checkout.getBook().equals(book)) {
          count++;
        }
      }
    }
    return count;
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // LibrarySystem
238903 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../LS/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../LS/src-gen/edu/library/
239141 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
239141 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
239141 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
239141 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
239143 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample2.mwe2 启动完成
正在拷贝 src-gen/edu/library 到 deepseek-v3.2-exp/library2...
拷贝完成！

======================================
正在启动 sample3.mwe2...
======================================
239458 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
239569 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project LS at 'file:/D:/EclipseWorkspace/LS/'
239572 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
239581 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@13047d3d
239581 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
239583 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
239584 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
An automated library book borrowing system maintains a collection of books. Each book has title, barcode, ISBN, and number of pages. In addition, the system allows users to have either a MEMBER User or a GUEST User. Each user (member/guest) has a name, email, address, and ID. A user can checkout a book on loan which has the start date and end date (format: yyyy-MM-dd).

A user can checkout a book on loan which has the start date and end date.
Function Requirement:
+ Count the number of times a specific book has been checked out.
+ Determine how many unique books a particular user has borrowed during a specified period.
+ Calculate the average page count of the unique books borrowed by a specific user.
+ Calculate the total number of unique books checked out by a specific user.
```

# Class Diagram
```plantuml
@startuml

title library Model

class Book {
    ISBN : String
    barcode : String
    numberOfPages : EIntegerObject
    title : String
}
class CheckOut {
    endDate : EDate
    startDate : EDate
    book : Book
    user : User
}
class LibrarySystem {
    books : List<Book>
    users : List<User>
    averageNumberOfPagesUniqueBooksByUser(user : User) : double
    countBookCheckOuts(book : Book) : int
    totalUniqueBooksCheckedOutByUser(user : User) : int
    uniqueBooksBorrowedByUser(user : User, start : EDate, end : EDate) : int
}
class User {
    ID : String
    address : String
    email : String
    name : String
    type : UserType
    checkouts : List<CheckOut>
}
enum UserType {
    MEMBER
    GUEST
}

CheckOut --> Book : book
CheckOut --> User : user  'opposite: checkouts
LibrarySystem *-- "*" Book : books
LibrarySystem --> "*" User : users
User *-- "*" CheckOut : checkouts  'opposite: user
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

277204 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@20c283b4 (name: totalUniqueBooksCheckedOutByUser) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary: Calculates the total number of unique books checked out by a specific user.
Algorithm:
  Initialize an empty set of books
  For each checkout in the user's checkouts list:
    Add checkout.book to the set
  Return the size of the set
Input:
  user: User - The user to analyze. Must be a valid User instance from the system.
Output:
  int - The total number of unique books ever borrowed by the user. Range: >= 0.
Pre-condition:
  The user must exist in the library system
Post-condition:
  The returned count accurately reflects all unique books borrowed by the user throughout history, org.eclipse.emf.ecore.impl.EOperationImpl@628bcf2c (name: uniqueBooksBorrowedByUser) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary: Counts how many unique books a particular user has borrowed during a specified period.
Algorithm:
  Initialize an empty set of books
  For each checkout in the user's checkouts list:
    If checkout.startDate >= start AND checkout.endDate <= end:
      Add checkout.book to the set
  Return the size of the set
Input:
  user: User - The user to analyze. Must be a valid User instance from the system.
  start: EDate - The start date of the period (inclusive). Format: yyyy-MM-dd.
  end: EDate - The end date of the period (inclusive). Format: yyyy-MM-dd.
Output:
  int - The number of unique books borrowed by the user during the specified period. Range: >= 0.
Pre-condition:
  The user must exist in the library system
  start date must be <= end date
  Dates must be in valid format
Post-condition:
  The returned count accurately reflects unique books borrowed within the date range, org.eclipse.emf.ecore.impl.EOperationImpl@4b76251c (name: averageNumberOfPagesUniqueBooksByUser) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary: Calculates the average page count of the unique books borrowed by a specific user.
Algorithm:
  Initialize an empty set of books
  Initialize totalPages = 0
  For each checkout in the user's checkouts list:
    If checkout.book is not already in the set:
      Add checkout.book to the set
      Add checkout.book.numberOfPages to totalPages
  If set is empty, return 0.0
  Else return totalPages / set.size()
Input:
  user: User - The user to analyze. Must be a valid User instance from the system.
Output:
  double - The average number of pages per unique book borrowed by the user. Range: >= 0.0.
Pre-condition:
  The user must exist in the library system
  All books must have valid numberOfPages values (> 0)
Post-condition:
  The returned average is calculated correctly for all unique books ever borrowed by the user, org.eclipse.emf.ecore.impl.EOperationImpl@446a5aa5 (name: countBookCheckOuts) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary: Counts the number of times a specific book has been checked out by any user.
Algorithm: 
  Initialize counter = 0
  For each user in the users list:
    For each checkout in the user's checkouts list:
      If checkout.book equals the input book, increment counter
  Return counter
Input: 
  book: Book - The book object to count checkouts for. Must be a valid Book instance from the system.
Output: 
  int - The total number of checkout records found for this book across all users. Range: >= 0.
Pre-condition: 
  The book must exist in the library system (books list)
  The users list and all user checkout lists must be properly initialized
Post-condition: 
  The returned count accurately reflects all historical checkouts of the book}
277206 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
277230 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../LS/src-gen/edu/library
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.library;

import java.util.Collection;
import java.util.Date;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.library.LibrarySystem#getUsers <em>Users</em>}</li>
 *   <li>{@link edu.library.LibrarySystem#getBooks <em>Books</em>}</li>
 * </ul>
 *
 * @see edu.library.LibraryPackage#getLibrarySystem()
 * @model kind="class"
 * @generated
 */
public class LibrarySystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<User> users;

  protected EList<Book> books;

  protected LibrarySystem()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<User> getUsers()
  { ... /* omitted */ }

  public EList<Book> getBooks()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total number of unique books checked out by a specific user.
   * Algorithm:
   *   Initialize an empty set of books
   *   For each checkout in the user's checkouts list:
   *     Add checkout.book to the set
   *   Return the size of the set
   * Input:
   *   user: User - The user to analyze. Must be a valid User instance from the system.
   * Output:
   *   int - The total number of unique books ever borrowed by the user. Range: >= 0.
   * Pre-condition:
   *   The user must exist in the library system
   * Post-condition:
   *   The returned count accurately reflects all unique books borrowed by the user throughout history
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int totalUniqueBooksCheckedOutByUser(final User user)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the average page count of the unique books borrowed by a specific user.
   * Algorithm:
   *   Initialize an empty set of books
   *   Initialize totalPages = 0
   *   For each checkout in the user's checkouts list:
   *     If checkout.book is not already in the set:
   *       Add checkout.book to the set
   *       Add checkout.book.numberOfPages to totalPages
   *   If set is empty, return 0.0
   *   Else return totalPages / set.size()
   * Input:
   *   user: User - The user to analyze. Must be a valid User instance from the system.
   * Output:
   *   double - The average number of pages per unique book borrowed by the user. Range: >= 0.0.
   * Pre-condition:
   *   The user must exist in the library system
   *   All books must have valid numberOfPages values (> 0)
   * Post-condition:
   *   The returned average is calculated correctly for all unique books ever borrowed by the user
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double averageNumberOfPagesUniqueBooksByUser(final User user)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts how many unique books a particular user has borrowed during a specified period.
   * Algorithm:
   *   Initialize an empty set of books
   *   For each checkout in the user's checkouts list:
   *     If checkout.startDate >= start AND checkout.endDate <= end:
   *       Add checkout.book to the set
   *   Return the size of the set
   * Input:
   *   user: User - The user to analyze. Must be a valid User instance from the system.
   *   start: EDate - The start date of the period (inclusive). Format: yyyy-MM-dd.
   *   end: EDate - The end date of the period (inclusive). Format: yyyy-MM-dd.
   * Output:
   *   int - The number of unique books borrowed by the user during the specified period. Range: >= 0.
   * Pre-condition:
   *   The user must exist in the library system
   *   start date must be <= end date
   *   Dates must be in valid format
   * Post-condition:
   *   The returned count accurately reflects unique books borrowed within the date range
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int uniqueBooksBorrowedByUser(final User user, final Date start, final Date end)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the number of times a specific book has been checked out by any user.
   * Algorithm: 
   *   Initialize counter = 0
   *   For each user in the users list:
   *     For each checkout in the user's checkouts list:
   *       If checkout.book equals the input book, increment counter
   *   Return counter
   * Input: 
   *   book: Book - The book object to count checkouts for. Must be a valid Book instance from the system.
   * Output: 
   *   int - The total number of checkout records found for this book across all users. Range: >= 0.
   * Pre-condition: 
   *   The book must exist in the library system (books list)
   *   The users list and all user checkout lists must be properly initialized
   * Post-condition: 
   *   The returned count accurately reflects all historical checkouts of the book
   * <!-- end-model-doc -->
   * @model required="true" bookRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int countBookCheckOuts(final Book book)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // LibrarySystem
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `User` contains the following methods.
  + Instance creation: Use `LibraryFactory.eINSTANCE.createUser()`
  + Getter methods: public String getName(), public String getEmail(), public String getAddress(), public String getID(), public UserType getType(), public EList<CheckOut> getCheckouts()
  + Setter methods: public void setName(String newName), public void setEmail(String newEmail), public void setAddress(String newAddress), public void setID(String newID), public void setType(UserType newType)
- Class `Book` contains the following methods.
  + Instance creation: Use `LibraryFactory.eINSTANCE.createBook()`
  + Getter methods: public String getTitle(), public String getBarcode(), public String getISBN(), public Integer getNumberOfPages()
  + Setter methods: public void setTitle(String newTitle), public void setBarcode(String newBarcode), public void setISBN(String newISBN), public void setNumberOfPages(Integer newNumberOfPages)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.library;

import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.library.LibrarySystem#getUsers <em>Users</em>}</li>
 *   <li>{@link edu.library.LibrarySystem#getBooks <em>Books</em>}</li>
 * </ul>
 *
 * @see edu.library.LibraryPackage#getLibrarySystem()
 * @model kind="class"
 * @generated
 */
public class LibrarySystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<User> users;

  protected EList<Book> books;

  protected LibrarySystem()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<User> getUsers()
  { ... /* omitted */ }

  public EList<Book> getBooks()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total number of unique books checked out by a specific user.
   * Algorithm:
   *   Initialize an empty set of books
   *   For each checkout in the user's checkouts list:
   *     Add checkout.book to the set
   *   Return the size of the set
   * Input:
   *   user: User - The user to analyze. Must be a valid User instance from the system.
   * Output:
   *   int - The total number of unique books ever borrowed by the user. Range: >= 0.
   * Pre-condition:
   *   The user must exist in the library system
   * Post-condition:
   *   The returned count accurately reflects all unique books borrowed by the user throughout history
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int totalUniqueBooksCheckedOutByUser(final User user)
  {
    Set<Book> uniqueBooks = new HashSet<>();
    EList<CheckOut> checkouts = user.getCheckouts();
    
    for (CheckOut checkout : checkouts) {
      uniqueBooks.add(checkout.getBook());
    }
    
    return uniqueBooks.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the average page count of the unique books borrowed by a specific user.
   * Algorithm:
   *   Initialize an empty set of books
   *   Initialize totalPages = 0
   *   For each checkout in the user's checkouts list:
   *     If checkout.book is not already in the set:
   *       Add checkout.book to the set
   *       Add checkout.book.numberOfPages to totalPages
   *   If set is empty, return 0.0
   *   Else return totalPages / set.size()
   * Input:
   *   user: User - The user to analyze. Must be a valid User instance from the system.
   * Output:
   *   double - The average number of pages per unique book borrowed by the user. Range: >= 0.0.
   * Pre-condition:
   *   The user must exist in the library system
   *   All books must have valid numberOfPages values (> 0)
   * Post-condition:
   *   The returned average is calculated correctly for all unique books ever borrowed by the user
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double averageNumberOfPagesUniqueBooksByUser(final User user)
  {
    Set<Book> uniqueBooks = new HashSet<>();
    int totalPages = 0;
    EList<CheckOut> checkouts = user.getCheckouts();
    
    for (CheckOut checkout : checkouts) {
      Book book = checkout.getBook();
      if (!uniqueBooks.contains(book)) {
        uniqueBooks.add(book);
        totalPages += book.getNumberOfPages();
      }
    }
    
    if (uniqueBooks.isEmpty()) {
      return 0.0;
    }
    
    return (double) totalPages / uniqueBooks.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts how many unique books a particular user has borrowed during a specified period.
   * Algorithm:
   *   Initialize an empty set of books
   *   For each checkout in the user's checkouts list:
   *     If checkout.startDate >= start AND checkout.endDate <= end:
   *       Add checkout.book to the set
   *   Return the size of the set
   * Input:
   *   user: User - The user to analyze. Must be a valid User instance from the system.
   *   start: EDate - The start date of the period (inclusive). Format: yyyy-MM-dd.
   *   end: EDate - The end date of the period (inclusive). Format: yyyy-MM-dd.
   * Output:
   *   int - The number of unique books borrowed by the user during the specified period. Range: >= 0.
   * Pre-condition:
   *   The user must exist in the library system
   *   start date must be <= end date
   *   Dates must be in valid format
   * Post-condition:
   *   The returned count accurately reflects unique books borrowed within the date range
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int uniqueBooksBorrowedByUser(final User user, final Date start, final Date end)
  {
    Set<Book> uniqueBooks = new HashSet<>();
    EList<CheckOut> checkouts = user.getCheckouts();
    
    for (CheckOut checkout : checkouts) {
      Date checkoutStart = checkout.getStartDate();
      Date checkoutEnd = checkout.getEndDate();
      
      if (checkoutStart.compareTo(start) >= 0 && checkoutEnd.compareTo(end) <= 0) {
        uniqueBooks.add(checkout.getBook());
      }
    }
    
    return uniqueBooks.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the number of times a specific book has been checked out by any user.
   * Algorithm: 
   *   Initialize counter = 0
   *   For each user in the users list:
   *     For each checkout in the user's checkouts list:
   *       If checkout.book equals the input book, increment counter
   *   Return counter
   * Input: 
   *   book: Book - The book object to count checkouts for. Must be a valid Book instance from the system.
   * Output: 
   *   int - The total number of checkout records found for this book across all users. Range: >= 0.
   * Pre-condition: 
   *   The book must exist in the library system (books list)
   *   The users list and all user checkout lists must be properly initialized
   * Post-condition: 
   *   The returned count accurately reflects all historical checkouts of the book
   * <!-- end-model-doc -->
   * @model required="true" bookRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int countBookCheckOuts(final Book book)
  {
    int counter = 0;
    EList<User> usersList = getUsers();
    
    for (User user : usersList) {
      EList<CheckOut> checkouts = user.getCheckouts();
      for (CheckOut checkout : checkouts) {
        if (checkout.getBook().equals(book)) {
          counter++;
        }
      }
    }
    
    return counter;
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // LibrarySystem
311952 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../LS/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../LS/src-gen/edu/library/
312100 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
312100 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
312100 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
312100 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
312101 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample3.mwe2 启动完成
正在拷贝 src-gen/edu/library 到 deepseek-v3.2-exp/library3...
拷贝完成！

======================================
正在启动 sample4.mwe2...
======================================
312347 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
312443 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project LS at 'file:/D:/EclipseWorkspace/LS/'
312446 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
312453 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@790d629a
312453 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
312455 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
312457 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
An automated library book borrowing system maintains a collection of books. Each book has title, barcode, ISBN, and number of pages. In addition, the system allows users to have either a MEMBER User or a GUEST User. Each user (member/guest) has a name, email, address, and ID. A user can checkout a book on loan which has the start date and end date (format: yyyy-MM-dd).

A user can checkout a book on loan which has the start date and end date.
Function Requirement:
+ Count the number of times a specific book has been checked out.
+ Determine how many unique books a particular user has borrowed during a specified period.
+ Calculate the average page count of the unique books borrowed by a specific user.
+ Calculate the total number of unique books checked out by a specific user.
```

# Class Diagram
```plantuml
@startuml

title library Model

class Book {
    ISBN : String
    barcode : String
    numberOfPages : EIntegerObject
    title : String
}
class CheckOut {
    endDate : EDate
    startDate : EDate
    book : Book
    user : User
}
class LibrarySystem {
    books : List<Book>
    users : List<User>
    averageNumberOfPagesUniqueBooksByUser(user : User) : double
    countBookCheckOuts(book : Book) : int
    totalUniqueBooksCheckedOutByUser(user : User) : int
    uniqueBooksBorrowedByUser(user : User, start : EDate, end : EDate) : int
}
class User {
    ID : String
    address : String
    email : String
    name : String
    type : UserType
    checkouts : List<CheckOut>
}
enum UserType {
    MEMBER
    GUEST
}

CheckOut --> Book : book
CheckOut --> User : user  'opposite: checkouts
LibrarySystem *-- "*" Book : books
LibrarySystem --> "*" User : users
User *-- "*" CheckOut : checkouts  'opposite: user
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

342906 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@74ee97cb (name: uniqueBooksBorrowedByUser) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary: Determines how many unique books a particular user has borrowed during a specified period.
Algorithm:
  1. Create an empty set of books
  2. For each checkout in the user's checkout list:
       a. If checkout.startDate >= start AND checkout.endDate <= end:
           i. Add checkout.book to the set
  3. Return the size of the set
Input:
  - user: User object for which to count unique books
  - start: EDate representing the start of the period (inclusive, format: yyyy-MM-dd)
  - end: EDate representing the end of the period (inclusive, format: yyyy-MM-dd)
Output:
  - int: Count of unique books borrowed by the user during the specified period (non-negative integer)
Pre-condition: start date <= end date; user exists in the system
Post-condition: Returns accurate count of distinct books borrowed in the time window, org.eclipse.emf.ecore.impl.EOperationImpl@7d216ee8 (name: countBookCheckOuts) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary: Counts the total number of times a specific book has been checked out by any user.
Algorithm: 
  1. Initialize counter = 0
  2. For each user in the system's user list:
       a. For each checkout in the user's checkout list:
           i. If checkout.book equals the input book, increment counter
  3. Return counter
Input: 
  - book: Book object representing the book to count checkouts for
Output: 
  - int: Total count of checkouts for the specified book (non-negative integer)
Pre-condition: The book must exist in the system
Post-condition: Returns accurate count based on all recorded checkouts, org.eclipse.emf.ecore.impl.EOperationImpl@268e30d4 (name: averageNumberOfPagesUniqueBooksByUser) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary: Calculates the average page count of the unique books borrowed by a specific user across all their checkouts.
Algorithm:
  1. Create an empty set of books
  2. For each checkout in the user's checkout list:
       a. Add checkout.book to the set
  3. If set is empty, return 0
  4. Calculate total pages = sum of numberOfPages for all books in the set
  5. Return total pages / set size
Input:
  - user: User object for which to calculate average pages
Output:
  - double: Average number of pages across unique books borrowed by the user (non-negative floating point)
Pre-condition: User exists in the system
Post-condition: Returns accurate average; returns 0 if user has no checkouts, org.eclipse.emf.ecore.impl.EOperationImpl@7c50709a (name: totalUniqueBooksCheckedOutByUser) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary: Calculates the total number of unique books checked out by a specific user across all time.
Algorithm:
  1. Create an empty set of books
  2. For each checkout in the user's checkout list:
       a. Add checkout.book to the set
  3. Return the size of the set
Input:
  - user: User object for which to count unique books
Output:
  - int: Total count of unique books ever borrowed by the user (non-negative integer)
Pre-condition: User exists in the system
Post-condition: Returns accurate count of distinct books across all checkouts}
342909 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
342982 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../LS/src-gen/edu/library
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.library;

import java.util.Collection;
import java.util.Date;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.library.LibrarySystem#getUsers <em>Users</em>}</li>
 *   <li>{@link edu.library.LibrarySystem#getBooks <em>Books</em>}</li>
 * </ul>
 *
 * @see edu.library.LibraryPackage#getLibrarySystem()
 * @model kind="class"
 * @generated
 */
public class LibrarySystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<User> users;

  protected EList<Book> books;

  protected LibrarySystem()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<User> getUsers()
  { ... /* omitted */ }

  public EList<Book> getBooks()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total number of unique books checked out by a specific user across all time.
   * Algorithm:
   *   1. Create an empty set of books
   *   2. For each checkout in the user's checkout list:
   *        a. Add checkout.book to the set
   *   3. Return the size of the set
   * Input:
   *   - user: User object for which to count unique books
   * Output:
   *   - int: Total count of unique books ever borrowed by the user (non-negative integer)
   * Pre-condition: User exists in the system
   * Post-condition: Returns accurate count of distinct books across all checkouts
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int totalUniqueBooksCheckedOutByUser(final User user)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the average page count of the unique books borrowed by a specific user across all their checkouts.
   * Algorithm:
   *   1. Create an empty set of books
   *   2. For each checkout in the user's checkout list:
   *        a. Add checkout.book to the set
   *   3. If set is empty, return 0
   *   4. Calculate total pages = sum of numberOfPages for all books in the set
   *   5. Return total pages / set size
   * Input:
   *   - user: User object for which to calculate average pages
   * Output:
   *   - double: Average number of pages across unique books borrowed by the user (non-negative floating point)
   * Pre-condition: User exists in the system
   * Post-condition: Returns accurate average; returns 0 if user has no checkouts
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double averageNumberOfPagesUniqueBooksByUser(final User user)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Determines how many unique books a particular user has borrowed during a specified period.
   * Algorithm:
   *   1. Create an empty set of books
   *   2. For each checkout in the user's checkout list:
   *        a. If checkout.startDate >= start AND checkout.endDate <= end:
   *            i. Add checkout.book to the set
   *   3. Return the size of the set
   * Input:
   *   - user: User object for which to count unique books
   *   - start: EDate representing the start of the period (inclusive, format: yyyy-MM-dd)
   *   - end: EDate representing the end of the period (inclusive, format: yyyy-MM-dd)
   * Output:
   *   - int: Count of unique books borrowed by the user during the specified period (non-negative integer)
   * Pre-condition: start date <= end date; user exists in the system
   * Post-condition: Returns accurate count of distinct books borrowed in the time window
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int uniqueBooksBorrowedByUser(final User user, final Date start, final Date end)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the total number of times a specific book has been checked out by any user.
   * Algorithm: 
   *   1. Initialize counter = 0
   *   2. For each user in the system's user list:
   *        a. For each checkout in the user's checkout list:
   *            i. If checkout.book equals the input book, increment counter
   *   3. Return counter
   * Input: 
   *   - book: Book object representing the book to count checkouts for
   * Output: 
   *   - int: Total count of checkouts for the specified book (non-negative integer)
   * Pre-condition: The book must exist in the system
   * Post-condition: Returns accurate count based on all recorded checkouts
   * <!-- end-model-doc -->
   * @model required="true" bookRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int countBookCheckOuts(final Book book)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // LibrarySystem
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `User` contains the following methods.
  + Instance creation: Use `LibraryFactory.eINSTANCE.createUser()`
  + Getter methods: public String getName(), public String getEmail(), public String getAddress(), public String getID(), public UserType getType(), public EList<CheckOut> getCheckouts()
  + Setter methods: public void setName(String newName), public void setEmail(String newEmail), public void setAddress(String newAddress), public void setID(String newID), public void setType(UserType newType)
- Class `Book` contains the following methods.
  + Instance creation: Use `LibraryFactory.eINSTANCE.createBook()`
  + Getter methods: public String getTitle(), public String getBarcode(), public String getISBN(), public Integer getNumberOfPages()
  + Setter methods: public void setTitle(String newTitle), public void setBarcode(String newBarcode), public void setISBN(String newISBN), public void setNumberOfPages(Integer newNumberOfPages)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.library;

import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.library.LibrarySystem#getUsers <em>Users</em>}</li>
 *   <li>{@link edu.library.LibrarySystem#getBooks <em>Books</em>}</li>
 * </ul>
 *
 * @see edu.library.LibraryPackage#getLibrarySystem()
 * @model kind="class"
 * @generated
 */
public class LibrarySystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<User> users;

  protected EList<Book> books;

  protected LibrarySystem()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<User> getUsers()
  { ... /* omitted */ }

  public EList<Book> getBooks()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total number of unique books checked out by a specific user across all time.
   * Algorithm:
   *   1. Create an empty set of books
   *   2. For each checkout in the user's checkout list:
   *        a. Add checkout.book to the set
   *   3. Return the size of the set
   * Input:
   *   - user: User object for which to count unique books
   * Output:
   *   - int: Total count of unique books ever borrowed by the user (non-negative integer)
   * Pre-condition: User exists in the system
   * Post-condition: Returns accurate count of distinct books across all checkouts
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int totalUniqueBooksCheckedOutByUser(final User user)
  {
    Set<Book> uniqueBooks = new HashSet<>();
    for (CheckOut checkout : user.getCheckouts()) {
      uniqueBooks.add(checkout.getBook());
    }
    return uniqueBooks.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the average page count of the unique books borrowed by a specific user across all their checkouts.
   * Algorithm:
   *   1. Create an empty set of books
   *   2. For each checkout in the user's checkout list:
   *        a. Add checkout.book to the set
   *   3. If set is empty, return 0
   *   4. Calculate total pages = sum of numberOfPages for all books in the set
   *   5. Return total pages / set size
   * Input:
   *   - user: User object for which to calculate average pages
   * Output:
   *   - double: Average number of pages across unique books borrowed by the user (non-negative floating point)
   * Pre-condition: User exists in the system
   * Post-condition: Returns accurate average; returns 0 if user has no checkouts
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double averageNumberOfPagesUniqueBooksByUser(final User user)
  {
    Set<Book> uniqueBooks = new HashSet<>();
    for (CheckOut checkout : user.getCheckouts()) {
      uniqueBooks.add(checkout.getBook());
    }
    
    if (uniqueBooks.isEmpty()) {
      return 0.0;
    }
    
    int totalPages = 0;
    for (Book book : uniqueBooks) {
      totalPages += book.getNumberOfPages();
    }
    
    return (double) totalPages / uniqueBooks.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Determines how many unique books a particular user has borrowed during a specified period.
   * Algorithm:
   *   1. Create an empty set of books
   *   2. For each checkout in the user's checkout list:
   *        a. If checkout.startDate >= start AND checkout.endDate <= end:
   *            i. Add checkout.book to the set
   *   3. Return the size of the set
   * Input:
   *   - user: User object for which to count unique books
   *   - start: EDate representing the start of the period (inclusive, format: yyyy-MM-dd)
   *   - end: EDate representing the end of the period (inclusive, format: yyyy-MM-dd)
   * Output:
   *   - int: Count of unique books borrowed by the user during the specified period (non-negative integer)
   * Pre-condition: start date <= end date; user exists in the system
   * Post-condition: Returns accurate count of distinct books borrowed in the time window
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int uniqueBooksBorrowedByUser(final User user, final Date start, final Date end)
  {
    Set<Book> uniqueBooks = new HashSet<>();
    for (CheckOut checkout : user.getCheckouts()) {
      if (checkout.getStartDate().compareTo(start) >= 0 && checkout.getEndDate().compareTo(end) <= 0) {
        uniqueBooks.add(checkout.getBook());
      }
    }
    return uniqueBooks.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the total number of times a specific book has been checked out by any user.
   * Algorithm: 
   *   1. Initialize counter = 0
   *   2. For each user in the system's user list:
   *        a. For each checkout in the user's checkout list:
   *            i. If checkout.book equals the input book, increment counter
   *   3. Return counter
   * Input: 
   *   - book: Book object representing the book to count checkouts for
   * Output: 
   *   - int: Total count of checkouts for the specified book (non-negative integer)
   * Pre-condition: The book must exist in the system
   * Post-condition: Returns accurate count based on all recorded checkouts
   * <!-- end-model-doc -->
   * @model required="true" bookRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int countBookCheckOuts(final Book book)
  {
    int counter = 0;
    for (User user : getUsers()) {
      for (CheckOut checkout : user.getCheckouts()) {
        if (checkout.getBook().equals(book)) {
          counter++;
        }
      }
    }
    return counter;
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // LibrarySystem
391202 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../LS/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../LS/src-gen/edu/library/
391342 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
391342 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
391342 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
391342 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
391344 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample4.mwe2 启动完成
正在拷贝 src-gen/edu/library 到 deepseek-v3.2-exp/library4...
拷贝完成！

======================================
正在启动 sample5.mwe2...
======================================
391537 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
391592 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project LS at 'file:/D:/EclipseWorkspace/LS/'
391595 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
391601 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@41736818
391601 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
391602 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
391602 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
An automated library book borrowing system maintains a collection of books. Each book has title, barcode, ISBN, and number of pages. In addition, the system allows users to have either a MEMBER User or a GUEST User. Each user (member/guest) has a name, email, address, and ID. A user can checkout a book on loan which has the start date and end date (format: yyyy-MM-dd).

A user can checkout a book on loan which has the start date and end date.
Function Requirement:
+ Count the number of times a specific book has been checked out.
+ Determine how many unique books a particular user has borrowed during a specified period.
+ Calculate the average page count of the unique books borrowed by a specific user.
+ Calculate the total number of unique books checked out by a specific user.
```

# Class Diagram
```plantuml
@startuml

title library Model

class Book {
    ISBN : String
    barcode : String
    numberOfPages : EIntegerObject
    title : String
}
class CheckOut {
    endDate : EDate
    startDate : EDate
    book : Book
    user : User
}
class LibrarySystem {
    books : List<Book>
    users : List<User>
    averageNumberOfPagesUniqueBooksByUser(user : User) : double
    countBookCheckOuts(book : Book) : int
    totalUniqueBooksCheckedOutByUser(user : User) : int
    uniqueBooksBorrowedByUser(user : User, start : EDate, end : EDate) : int
}
class User {
    ID : String
    address : String
    email : String
    name : String
    type : UserType
    checkouts : List<CheckOut>
}
enum UserType {
    MEMBER
    GUEST
}

CheckOut --> Book : book
CheckOut --> User : user  'opposite: checkouts
LibrarySystem *-- "*" Book : books
LibrarySystem --> "*" User : users
User *-- "*" CheckOut : checkouts  'opposite: user
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

454706 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@2c6d442d (name: averageNumberOfPagesUniqueBooksByUser) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary: Calculates the average page count of the unique books borrowed by a specific user.
Algorithm:
  1. Initialize an empty set for unique books and totalPages = 0
  2. For each checkout in user.checkouts:
      2.1 If checkout.book is not in unique books set:
          2.1.1 Add checkout.book to unique books set
          2.1.2 Add checkout.book.numberOfPages to totalPages
  3. If unique books set is empty, return 0
  4. Else return totalPages / size of unique books set
Input:
  - user: User object to calculate average pages for
  - Format: User instance with ID, address, email, name, type, and checkouts
  - Value range: Must be a valid User object from the users list
Output:
  - double: Average number of pages across all unique books borrowed by the user
  - Value range: Non-negative double (0.0 or greater)
Pre-condition:
  - User must exist in the system
  - User's checkout list must be properly initialized
  - All books in checkouts must have valid numberOfPages values
Post-condition:
  - Returns accurate average page count of all unique books ever borrowed by the user, org.eclipse.emf.ecore.impl.EOperationImpl@1f05d08c (name: uniqueBooksBorrowedByUser) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary: Determines how many unique books a particular user has borrowed during a specified period.
Algorithm:
  1. Initialize an empty set for unique books
  2. For each checkout in user.checkouts:
      2.1 If checkout.startDate >= start AND checkout.endDate <= end:
          2.1.1 Add checkout.book to the unique books set
  3. Return the size of the unique books set
Input:
  - user: User object to analyze borrow history for
  - start: EDate representing the start of the period (inclusive)
  - end: EDate representing the end of the period (inclusive)
  - Format: Dates in yyyy-MM-dd format
  - Value range: start <= end, both dates valid
Output:
  - int: Number of unique books borrowed by the user during the specified period
  - Value range: Non-negative integer (0 or greater)
Pre-condition:
  - User must exist in the system
  - start and end dates must be valid and start <= end
  - User's checkout list must be properly initialized
Post-condition:
  - Returns accurate count of unique books borrowed within the date range, org.eclipse.emf.ecore.impl.EOperationImpl@71842e18 (name: totalUniqueBooksCheckedOutByUser) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary: Calculates the total number of unique books checked out by a specific user.
Algorithm:
  1. Initialize an empty set for unique books
  2. For each checkout in user.checkouts:
      2.1 Add checkout.book to the unique books set
  3. Return the size of the unique books set
Input:
  - user: User object to count unique books for
  - Format: User instance with ID, address, email, name, type, and checkouts
  - Value range: Must be a valid User object from the users list
Output:
  - int: Total number of unique books ever borrowed by the user
  - Value range: Non-negative integer (0 or greater)
Pre-condition:
  - User must exist in the system
  - User's checkout list must be properly initialized
Post-condition:
  - Returns accurate count of unique books across user's entire borrowing history, org.eclipse.emf.ecore.impl.EOperationImpl@799557c8 (name: countBookCheckOuts) (ordered: true, unique: true, lowerBound: 1, upperBound: 1)=Summary: Counts the number of times a specific book has been checked out by any user in the system.
Algorithm: 
  1. Initialize counter = 0
  2. For each user in users:
      2.1 For each checkout in user.checkouts:
          2.1.1 If checkout.book equals the input book, increment counter
  3. Return counter
Input: 
  - book: Book object to count checkouts for
  - Format: Book instance with ISBN, barcode, numberOfPages, title
  - Value range: Must be a valid Book object from the books list
Output: 
  - int: Total number of checkouts for the specified book
  - Value range: Non-negative integer (0 or greater)
Pre-condition: 
  - The book must exist in the library system (books list)
  - The users list and all user checkout lists must be properly initialized
Post-condition:
  - Returns accurate count of all checkout records for the specified book}
454707 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
454729 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../LS/src-gen/edu/library
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.library;

import java.util.Collection;
import java.util.Date;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.library.LibrarySystem#getUsers <em>Users</em>}</li>
 *   <li>{@link edu.library.LibrarySystem#getBooks <em>Books</em>}</li>
 * </ul>
 *
 * @see edu.library.LibraryPackage#getLibrarySystem()
 * @model kind="class"
 * @generated
 */
public class LibrarySystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<User> users;

  protected EList<Book> books;

  protected LibrarySystem()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<User> getUsers()
  { ... /* omitted */ }

  public EList<Book> getBooks()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total number of unique books checked out by a specific user.
   * Algorithm:
   *   1. Initialize an empty set for unique books
   *   2. For each checkout in user.checkouts:
   *       2.1 Add checkout.book to the unique books set
   *   3. Return the size of the unique books set
   * Input:
   *   - user: User object to count unique books for
   *   - Format: User instance with ID, address, email, name, type, and checkouts
   *   - Value range: Must be a valid User object from the users list
   * Output:
   *   - int: Total number of unique books ever borrowed by the user
   *   - Value range: Non-negative integer (0 or greater)
   * Pre-condition:
   *   - User must exist in the system
   *   - User's checkout list must be properly initialized
   * Post-condition:
   *   - Returns accurate count of unique books across user's entire borrowing history
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int totalUniqueBooksCheckedOutByUser(final User user)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the average page count of the unique books borrowed by a specific user.
   * Algorithm:
   *   1. Initialize an empty set for unique books and totalPages = 0
   *   2. For each checkout in user.checkouts:
   *       2.1 If checkout.book is not in unique books set:
   *           2.1.1 Add checkout.book to unique books set
   *           2.1.2 Add checkout.book.numberOfPages to totalPages
   *   3. If unique books set is empty, return 0
   *   4. Else return totalPages / size of unique books set
   * Input:
   *   - user: User object to calculate average pages for
   *   - Format: User instance with ID, address, email, name, type, and checkouts
   *   - Value range: Must be a valid User object from the users list
   * Output:
   *   - double: Average number of pages across all unique books borrowed by the user
   *   - Value range: Non-negative double (0.0 or greater)
   * Pre-condition:
   *   - User must exist in the system
   *   - User's checkout list must be properly initialized
   *   - All books in checkouts must have valid numberOfPages values
   * Post-condition:
   *   - Returns accurate average page count of all unique books ever borrowed by the user
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double averageNumberOfPagesUniqueBooksByUser(final User user)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Determines how many unique books a particular user has borrowed during a specified period.
   * Algorithm:
   *   1. Initialize an empty set for unique books
   *   2. For each checkout in user.checkouts:
   *       2.1 If checkout.startDate >= start AND checkout.endDate <= end:
   *           2.1.1 Add checkout.book to the unique books set
   *   3. Return the size of the unique books set
   * Input:
   *   - user: User object to analyze borrow history for
   *   - start: EDate representing the start of the period (inclusive)
   *   - end: EDate representing the end of the period (inclusive)
   *   - Format: Dates in yyyy-MM-dd format
   *   - Value range: start <= end, both dates valid
   * Output:
   *   - int: Number of unique books borrowed by the user during the specified period
   *   - Value range: Non-negative integer (0 or greater)
   * Pre-condition:
   *   - User must exist in the system
   *   - start and end dates must be valid and start <= end
   *   - User's checkout list must be properly initialized
   * Post-condition:
   *   - Returns accurate count of unique books borrowed within the date range
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int uniqueBooksBorrowedByUser(final User user, final Date start, final Date end)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the number of times a specific book has been checked out by any user in the system.
   * Algorithm: 
   *   1. Initialize counter = 0
   *   2. For each user in users:
   *       2.1 For each checkout in user.checkouts:
   *           2.1.1 If checkout.book equals the input book, increment counter
   *   3. Return counter
   * Input: 
   *   - book: Book object to count checkouts for
   *   - Format: Book instance with ISBN, barcode, numberOfPages, title
   *   - Value range: Must be a valid Book object from the books list
   * Output: 
   *   - int: Total number of checkouts for the specified book
   *   - Value range: Non-negative integer (0 or greater)
   * Pre-condition: 
   *   - The book must exist in the library system (books list)
   *   - The users list and all user checkout lists must be properly initialized
   * Post-condition:
   *   - Returns accurate count of all checkout records for the specified book
   * <!-- end-model-doc -->
   * @model required="true" bookRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int countBookCheckOuts(final Book book)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // LibrarySystem
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `User` contains the following methods.
  + Instance creation: Use `LibraryFactory.eINSTANCE.createUser()`
  + Getter methods: public String getName(), public String getEmail(), public String getAddress(), public String getID(), public UserType getType(), public EList<CheckOut> getCheckouts()
  + Setter methods: public void setName(String newName), public void setEmail(String newEmail), public void setAddress(String newAddress), public void setID(String newID), public void setType(UserType newType)
- Class `Book` contains the following methods.
  + Instance creation: Use `LibraryFactory.eINSTANCE.createBook()`
  + Getter methods: public String getTitle(), public String getBarcode(), public String getISBN(), public Integer getNumberOfPages()
  + Setter methods: public void setTitle(String newTitle), public void setBarcode(String newBarcode), public void setISBN(String newISBN), public void setNumberOfPages(Integer newNumberOfPages)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.library;

import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EObjectResolvingEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>System</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.library.LibrarySystem#getUsers <em>Users</em>}</li>
 *   <li>{@link edu.library.LibrarySystem#getBooks <em>Books</em>}</li>
 * </ul>
 *
 * @see edu.library.LibraryPackage#getLibrarySystem()
 * @model kind="class"
 * @generated
 */
public class LibrarySystem extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<User> users;

  protected EList<Book> books;

  protected LibrarySystem()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<User> getUsers()
  { ... /* omitted */ }

  public EList<Book> getBooks()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the total number of unique books checked out by a specific user.
   * Algorithm:
   *   1. Initialize an empty set for unique books
   *   2. For each checkout in user.checkouts:
   *       2.1 Add checkout.book to the unique books set
   *   3. Return the size of the unique books set
   * Input:
   *   - user: User object to count unique books for
   *   - Format: User instance with ID, address, email, name, type, and checkouts
   *   - Value range: Must be a valid User object from the users list
   * Output:
   *   - int: Total number of unique books ever borrowed by the user
   *   - Value range: Non-negative integer (0 or greater)
   * Pre-condition:
   *   - User must exist in the system
   *   - User's checkout list must be properly initialized
   * Post-condition:
   *   - Returns accurate count of unique books across user's entire borrowing history
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int totalUniqueBooksCheckedOutByUser(final User user)
  {
    Set<Book> uniqueBooks = new HashSet<>();
    for (CheckOut checkout : user.getCheckouts()) {
      uniqueBooks.add(checkout.getBook());
    }
    return uniqueBooks.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Calculates the average page count of the unique books borrowed by a specific user.
   * Algorithm:
   *   1. Initialize an empty set for unique books and totalPages = 0
   *   2. For each checkout in user.checkouts:
   *       2.1 If checkout.book is not in unique books set:
   *           2.1.1 Add checkout.book to unique books set
   *           2.1.2 Add checkout.book.numberOfPages to totalPages
   *   3. If unique books set is empty, return 0
   *   4. Else return totalPages / size of unique books set
   * Input:
   *   - user: User object to calculate average pages for
   *   - Format: User instance with ID, address, email, name, type, and checkouts
   *   - Value range: Must be a valid User object from the users list
   * Output:
   *   - double: Average number of pages across all unique books borrowed by the user
   *   - Value range: Non-negative double (0.0 or greater)
   * Pre-condition:
   *   - User must exist in the system
   *   - User's checkout list must be properly initialized
   *   - All books in checkouts must have valid numberOfPages values
   * Post-condition:
   *   - Returns accurate average page count of all unique books ever borrowed by the user
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double averageNumberOfPagesUniqueBooksByUser(final User user)
  {
    Set<Book> uniqueBooks = new HashSet<>();
    int totalPages = 0;
    for (CheckOut checkout : user.getCheckouts()) {
      Book book = checkout.getBook();
      if (!uniqueBooks.contains(book)) {
        uniqueBooks.add(book);
        totalPages += book.getNumberOfPages();
      }
    }
    if (uniqueBooks.isEmpty()) {
      return 0.0;
    }
    return (double) totalPages / uniqueBooks.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Determines how many unique books a particular user has borrowed during a specified period.
   * Algorithm:
   *   1. Initialize an empty set for unique books
   *   2. For each checkout in user.checkouts:
   *       2.1 If checkout.startDate >= start AND checkout.endDate <= end:
   *           2.1.1 Add checkout.book to the unique books set
   *   3. Return the size of the unique books set
   * Input:
   *   - user: User object to analyze borrow history for
   *   - start: EDate representing the start of the period (inclusive)
   *   - end: EDate representing the end of the period (inclusive)
   *   - Format: Dates in yyyy-MM-dd format
   *   - Value range: start <= end, both dates valid
   * Output:
   *   - int: Number of unique books borrowed by the user during the specified period
   *   - Value range: Non-negative integer (0 or greater)
   * Pre-condition:
   *   - User must exist in the system
   *   - start and end dates must be valid and start <= end
   *   - User's checkout list must be properly initialized
   * Post-condition:
   *   - Returns accurate count of unique books borrowed within the date range
   * <!-- end-model-doc -->
   * @model required="true" userRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int uniqueBooksBorrowedByUser(final User user, final Date start, final Date end)
  {
    Set<Book> uniqueBooks = new HashSet<>();
    for (CheckOut checkout : user.getCheckouts()) {
      Date checkoutStart = checkout.getStartDate();
      Date checkoutEnd = checkout.getEndDate();
      if (checkoutStart.compareTo(start) >= 0 && checkoutEnd.compareTo(end) <= 0) {
        uniqueBooks.add(checkout.getBook());
      }
    }
    return uniqueBooks.size();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the number of times a specific book has been checked out by any user in the system.
   * Algorithm: 
   *   1. Initialize counter = 0
   *   2. For each user in users:
   *       2.1 For each checkout in user.checkouts:
   *           2.1.1 If checkout.book equals the input book, increment counter
   *   3. Return counter
   * Input: 
   *   - book: Book object to count checkouts for
   *   - Format: Book instance with ISBN, barcode, numberOfPages, title
   *   - Value range: Must be a valid Book object from the books list
   * Output: 
   *   - int: Total number of checkouts for the specified book
   *   - Value range: Non-negative integer (0 or greater)
   * Pre-condition: 
   *   - The book must exist in the library system (books list)
   *   - The users list and all user checkout lists must be properly initialized
   * Post-condition:
   *   - Returns accurate count of all checkout records for the specified book
   * <!-- end-model-doc -->
   * @model required="true" bookRequired="true"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int countBookCheckOuts(final Book book)
  {
    int counter = 0;
    for (User user : getUsers()) {
      for (CheckOut checkout : user.getCheckouts()) {
        if (checkout.getBook().equals(book)) {
          counter++;
        }
      }
    }
    return counter;
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // LibrarySystem
486862 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../LS/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../LS/src-gen/edu/library/
486972 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
486972 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
486972 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
486972 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
486973 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample5.mwe2 启动完成
正在拷贝 src-gen/edu/library 到 deepseek-v3.2-exp/library5...
拷贝完成！

======================================
所有任务完成！
======================================

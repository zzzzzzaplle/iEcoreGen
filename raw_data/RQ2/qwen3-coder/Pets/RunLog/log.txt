+ Remove a specified pet from its current house. Return false if the pet does not belong to the given current house; return true if it is removed successfully.

+ Retrieve a list of pets of a specific input string ("dog" or "cat") that live in a particular house. Return an empty list if there are no pets.

+ Count the number of pets in a particular house. Return 0 if there are no pets.
```

# Class Diagram
```plantuml
@startuml

title pets Model

class Cat {
}
class Dog {
}
class House {
    lived : List<Pet>
    addPet(pet : Pet) : boolean
    getPetCount(type : String) : int
    getPetsByType(type : String) : List<Pet>
    removePet(pet : Pet) : void
    retrievePetNames() : List<String>
}
abstract class Pet {
    name : String
    house : House
    makeNoise() : void
}

Cat --|> Pet
Dog --|> Pet
House *-- "*" Pet : lived  'opposite: house
Pet --> House : house  'opposite: lived
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

192218 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@80081d7 (name: makeNoise) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Makes the pet produce its characteristic sound.
Algorithm: This is an abstract method; it should be overridden by subclasses (Cat and Dog) to produce their specific noises.
Input: None.
Output: None.
Pre-condition: None.
Post-condition: The pet makes its respective noise (e.g., bark or meow)., org.eclipse.emf.ecore.impl.EOperationImpl@2314f013 (name: removePet) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Removes a specific pet from the house if it belongs to this house.
Algorithm:
  if pet.house != this then return false
  lived.remove(pet)
  pet.house = null
  return true
Input:
  - pet: Pet instance to be removed from the house.
Output:
  - boolean: true if the pet is successfully removed; false otherwise.
Pre-condition: pet must belong to this house.
Post-condition: If successful, pet is removed from lived list and pet.house is set to null., org.eclipse.emf.ecore.impl.EOperationImpl@57d0c779 (name: addPet) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Adds a pet to the house if the pet does not already belong to any house and has a valid name.
Algorithm:
  if pet.house != null then return false
  if pet.name is null or empty then return false
  lived.add(pet)
  pet.house = this
  return true
Input:
  - pet: Pet instance to be added to the house.
Output:
  - boolean: true if the pet is successfully added; false otherwise.
Pre-condition: pet must not already belong to any house and must have a non-null, non-empty name.
Post-condition: If successful, pet is added to lived list, and pet.house is set to this house., org.eclipse.emf.ecore.impl.EOperationImpl@2f16c21f (name: getPetsByType) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary: Retrieves a list of pets that match the specified type ("dog" or "cat") living in the house.
Algorithm:
  create empty list result
  for each pet in lived do
      if type equals "dog" and pet is instance of Dog then
          add pet to result
      else if type equals "cat" and pet is instance of Cat then
          add pet to result
      end if
  end for
  return result
Input:
  - type: String indicating which type of pet to retrieve ("dog" or "cat").
Output:
  - List<Pet>: A list of pets of the specified type. Empty list if no matching pets found.
Pre-condition: type is either "dog" or "cat".
Post-condition: Returns a list containing only pets of the specified type., org.eclipse.emf.ecore.impl.EOperationImpl@72ae1007 (name: retrievePetNames) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary: Retrieves a list of names of all pets living in the house.
Algorithm:
  create empty list names
  for each pet in lived do
      add pet.name to names
  end for
  return names
Input: None.
Output:
  - List<String>: A list of pet names. Empty list if no pets are present in the house.
Pre-condition: None.
Post-condition: Returns a list of all pet names currently residing in the house., org.eclipse.emf.ecore.impl.EOperationImpl@3070f59f (name: getPetCount) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Counts the total number of pets currently living in the house.
Algorithm:
  return lived.size()
Input:
  - type: String specifying the type of pets ("dog", "cat", or any other value to count all pets).
Output:
  - int: Number of pets of the specified type in the house.
Pre-condition: None.
Post-condition: Returns the number of pets matching the specified type or all pets if type is not "dog" or "cat".}
192220 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
192238 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../Pets/src-gen/edu/pets
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getLived <em>Lived</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Pet> lived;

  protected House()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Pet> getLived()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of names of all pets living in the house.
   * Algorithm:
   *   create empty list names
   *   for each pet in lived do
   *       add pet.name to names
   *   end for
   *   return names
   * Input: None.
   * Output:
   *   - List<String>: A list of pet names. Empty list if no pets are present in the house.
   * Pre-condition: None.
   * Post-condition: Returns a list of all pet names currently residing in the house.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<String> retrievePetNames()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Adds a pet to the house if the pet does not already belong to any house and has a valid name.
   * Algorithm:
   *   if pet.house != null then return false
   *   if pet.name is null or empty then return false
   *   lived.add(pet)
   *   pet.house = this
   *   return true
   * Input:
   *   - pet: Pet instance to be added to the house.
   * Output:
   *   - boolean: true if the pet is successfully added; false otherwise.
   * Pre-condition: pet must not already belong to any house and must have a non-null, non-empty name.
   * Post-condition: If successful, pet is added to lived list, and pet.house is set to this house.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean addPet(final Pet pet)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Removes a specific pet from the house if it belongs to this house.
   * Algorithm:
   *   if pet.house != this then return false
   *   lived.remove(pet)
   *   pet.house = null
   *   return true
   * Input:
   *   - pet: Pet instance to be removed from the house.
   * Output:
   *   - boolean: true if the pet is successfully removed; false otherwise.
   * Pre-condition: pet must belong to this house.
   * Post-condition: If successful, pet is removed from lived list and pet.house is set to null.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void removePet(final Pet pet)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of pets that match the specified type ("dog" or "cat") living in the house.
   * Algorithm:
   *   create empty list result
   *   for each pet in lived do
   *       if type equals "dog" and pet is instance of Dog then
   *           add pet to result
   *       else if type equals "cat" and pet is instance of Cat then
   *           add pet to result
   *       end if
   *   end for
   *   return result
   * Input:
   *   - type: String indicating which type of pet to retrieve ("dog" or "cat").
   * Output:
   *   - List<Pet>: A list of pets of the specified type. Empty list if no matching pets found.
   * Pre-condition: type is either "dog" or "cat".
   * Post-condition: Returns a list containing only pets of the specified type.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<Pet> getPetsByType(final String type)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the total number of pets currently living in the house.
   * Algorithm:
   *   return lived.size()
   * Input:
   *   - type: String specifying the type of pets ("dog", "cat", or any other value to count all pets).
   * Output:
   *   - int: Number of pets of the specified type in the house.
   * Pre-condition: None.
   * Post-condition: Returns the number of pets matching the specified type or all pets if type is not "dog" or "cat".
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int getPetCount(final String type)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // House
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Pet` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Public methods: public void makeNoise()
  + Getter methods: public String getName(), public House getHouse()
  + Setter methods: public void setName(String newName), public void setHouse(House newHouse)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getLived <em>Lived</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Pet> lived;

  protected House()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Pet> getLived()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of names of all pets living in the house.
   * Algorithm:
   *   create empty list names
   *   for each pet in lived do
   *       add pet.name to names
   *   end for
   *   return names
   * Input: None.
   * Output:
   *   - List<String>: A list of pet names. Empty list if no pets are present in the house.
   * Pre-condition: None.
   * Post-condition: Returns a list of all pet names currently residing in the house.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> retrievePetNames()
  {
    EList<String> names = new BasicEList<String>();
    for (Pet pet : getLived()) {
      names.add(pet.getName());
    }
    return names;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Adds a pet to the house if the pet does not already belong to any house and has a valid name.
   * Algorithm:
   *   if pet.house != null then return false
   *   if pet.name is null or empty then return false
   *   lived.add(pet)
   *   pet.house = this
   *   return true
   * Input:
   *   - pet: Pet instance to be added to the house.
   * Output:
   *   - boolean: true if the pet is successfully added; false otherwise.
   * Pre-condition: pet must not already belong to any house and must have a non-null, non-empty name.
   * Post-condition: If successful, pet is added to lived list, and pet.house is set to this house.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean addPet(final Pet pet)
  {
    if (pet.getHouse() != null) return false;
    if (pet.getName() == null || pet.getName().isEmpty()) return false;
    getLived().add(pet);
    pet.setHouse(this);
    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Removes a specific pet from the house if it belongs to this house.
   * Algorithm:
   *   if pet.house != this then return false
   *   lived.remove(pet)
   *   pet.house = null
   *   return true
   * Input:
   *   - pet: Pet instance to be removed from the house.
   * Output:
   *   - boolean: true if the pet is successfully removed; false otherwise.
   * Pre-condition: pet must belong to this house.
   * Post-condition: If successful, pet is removed from lived list and pet.house is set to null.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void removePet(final Pet pet)
  {
    if (pet.getHouse() != this) return;
    getLived().remove(pet);
    pet.setHouse(null);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of pets that match the specified type ("dog" or "cat") living in the house.
   * Algorithm:
   *   create empty list result
   *   for each pet in lived do
   *       if type equals "dog" and pet is instance of Dog then
   *           add pet to result
   *       else if type equals "cat" and pet is instance of Cat then
   *           add pet to result
   *       end if
   *   end for
   *   return result
   * Input:
   *   - type: String indicating which type of pet to retrieve ("dog" or "cat").
   * Output:
   *   - List<Pet>: A list of pets of the specified type. Empty list if no matching pets found.
   * Pre-condition: type is either "dog" or "cat".
   * Post-condition: Returns a list containing only pets of the specified type.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Pet> getPetsByType(final String type)
  {
    EList<Pet> result = new BasicEList<Pet>();
    for (Pet pet : getLived()) {
      if ("dog".equals(type) && pet instanceof Dog) {
        result.add(pet);
      } else if ("cat".equals(type) && pet instanceof Cat) {
        result.add(pet);
      }
    }
    return result;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the total number of pets currently living in the house.
   * Algorithm:
   *   return lived.size()
   * Input:
   *   - type: String specifying the type of pets ("dog", "cat", or any other value to count all pets).
   * Output:
   *   - int: Number of pets of the specified type in the house.
   * Pre-condition: None.
   * Post-condition: Returns the number of pets matching the specified type or all pets if type is not "dog" or "cat".
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int getPetCount(final String type)
  {
    if ("dog".equals(type)) {
      int count = 0;
      for (Pet pet : getLived()) {
        if (pet instanceof Dog) count++;
      }
      return count;
    } else if ("cat".equals(type)) {
      int count = 0;
      for (Pet pet : getLived()) {
        if (pet instanceof Cat) count++;
      }
      return count;
    } else {
      return getLived().size();
    }
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // House
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public House getHouse()
  { ... /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { ... /* omitted */ }

  public void setHouse(House newHouse)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet produce its characteristic sound.
   * Algorithm: This is an abstract method; it should be overridden by subclasses (Cat and Dog) to produce their specific noises.
   * Input: None.
   * Output: None.
   * Pre-condition: None.
   * Post-condition: The pet makes its respective noise (e.g., bark or meow).
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void makeNoise()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `House` contains the following methods.
  + Instance creation: Use `PetsFactory.eINSTANCE.createHouse()`
  + Public methods: public EList<String> retrievePetNames(), public boolean addPet(final Pet pet), public void removePet(final Pet pet), public EList<Pet> getPetsByType(final String type), public int getPetCount(final String type)
  + Getter methods: public EList<Pet> getLived()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public House getHouse()
  { ... /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { ... /* omitted */ }

  public void setHouse(House newHouse)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet produce its characteristic sound.
   * Algorithm: This is an abstract method; it should be overridden by subclasses (Cat and Dog) to produce their specific noises.
   * Input: None.
   * Output: None.
   * Pre-condition: None.
   * Post-condition: The pet makes its respective noise (e.g., bark or meow).
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void makeNoise()
  {
    // Abstract method - to be implemented by subclasses
    throw new UnsupportedOperationException("Abstract method must be overridden in subclass");
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
256639 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../Pets/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../Pets/src-gen/edu/pets/
256747 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
256747 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
256747 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
256747 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
256748 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample4.mwe2 启动完成
正在拷贝 src-gen/edu/pets 到 qwen3-coder/pets4...
拷贝完成！

======================================
正在启动 sample5.mwe2...
======================================
256944 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
257016 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project Pets at 'file:/D:/EclipseWorkspace/Pets/'
257019 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
257039 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@502f6f6a
257039 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
257042 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
257042 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
A house may have any number of pets living in it. The two possible types of pets that can live in a house are dogs and cats. Each dog or cat has a name. An animal’s house is its one and only home. You can tell an animal to make noise and it will do its thing.
Functional requirement：
+ Retrieve a list of all pet names (dogs and cats) living in a specified house. Return an empty list if there are no pets.

+ Add a pet to the house. Return false if the pet already belongs to any house (including this one) or the pet does have name; return true if the pet is added successfully.

+ Remove a specified pet from its current house. Return false if the pet does not belong to the given current house; return true if it is removed successfully.

+ Retrieve a list of pets of a specific input string ("dog" or "cat") that live in a particular house. Return an empty list if there are no pets.

+ Count the number of pets in a particular house. Return 0 if there are no pets.
```

# Class Diagram
```plantuml
@startuml

title pets Model

class Cat {
}
class Dog {
}
class House {
    lived : List<Pet>
    addPet(pet : Pet) : boolean
    getPetCount(type : String) : int
    getPetsByType(type : String) : List<Pet>
    removePet(pet : Pet) : void
    retrievePetNames() : List<String>
}
abstract class Pet {
    name : String
    house : House
    makeNoise() : void
}

Cat --|> Pet
Dog --|> Pet
House *-- "*" Pet : lived  'opposite: house
Pet --> House : house  'opposite: lived
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

281864 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@3d9dc84d (name: addPet) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Adds a pet to the house if it doesn't already belong to a house and has a name.
Algorithm: 
  1. If the pet's name is null or empty, return false.
  2. If the pet already belongs to a house (including this one), return false.
  3. Add the pet to the 'lived' list.
  4. Set the pet's house to this house.
  5. Return true.
Input: pet - the Pet to add (must not be null).
Output: boolean - true if the pet was successfully added, false otherwise.
Pre-condition: pet is not null.
Post-condition: If successful, the pet is added to this house and its house reference is set to this., org.eclipse.emf.ecore.impl.EOperationImpl@73625632 (name: getPetCount) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Counts the total number of pets living in the house.
Algorithm: 
  1. Return the size of the 'lived' list.
Input: None.
Output: int - the number of pets in the house (non-negative).
Pre-condition: None.
Post-condition: The count of pets is returned., org.eclipse.emf.ecore.impl.EOperationImpl@676f70dc (name: getPetsByType) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary: Retrieves a list of pets of a specific type (e.g., "dog" or "cat") living in the house.
Algorithm: 
  1. Initialize an empty list result.
  2. For each pet in 'lived':
     a. If type is "dog" and pet is an instance of Dog, add to result.
     b. If type is "cat" and pet is an instance of Cat, add to result.
  3. Return result.
Input: type - String representing pet type ("dog" or "cat", case-sensitive).
Output: List<Pet> - list of pets of the specified type; empty if none.
Pre-condition: type is either "dog" or "cat".
Post-condition: A list of pets matching the specified type is returned., org.eclipse.emf.ecore.impl.EOperationImpl@54c2cfc9 (name: makeNoise) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Makes the pet produce its characteristic noise.
Algorithm: 
  1. If the pet is a Dog, output "Woof!".
  2. If the pet is a Cat, output "Meow!".
Input: None.
Output: None (side effect: prints noise to console).
Pre-condition: None.
Post-condition: The pet has made its noise., org.eclipse.emf.ecore.impl.EOperationImpl@761d3c20 (name: retrievePetNames) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary: Retrieves a list of names of all pets living in the house.
Algorithm: 
  1. Initialize an empty list of strings result.
  2. For each pet in 'lived':
     a. Add pet.name to result.
  3. Return result.
Input: None.
Output: List<String> - list of pet names; empty if no pets.
Pre-condition: None.
Post-condition: A list of pet names is returned., org.eclipse.emf.ecore.impl.EOperationImpl@2591477f (name: removePet) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Removes a specified pet from the house.
Algorithm: 
  1. If the pet is in the 'lived' list:
     a. Remove the pet from the list.
     b. Set the pet's house reference to null.
     c. Return true.
  2. Else, return false.
Input: pet - the Pet to remove (must not be null).
Output: boolean - true if the pet was removed, false otherwise.
Pre-condition: pet is not null.
Post-condition: If successful, the pet is removed from this house and its house reference is set to null.}
281866 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
281884 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../Pets/src-gen/edu/pets
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getLived <em>Lived</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Pet> lived;

  protected House()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Pet> getLived()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of names of all pets living in the house.
   * Algorithm: 
   *   1. Initialize an empty list of strings result.
   *   2. For each pet in 'lived':
   *      a. Add pet.name to result.
   *   3. Return result.
   * Input: None.
   * Output: List<String> - list of pet names; empty if no pets.
   * Pre-condition: None.
   * Post-condition: A list of pet names is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<String> retrievePetNames()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Adds a pet to the house if it doesn't already belong to a house and has a name.
   * Algorithm: 
   *   1. If the pet's name is null or empty, return false.
   *   2. If the pet already belongs to a house (including this one), return false.
   *   3. Add the pet to the 'lived' list.
   *   4. Set the pet's house to this house.
   *   5. Return true.
   * Input: pet - the Pet to add (must not be null).
   * Output: boolean - true if the pet was successfully added, false otherwise.
   * Pre-condition: pet is not null.
   * Post-condition: If successful, the pet is added to this house and its house reference is set to this.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean addPet(final Pet pet)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Removes a specified pet from the house.
   * Algorithm: 
   *   1. If the pet is in the 'lived' list:
   *      a. Remove the pet from the list.
   *      b. Set the pet's house reference to null.
   *      c. Return true.
   *   2. Else, return false.
   * Input: pet - the Pet to remove (must not be null).
   * Output: boolean - true if the pet was removed, false otherwise.
   * Pre-condition: pet is not null.
   * Post-condition: If successful, the pet is removed from this house and its house reference is set to null.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void removePet(final Pet pet)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of pets of a specific type (e.g., "dog" or "cat") living in the house.
   * Algorithm: 
   *   1. Initialize an empty list result.
   *   2. For each pet in 'lived':
   *      a. If type is "dog" and pet is an instance of Dog, add to result.
   *      b. If type is "cat" and pet is an instance of Cat, add to result.
   *   3. Return result.
   * Input: type - String representing pet type ("dog" or "cat", case-sensitive).
   * Output: List<Pet> - list of pets of the specified type; empty if none.
   * Pre-condition: type is either "dog" or "cat".
   * Post-condition: A list of pets matching the specified type is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<Pet> getPetsByType(final String type)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the total number of pets living in the house.
   * Algorithm: 
   *   1. Return the size of the 'lived' list.
   * Input: None.
   * Output: int - the number of pets in the house (non-negative).
   * Pre-condition: None.
   * Post-condition: The count of pets is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int getPetCount(final String type)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // House
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Pet` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Public methods: public void makeNoise()
  + Getter methods: public String getName(), public House getHouse()
  + Setter methods: public void setName(String newName), public void setHouse(House newHouse)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

283086 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - Cannot invoke "java.lang.Iterable.iterator()" because "iterable" is null
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getLived <em>Lived</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Pet> lived;

  protected House()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Pet> getLived()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of names of all pets living in the house.
   * Algorithm: 
   *   1. Initialize an empty list of strings result.
   *   2. For each pet in 'lived':
   *      a. Add pet.name to result.
   *   3. Return result.
   * Input: None.
   * Output: List<String> - list of pet names; empty if no pets.
   * Pre-condition: None.
   * Post-condition: A list of pet names is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<String> retrievePetNames()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Adds a pet to the house if it doesn't already belong to a house and has a name.
   * Algorithm: 
   *   1. If the pet's name is null or empty, return false.
   *   2. If the pet already belongs to a house (including this one), return false.
   *   3. Add the pet to the 'lived' list.
   *   4. Set the pet's house to this house.
   *   5. Return true.
   * Input: pet - the Pet to add (must not be null).
   * Output: boolean - true if the pet was successfully added, false otherwise.
   * Pre-condition: pet is not null.
   * Post-condition: If successful, the pet is added to this house and its house reference is set to this.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean addPet(final Pet pet)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Removes a specified pet from the house.
   * Algorithm: 
   *   1. If the pet is in the 'lived' list:
   *      a. Remove the pet from the list.
   *      b. Set the pet's house reference to null.
   *      c. Return true.
   *   2. Else, return false.
   * Input: pet - the Pet to remove (must not be null).
   * Output: boolean - true if the pet was removed, false otherwise.
   * Pre-condition: pet is not null.
   * Post-condition: If successful, the pet is removed from this house and its house reference is set to null.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void removePet(final Pet pet)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of pets of a specific type (e.g., "dog" or "cat") living in the house.
   * Algorithm: 
   *   1. Initialize an empty list result.
   *   2. For each pet in 'lived':
   *      a. If type is "dog" and pet is an instance of Dog, add to result.
   *      b. If type is "cat" and pet is an instance of Cat, add to result.
   *   3. Return result.
   * Input: type - String representing pet type ("dog" or "cat", case-sensitive).
   * Output: List<Pet> - list of pets of the specified type; empty if none.
   * Pre-condition: type is either "dog" or "cat".
   * Post-condition: A list of pets matching the specified type is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<Pet> getPetsByType(final String type)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the total number of pets living in the house.
   * Algorithm: 
   *   1. Return the size of the 'lived' list.
   * Input: None.
   * Output: int - the number of pets in the house (non-negative).
   * Pre-condition: None.
   * Post-condition: The count of pets is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int getPetCount(final String type)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // House
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Pet` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Public methods: public void makeNoise()
  + Getter methods: public String getName(), public House getHouse()
  + Setter methods: public void setName(String newName), public void setHouse(House newHouse)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getLived <em>Lived</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Pet> lived;

  protected House()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Pet> getLived()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of names of all pets living in the house.
   * Algorithm: 
   *   1. Initialize an empty list of strings result.
   *   2. For each pet in 'lived':
   *      a. Add pet.name to result.
   *   3. Return result.
   * Input: None.
   * Output: List<String> - list of pet names; empty if no pets.
   * Pre-condition: None.
   * Post-condition: A list of pet names is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> retrievePetNames()
  {
    EList<String> result = new BasicEList<String>();
    for (Pet pet : getLived()) {
      result.add(pet.getName());
    }
    return result;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Adds a pet to the house if it doesn't already belong to a house and has a name.
   * Algorithm: 
   *   1. If the pet's name is null or empty, return false.
   *   2. If the pet already belongs to a house (including this one), return false.
   *   3. Add the pet to the 'lived' list.
   *   4. Set the pet's house to this house.
   *   5. Return true.
   * Input: pet - the Pet to add (must not be null).
   * Output: boolean - true if the pet was successfully added, false otherwise.
   * Pre-condition: pet is not null.
   * Post-condition: If successful, the pet is added to this house and its house reference is set to this.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean addPet(final Pet pet)
  {
    if (pet == null) return false;
    
    String name = pet.getName();
    if (name == null || name.isEmpty()) {
      return false;
    }
    
    if (pet.getHouse() != null) {
      return false;
    }
    
    getLived().add(pet);
    pet.setHouse(this);
    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Removes a specified pet from the house.
   * Algorithm: 
   *   1. If the pet is in the 'lived' list:
   *      a. Remove the pet from the list.
   *      b. Set the pet's house reference to null.
   *      c. Return true.
   *   2. Else, return false.
   * Input: pet - the Pet to remove (must not be null).
   * Output: boolean - true if the pet was removed, false otherwise.
   * Pre-condition: pet is not null.
   * Post-condition: If successful, the pet is removed from this house and its house reference is set to null.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void removePet(final Pet pet)
  {
    if (pet == null) return;
    
    if (getLived().remove(pet)) {
      pet.setHouse(null);
    }
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of pets of a specific type (e.g., "dog" or "cat") living in the house.
   * Algorithm: 
   *   1. Initialize an empty list result.
   *   2. For each pet in 'lived':
   *      a. If type is "dog" and pet is an instance of Dog, add to result.
   *      b. If type is "cat" and pet is an instance of Cat, add to result.
   *   3. Return result.
   * Input: type - String representing pet type ("dog" or "cat", case-sensitive).
   * Output: List<Pet> - list of pets of the specified type; empty if none.
   * Pre-condition: type is either "dog" or "cat".
   * Post-condition: A list of pets matching the specified type is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Pet> getPetsByType(final String type)
  {
    EList<Pet> result = new BasicEList<Pet>();
    for (Pet pet : getLived()) {
      if ("dog".equals(type) && pet instanceof Dog) {
        result.add(pet);
      } else if ("cat".equals(type) && pet instanceof Cat) {
        result.add(pet);
      }
    }
    return result;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the total number of pets living in the house.
   * Algorithm: 
   *   1. Return the size of the 'lived' list.
   * Input: None.
   * Output: int - the number of pets in the house (non-negative).
   * Pre-condition: None.
   * Post-condition: The count of pets is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int getPetCount(final String type)
  {
    return getLived().size();
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // House
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public House getHouse()
  { ... /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { ... /* omitted */ }

  public void setHouse(House newHouse)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet produce its characteristic noise.
   * Algorithm: 
   *   1. If the pet is a Dog, output "Woof!".
   *   2. If the pet is a Cat, output "Meow!".
   * Input: None.
   * Output: None (side effect: prints noise to console).
   * Pre-condition: None.
   * Post-condition: The pet has made its noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void makeNoise()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `House` contains the following methods.
  + Instance creation: Use `PetsFactory.eINSTANCE.createHouse()`
  + Public methods: public EList<String> retrievePetNames(), public boolean addPet(final Pet pet), public void removePet(final Pet pet), public EList<Pet> getPetsByType(final String type), public int getPetCount(final String type)
  + Getter methods: public EList<Pet> getLived()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

319211 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - Cannot invoke "java.lang.Iterable.iterator()" because "iterable" is null
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public House getHouse()
  { ... /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { ... /* omitted */ }

  public void setHouse(House newHouse)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet produce its characteristic noise.
   * Algorithm: 
   *   1. If the pet is a Dog, output "Woof!".
   *   2. If the pet is a Cat, output "Meow!".
   * Input: None.
   * Output: None (side effect: prints noise to console).
   * Pre-condition: None.
   * Post-condition: The pet has made its noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void makeNoise()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `House` contains the following methods.
  + Instance creation: Use `PetsFactory.eINSTANCE.createHouse()`
  + Public methods: public EList<String> retrievePetNames(), public boolean addPet(final Pet pet), public void removePet(final Pet pet), public EList<Pet> getPetsByType(final String type), public int getPetCount(final String type)
  + Getter methods: public EList<Pet> getLived()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

326723 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - Cannot invoke "java.lang.Iterable.iterator()" because "iterable" is null
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public House getHouse()
  { ... /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { ... /* omitted */ }

  public void setHouse(House newHouse)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet produce its characteristic noise.
   * Algorithm: 
   *   1. If the pet is a Dog, output "Woof!".
   *   2. If the pet is a Cat, output "Meow!".
   * Input: None.
   * Output: None (side effect: prints noise to console).
   * Pre-condition: None.
   * Post-condition: The pet has made its noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void makeNoise()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `House` contains the following methods.
  + Instance creation: Use `PetsFactory.eINSTANCE.createHouse()`
  + Public methods: public EList<String> retrievePetNames(), public boolean addPet(final Pet pet), public void removePet(final Pet pet), public EList<Pet> getPetsByType(final String type), public int getPetCount(final String type)
  + Getter methods: public EList<Pet> getLived()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

327988 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - Cannot invoke "java.lang.Iterable.iterator()" because "iterable" is null
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public House getHouse()
  { ... /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { ... /* omitted */ }

  public void setHouse(House newHouse)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet produce its characteristic noise.
   * Algorithm: 
   *   1. If the pet is a Dog, output "Woof!".
   *   2. If the pet is a Cat, output "Meow!".
   * Input: None.
   * Output: None (side effect: prints noise to console).
   * Pre-condition: None.
   * Post-condition: The pet has made its noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void makeNoise()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `House` contains the following methods.
  + Instance creation: Use `PetsFactory.eINSTANCE.createHouse()`
  + Public methods: public EList<String> retrievePetNames(), public boolean addPet(final Pet pet), public void removePet(final Pet pet), public EList<Pet> getPetsByType(final String type), public int getPetCount(final String type)
  + Getter methods: public EList<Pet> getLived()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

328877 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - Cannot invoke "java.lang.Iterable.iterator()" because "iterable" is null
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public House getHouse()
  { ... /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { ... /* omitted */ }

  public void setHouse(House newHouse)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet produce its characteristic noise.
   * Algorithm: 
   *   1. If the pet is a Dog, output "Woof!".
   *   2. If the pet is a Cat, output "Meow!".
   * Input: None.
   * Output: None (side effect: prints noise to console).
   * Pre-condition: None.
   * Post-condition: The pet has made its noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void makeNoise()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `House` contains the following methods.
  + Instance creation: Use `PetsFactory.eINSTANCE.createHouse()`
  + Public methods: public EList<String> retrievePetNames(), public boolean addPet(final Pet pet), public void removePet(final Pet pet), public EList<Pet> getPetsByType(final String type), public int getPetCount(final String type)
  + Getter methods: public EList<Pet> getLived()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { }

  @Override
  protected EClass eStaticClass()
  {
    return PetsPackage.Literals.PET;
  }

  public String getName()
  {
    return name;
  }

  public void setName(String newName)
  {
    String oldName = name;
    name = newName;
    if (eNotificationRequired())
      eNotify(new ENotificationImpl(this, Notification.SET, PetsPackage.PET__NAME, oldName, name));
  }

  public House getHouse()
  {
    if (eContainerFeatureID() != PetsPackage.PET__HOUSE) return null;
    return (House)eInternalContainer();
  }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  {
    msgs = eBasicSetContainer((InternalEObject)newHouse, PetsPackage.PET__HOUSE, msgs);
    return msgs;
  }

  public void setHouse(House newHouse)
  {
    if (newHouse != eInternalContainer() || (eContainerFeatureID() != PetsPackage.PET__HOUSE && newHouse != null))
    {
      if (EcoreUtil.isAncestor(this, newHouse))
        throw new IllegalArgumentException("Recursive containment not allowed for " + toString());
      NotificationChain msgs = null;
      if (eInternalContainer() != null)
        msgs = eBasicRemoveFromContainer(msgs);
      if (newHouse != null)
        msgs = ((InternalEObject)newHouse).eInverseAdd(this, PetsPackage.HOUSE__LIVED, House.class, msgs);
      msgs = basicSetHouse(newHouse, msgs);
      if (msgs != null) msgs.dispatch();
    }
    else if (eNotificationRequired())
      eNotify(new ENotificationImpl(this, Notification.SET, PetsPackage.PET__HOUSE, newHouse, newHouse));
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet produce its characteristic noise.
   * Algorithm: 
   *   1. If the pet is a Dog, output "Woof!".
   *   2. If the pet is a Cat, output "Meow!".
   * Input: None.
   * Output: None (side effect: prints noise to console).
   * Pre-condition: None.
   * Post-condition: The pet has made its noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void makeNoise()
  {
    if (this instanceof Dog) {
      System.out.println("Woof!");
    } else if (this instanceof Cat) {
      System.out.println("Meow!");
    }
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  {
    switch (featureID)
    {
      case PetsPackage.PET__HOUSE:
        if (eInternalContainer() != null)
          msgs = eBasicRemoveFromContainer(msgs);
        return basicSetHouse((House)otherEnd, msgs);
    }
    return super.eInverseAdd(otherEnd, featureID, msgs);
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  {
    switch (featureID)
    {
      case PetsPackage.PET__HOUSE:
        return basicSetHouse(null, msgs);
    }
    return super.eInverseRemove(otherEnd, featureID, msgs);
  }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  {
    switch (eContainerFeatureID())
    {
      case PetsPackage.PET__HOUSE:
        return eInternalContainer().eInverseRemove(this, PetsPackage.HOUSE__LIVED, House.class, msgs);
    }
    return super.eBasicRemoveFromContainerFeature(msgs);
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  {
    switch (featureID)
    {
      case PetsPackage.PET__NAME:
        return getName();
      case PetsPackage.PET__HOUSE:
        return getHouse();
    }
    return super.eGet(featureID, resolve, coreType);
  }

  @Override
  public void eSet(int featureID, Object newValue)
  {
    switch (featureID)
    {
      case PetsPackage.PET__NAME:
        setName((String)newValue);
        return;
      case PetsPackage.PET__HOUSE:
        setHouse((House)newValue);
        return;
    }
    super.eSet(featureID, newValue);
  }

  @Override
  public void eUnset(int featureID)
  {
    switch (featureID)
    {
      case PetsPackage.PET__NAME:
        setName(NAME_EDEFAULT);
        return;
      case PetsPackage.PET__HOUSE:
        setHouse((House)null);
        return;
    }
    super.eUnset(featureID);
  }

  @Override
  public boolean eIsSet(int featureID)
  {
    switch (featureID)
    {
      case PetsPackage.PET__NAME:
        return NAME_EDEFAULT == null ? name != null : !NAME_EDEFAULT.equals(name);
      case PetsPackage.PET__HOUSE:
        return getHouse() != null;
    }
    return super.eIsSet(featureID);
  }

  @Override
  public String toString()
  {
    if (eIsProxy()) return super.toString();

    StringBuilder result = new StringBuilder(super.toString());
    result.append(" (name: ");
    result.append(name);
    result.append(')');
    return result.toString();
  }

} // Pet
382167 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../Pets/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../Pets/src-gen/edu/pets/
382344 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
382344 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
382344 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
382345 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
382345 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample5.mwe2 启动完成
正在拷贝 src-gen/edu/pets 到 qwen3-coder/pets5...
拷贝完成！

======================================
所有任务完成！
======================================

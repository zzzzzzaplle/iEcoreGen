Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.ipo;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Application</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.ipo.Application#getShare <em>Share</em>}</li>
 *   <li>{@link edu.ipo.Application#getAmountOfMoney <em>Amount Of Money</em>}</li>
 *   <li>{@link edu.ipo.Application#getStatus <em>Status</em>}</li>
 *   <li>{@link edu.ipo.Application#getCustomer <em>Customer</em>}</li>
 *   <li>{@link edu.ipo.Application#getEmails <em>Emails</em>}</li>
 *   <li>{@link edu.ipo.Application#getCompany <em>Company</em>}</li>
 *   <li>{@link edu.ipo.Application#getAllowance <em>Allowance</em>}</li>
 * </ul>
 *
 * @see edu.ipo.IpoPackage#getApplication()
 * @model kind="class"
 * @generated
 */
public class Application extends MinimalEObjectImpl.Container implements EObject
{
  protected static final int SHARE_EDEFAULT = 0;

  protected int share = SHARE_EDEFAULT;

  protected static final double AMOUNT_OF_MONEY_EDEFAULT = 0.0;

  protected double amountOfMoney = AMOUNT_OF_MONEY_EDEFAULT;

  protected static final ApplicationStatus STATUS_EDEFAULT = ApplicationStatus.PENDING;

  protected ApplicationStatus status = STATUS_EDEFAULT;

  protected EList<Email> emails;

  protected Company company;

  protected Document allowance;

  protected Application()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public int getShare()
  { ... /* omitted */ }

  public void setShare(int newShare)
  { ... /* omitted */ }

  public double getAmountOfMoney()
  { ... /* omitted */ }

  public void setAmountOfMoney(double newAmountOfMoney)
  { ... /* omitted */ }

  public ApplicationStatus getStatus()
  { ... /* omitted */ }

  public void setStatus(ApplicationStatus newStatus)
  { ... /* omitted */ }

  public Customer getCustomer()
  { ... /* omitted */ }

  public NotificationChain basicSetCustomer(Customer newCustomer, NotificationChain msgs)
  { ... /* omitted */ }

  public void setCustomer(Customer newCustomer)
  { ... /* omitted */ }

  public EList<Email> getEmails()
  { ... /* omitted */ }

  public Company getCompany()
  { ... /* omitted */ }

  public Company basicGetCompany()
  { ... /* omitted */ }

  public void setCompany(Company newCompany)
  { ... /* omitted */ }

  public Document getAllowance()
  { ... /* omitted */ }

  public Document basicGetAllowance()
  { ... /* omitted */ }

  public void setAllowance(Document newAllowance)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Approves the IPO application and sends confirmation emails to the customer and the company.
   * Algorithm:
   * 1. Verify that the customer is still eligible for IPOs.
   * 2. Set the application's status to APPROVAL.
   * 3. Send information emails to both the customer and the company.
   * 4. Return true if approval succeeds; otherwise, false.
   * Input: None
   * Output:
   * - boolean: True if the application is approved; otherwise, false.
   * Pre-condition:
   * - The customer must still be eligible to apply for IPOs.
   * - The application must be in PENDING status.
   * Post-condition:
   * - The application status is set to APPROVAL.
   * - Emails are sent to the customer and company.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean approve()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Rejects the application and immediately notifies the customer via email.
   * Algorithm:
   * 1. Set the application's status to REJECTED.
   * 2. Send a rejection email to the customer.
   * 3. Return true.
   * Input: None
   * Output:
   * - boolean: Always returns true to indicate rejection.
   * Pre-condition: None
   * Post-condition:
   * - The application's status is set to REJECTED.
   * - A rejection email is sent to the customer.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean reject()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Cancels the application (sets its status to REJECTED).
   * Algorithm:
   * 1. Set the application's status to REJECTED.
   * 2. Return true.
   * Input: None
   * Output:
   * - boolean: Always returns true to indicate cancellation.
   * Pre-condition: None
   * Post-condition:
   * - The application's status is set to REJECTED.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean cancel()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Sends detailed emails to both the customer and the company containing IPO application details.
   * Algorithm:
   * 1. Generate email content using customer and application data.
   * 2. Send email to customer.
   * 3. Send email to the company.
   * Input: None
   * Output: None
   * Pre-condition:
   * - The customer, company, share, and amount fields are populated.
   * Post-condition:
   * - Two emails are created and sent with detailed application information.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void sendEmailsToCustomerAndCompany()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Sends a rejection email to the customer with IPO application rejection details.
   * Algorithm:
   * 1. Generate rejection email content.
   * 2. Send email to the customer.
   * Input: None
   * Output: None
   * Pre-condition:
   * - The customer, company, share, and amount fields are populated.
   * Post-condition:
   * - An email is created and sent to the customer notifying them of rejection.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void sendRejectionEmail()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Application
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Customer` contains the following methods.
  + Instance creation: Use `IpoFactory.eINSTANCE.createCustomer()`
  + Public methods: public boolean createApplication(final Company company, final int shares, final double amount, final Document doc), public int getApplicationCount(), public double getApprovedTotalAmount(), public boolean cancelApplication(final String companyName)
  + Getter methods: public String getName(), public String getSurname(), public String getEmail(), public String getTelephone(), public boolean isCanApplyForIPO(), public EList<Application> getApplications()
  + Setter methods: public void setName(String newName), public void setSurname(String newSurname), public void setEmail(String newEmail), public void setTelephone(String newTelephone), public void setCanApplyForIPO(boolean newCanApplyForIPO)
- Class `Email` contains the following methods.
  + Instance creation: Use `IpoFactory.eINSTANCE.createEmail()`
  + Public methods: public String createEmailContent(final Company company, final int shares, final Customer customer, final double amount)
  + Getter methods: public String getReceiver(), public String getContent()
  + Setter methods: public void setReceiver(String newReceiver), public void setContent(String newContent)
- Class `Company` contains the following methods.
  + Instance creation: Use `IpoFactory.eINSTANCE.createCompany()`
  + Getter methods: public String getName(), public String getEmail()
  + Setter methods: public void setName(String newName), public void setEmail(String newEmail)
- Class `Document` contains the following methods.
  + Instance creation: Use `IpoFactory.eINSTANCE.createDocument()`

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.ipo;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Application</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.ipo.Application#getShare <em>Share</em>}</li>
 *   <li>{@link edu.ipo.Application#getAmountOfMoney <em>Amount Of Money</em>}</li>
 *   <li>{@link edu.ipo.Application#getStatus <em>Status</em>}</li>
 *   <li>{@link edu.ipo.Application#getCustomer <em>Customer</em>}</li>
 *   <li>{@link edu.ipo.Application#getEmails <em>Emails</em>}</li>
 *   <li>{@link edu.ipo.Application#getCompany <em>Company</em>}</li>
 *   <li>{@link edu.ipo.Application#getAllowance <em>Allowance</em>}</li>
 * </ul>
 *
 * @see edu.ipo.IpoPackage#getApplication()
 * @model kind="class"
 * @generated
 */
public class Application extends MinimalEObjectImpl.Container implements EObject
{
  protected static final int SHARE_EDEFAULT = 0;

  protected int share = SHARE_EDEFAULT;

  protected static final double AMOUNT_OF_MONEY_EDEFAULT = 0.0;

  protected double amountOfMoney = AMOUNT_OF_MONEY_EDEFAULT;

  protected static final ApplicationStatus STATUS_EDEFAULT = ApplicationStatus.PENDING;

  protected ApplicationStatus status = STATUS_EDEFAULT;

  protected EList<Email> emails;

  protected Company company;

  protected Document allowance;

  protected Application()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public int getShare()
  { ... /* omitted */ }

  public void setShare(int newShare)
  { ... /* omitted */ }

  public double getAmountOfMoney()
  { ... /* omitted */ }

  public void setAmountOfMoney(double newAmountOfMoney)
  { ... /* omitted */ }

  public ApplicationStatus getStatus()
  { ... /* omitted */ }

  public void setStatus(ApplicationStatus newStatus)
  { ... /* omitted */ }

  public Customer getCustomer()
  { ... /* omitted */ }

  public NotificationChain basicSetCustomer(Customer newCustomer, NotificationChain msgs)
  { ... /* omitted */ }

  public void setCustomer(Customer newCustomer)
  { ... /* omitted */ }

  public EList<Email> getEmails()
  { ... /* omitted */ }

  public Company getCompany()
  { ... /* omitted */ }

  public Company basicGetCompany()
  { ... /* omitted */ }

  public void setCompany(Company newCompany)
  { ... /* omitted */ }

  public Document getAllowance()
  { ... /* omitted */ }

  public Document basicGetAllowance()
  { ... /* omitted */ }

  public void setAllowance(Document newAllowance)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Approves the IPO application and sends confirmation emails to the customer and the company.
   * Algorithm:
   * 1. Verify that the customer is still eligible for IPOs.
   * 2. Set the application's status to APPROVAL.
   * 3. Send information emails to both the customer and the company.
   * 4. Return true if approval succeeds; otherwise, false.
   * Input: None
   * Output:
   * - boolean: True if the application is approved; otherwise, false.
   * Pre-condition:
   * - The customer must still be eligible to apply for IPOs.
   * - The application must be in PENDING status.
   * Post-condition:
   * - The application status is set to APPROVAL.
   * - Emails are sent to the customer and company.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean approve()
  {
    Customer customer = getCustomer();
    if (customer != null && customer.isCanApplyForIPO() && getStatus() == ApplicationStatus.PENDING) {
      setStatus(ApplicationStatus.APPROVAL);
      sendEmailsToCustomerAndCompany();
      return true;
    }
    return false;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Rejects the application and immediately notifies the customer via email.
   * Algorithm:
   * 1. Set the application's status to REJECTED.
   * 2. Send a rejection email to the customer.
   * 3. Return true.
   * Input: None
   * Output:
   * - boolean: Always returns true to indicate rejection.
   * Pre-condition: None
   * Post-condition:
   * - The application's status is set to REJECTED.
   * - A rejection email is sent to the customer.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean reject()
  {
    setStatus(ApplicationStatus.REJECTED);
    sendRejectionEmail();
    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Cancels the application (sets its status to REJECTED).
   * Algorithm:
   * 1. Set the application's status to REJECTED.
   * 2. Return true.
   * Input: None
   * Output:
   * - boolean: Always returns true to indicate cancellation.
   * Pre-condition: None
   * Post-condition:
   * - The application's status is set to REJECTED.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean cancel()
  {
    setStatus(ApplicationStatus.REJECTED);
    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Sends detailed emails to both the customer and the company containing IPO application details.
   * Algorithm:
   * 1. Generate email content using customer and application data.
   * 2. Send email to customer.
   * 3. Send email to the company.
   * Input: None
   * Output: None
   * Pre-condition:
   * - The customer, company, share, and amount fields are populated.
   * Post-condition:
   * - Two emails are created and sent with detailed application information.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void sendEmailsToCustomerAndCompany()
  {
    if (getCustomer() != null && getCompany() != null && getShare() > 0 && getAmountOfMoney() > 0) {
      Email customerEmail = IpoFactory.eINSTANCE.createEmail();
      Email companyEmail = IpoFactory.eINSTANCE.createEmail();
      
      String content = customerEmail.createEmailContent(getCompany(), getShare(), getCustomer(), getAmountOfMoney());
      
      customerEmail.setReceiver(getCustomer().getEmail());
      customerEmail.setContent(content);
      
      companyEmail.setReceiver(getCompany().getEmail());
      companyEmail.setContent(content);
      
      getEmails().add(customerEmail);
      getEmails().add(companyEmail);
    }
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Sends a rejection email to the customer with IPO application rejection details.
   * Algorithm:
   * 1. Generate rejection email content.
   * 2. Send email to the customer.
   * Input: None
   * Output: None
   * Pre-condition:
   * - The customer, company, share, and amount fields are populated.
   * Post-condition:
   * - An email is created and sent to the customer notifying them of rejection.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void sendRejectionEmail()
  {
    if (getCustomer() != null && getCompany() != null && getShare() > 0 && getAmountOfMoney() > 0) {
      Email rejectionEmail = IpoFactory.eINSTANCE.createEmail();
      String content = rejectionEmail.createEmailContent(getCompany(), getShare(), getCustomer(), getAmountOfMoney());
      rejectionEmail.setReceiver(getCustomer().getEmail());
      rejectionEmail.setContent("Your application has been rejected. Details: " + content);
      getEmails().add(rejectionEmail);
    }
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Application
390718 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../IPOApplication/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../IPOApplication/src-gen/edu/ipo/
390892 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
390893 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
390893 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
390893 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
390895 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample4.mwe2 启动完成
正在拷贝 src-gen/edu/ipo 到 qwen3-coder/ipo4...
拷贝完成！

======================================
正在启动 sample5.mwe2...
======================================
391195 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
391346 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project IPOApplication at 'file:/D:/EclipseWorkspace/IPOApplication/'
391352 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
391365 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@799c1c8
391365 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
391367 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
391368 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
Customer
+ Retail customers should be eligible for applying IPO.
+ Customers who will make IPO Applications must share their name, surname, email address, and telephone number information with the related company. 

Software System
+ When a customer applies IPO, he is required to upload legal allowance documentation. 
+ When the customer completes the application process successfully, the bank should send two information emails, one for the customer and another for the company. 
+ If the customer has many failed attempts, the bank should restrict the customer from the application process. If they would like to apply anyway, they should call the "call center" and request IPO application access.

Rules
+ Even though the customer completed the process successfully, the purchase is still being determined. Related companies always have a right to reject customers' applications. If a company rejects the customer, our system should inform the customer.
+ Email content should include below information:
 - Customer's name, surname, email address, telephone number
 - Applied company named
 - Number of shares that have been purchased
 - The amount of money that has been paid

Functional requirement:
+ "Create an IPO application". A retail customer begins an IPO application by supplying the target company, the number of shares (>0), the amount of money, and uploading the document(non-null). The system first checks that the customer is still eligible to apply for IPOs and has no approved application for the same company; only then is an application record created. It returns true on success; otherwise, false.

+ "Approve or reject an application". If the application is rejected, the bank immediately emails the customer a rejection notice. The bank approves a specific application after verifying that the customer current can apply for IPO. If the application is approved, the bank sends two information emails: one to the customer and one to the company. The operation returns true if on success; otherwise, false.

+ "Retrieve a customer's application-count summary". The customer can report how many IPO applications has filed in total, including approval and rejected applications. Applications that have not yet been reviewed by the bank are not included. It returns 0 if the customer has no recorded applications.

+ "Query total approval IPO applications amount for a customer". A customer may request an aggregate view of the customer's approved IPO purchases. Returns the sum of all approved application amounts.

+ "Cancel an pending application". Providing the specific company name, a customer can cancel an application that is neither approved nor rejected by the bank. The operation returns true if the cancellation succeeds, otherwise, false.
```

# Class Diagram
```plantuml
@startuml

title ipo Model

class Application {
    amountOfMoney : double
    share : int
    status : ApplicationStatus
    allowance : Document
    company : Company
    customer : Customer
    emails : List<Email>
    approve() : boolean
    cancel() : boolean
    reject() : boolean
    sendEmailsToCustomerAndCompany() : void
    sendRejectionEmail() : void
}
class Company {
    email : String
    name : String
}
class Customer {
    canApplyForIPO : boolean
    email : String
    name : String
    surname : String
    telephone : String
    applications : List<Application>
    cancelApplication(companyName : String) : boolean
    createApplication(company : Company, shares : int, amount : double, doc : Document) : boolean
    getApplicationCount() : int
    getApprovedTotalAmount() : double
}
class Document {
}
class Email {
    content : String
    receiver : String
    createEmailContent(company : Company, shares : int, customer : Customer, amount : double) : String
}
enum ApplicationStatus {
    PENDING
    APPROVAL
    REJECTED
}

Application --> Document : allowance
Application --> Company : company
Application --> Customer : customer  'opposite: applications
Application *-- "*" Email : emails
Customer *-- "*" Application : applications  'opposite: customer
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

446060 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@633f8efd (name: approve) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Approves the current application after verifying that the customer is still eligible for IPO.
Algorithm:
1. Check if the customer associated with this application is still eligible for IPO (canApplyForIPO == true).
2. If eligible:
   - Set application status to APPROVAL
   - Call sendEmailsToCustomerAndCompany()
   - Return true
3. Otherwise, return false.
Input: None
Output:
- boolean: true if application approved, otherwise false
Pre-condition: Application must be in PENDING status
Post-condition:
- Application status is set to APPROVAL
- Emails are sent to both customer and company upon approval, org.eclipse.emf.ecore.impl.EOperationImpl@39660d2 (name: cancelApplication) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Cancels a pending IPO application based on the given company name.
Algorithm:
1. Search through the customer's applications for one associated with the given company name and has a status of PENDING.
2. If such an application is found, remove it from the list.
3. Return true if cancellation succeeds; otherwise, return false.
Input:
- companyName (String): name of the company for which the application was made
Output:
- boolean: true if cancellation succeeded, otherwise false
Pre-condition: None
Post-condition: The matching pending application (if found) is removed from the list, org.eclipse.emf.ecore.impl.EOperationImpl@3e1c58c9 (name: createApplication) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Creates a new IPO application for the customer with the given company, number of shares, amount of money, and allowance document.
Algorithm:
1. Verify that the customer is eligible to apply for an IPO (canApplyForIPO == true).
2. Check that the customer does not already have an approved application for the same company.
3. Validate inputs:
   - shares > 0
   - amount > 0
   - doc is non-null
4. If all checks pass, create a new Application instance with status PENDING and add it to the customer's applications list.
5. Return true if the application was created; otherwise, return false.
Input:
- company (Company): the target company for the IPO application
- shares (int): the number of shares to apply for (> 0)
- amount (double): the total amount of money involved (> 0)
- doc (Document): the legal allowance documentation (non-null)
Output:
- boolean: true if the application was successfully created, otherwise false
Pre-condition:
- The customer must be eligible to apply for IPOs (canApplyForIPO == true)
Post-condition:
- A new Application object may be added to the customer's applications list with status PENDING, org.eclipse.emf.ecore.impl.EOperationImpl@539fe2b8 (name: cancel) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Cancels the application if it is still pending.
Algorithm:
1. If the application status is PENDING, set status to REJECTED.
2. Return true if cancellation succeeded; otherwise, return false.
Input: None
Output:
- boolean: true if successfully canceled, otherwise false
Pre-condition: None
Post-condition:
- If the operation returns true, the application status becomes REJECTED, org.eclipse.emf.ecore.impl.EOperationImpl@30012b46 (name: reject) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Rejects the pending application and sends a rejection email to the customer.
Algorithm:
1. If the application status is PENDING:
   - Set the status to REJECTED
   - Call sendRejectionEmail()
   - Return true
2. Otherwise, return false
Input: None
Output:
- boolean: true if rejection succeeded, otherwise false
Pre-condition: Application must be in PENDING status
Post-condition:
- Application status is set to REJECTED
- Rejection email is sent to the customer, org.eclipse.emf.ecore.impl.EOperationImpl@76225435 (name: createEmailContent) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Generates the content of an email containing IPO application details.
Algorithm:
1. Format a string including:
   - Customer name and surname
   - Customer email and phone
   - Company name
   - Number of shares
   - Amount paid
2. Return this formatted string.
Input:
- company (Company): The company involved in the IPO
- shares (int): The number of shares applied for
- customer (Customer): The customer who submitted the application
- amount (double): The amount of money involved
Output:
- String: formatted email content with all specified fields
Pre-condition: None
Post-condition: None, org.eclipse.emf.ecore.impl.EOperationImpl@3f3953c3 (name: getApprovedTotalAmount) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Computes the total amount of money from all approved IPO applications.
Algorithm:
1. Iterate over the customer's applications.
2. For each application with status APPROVAL, accumulate its amountOfMoney.
3. Return the total sum.
Input: None
Output:
- double: the sum of all approved application amounts, 0 if none
Pre-condition: None
Post-condition: None, org.eclipse.emf.ecore.impl.EOperationImpl@26c8a6b3 (name: getApplicationCount) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Retrieves the count of IPO applications that have been reviewed (approved or rejected).
Algorithm:
1. Iterate over all applications of the customer.
2. Count only those with status APPROVAL or REJECTED.
3. Return the count.
Input: None
Output:
- int: the number of reviewed applications (approved or rejected), 0 if none
Pre-condition: None
Post-condition: None, org.eclipse.emf.ecore.impl.EOperationImpl@5a04e7ef (name: sendRejectionEmail) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Sends a rejection notification email to the customer detailing the IPO application rejection.
Algorithm:
1. Generate an email body using Email.createEmailContent(), passing relevant parameters.
2. Set the receiver as the customer’s email address.
3. Add this email to the application's emails list.
Input: None
Output: None
Pre-condition: Application must be in REJECTED status
Post-condition:
- One Email object is created and added to the emails list, org.eclipse.emf.ecore.impl.EOperationImpl@45d3c1ce (name: sendEmailsToCustomerAndCompany) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Sends informational emails to both the customer and the company regarding a successful IPO application approval.
Algorithm:
1. Create two Email objects:
   - Email to customer: includes customer info, company name, shares, amount
   - Email to company: includes same fields
2. Use Email.createEmailContent() for generating content.
3. Add both emails to the application's emails list.
Input: None
Output: None
Pre-condition: Application must be in APPROVAL status
Post-condition:
- Two Email objects are created and added to the emails list}
446062 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
446094 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../IPOApplication/src-gen/edu/ipo
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.ipo;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Email</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.ipo.Email#getReceiver <em>Receiver</em>}</li>
 *   <li>{@link edu.ipo.Email#getContent <em>Content</em>}</li>
 * </ul>
 *
 * @see edu.ipo.IpoPackage#getEmail()
 * @model kind="class"
 * @generated
 */
public class Email extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String RECEIVER_EDEFAULT = null;

  protected String receiver = RECEIVER_EDEFAULT;

  protected static final String CONTENT_EDEFAULT = null;

  protected String content = CONTENT_EDEFAULT;

  protected Email()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getReceiver()
  { ... /* omitted */ }

  public void setReceiver(String newReceiver)
  { ... /* omitted */ }

  public String getContent()
  { ... /* omitted */ }

  public void setContent(String newContent)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Generates the content of an email containing IPO application details.
   * Algorithm:
   * 1. Format a string including:
   *    - Customer name and surname
   *    - Customer email and phone
   *    - Company name
   *    - Number of shares
   *    - Amount paid
   * 2. Return this formatted string.
   * Input:
   * - company (Company): The company involved in the IPO
   * - shares (int): The number of shares applied for
   * - customer (Customer): The customer who submitted the application
   * - amount (double): The amount of money involved
   * Output:
   * - String: formatted email content with all specified fields
   * Pre-condition: None
   * Post-condition: None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public String createEmailContent(final Company company, final int shares, final Customer customer, final double amount)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Email
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Company` contains the following methods.
  + Instance creation: Use `IpoFactory.eINSTANCE.createCompany()`
  + Getter methods: public String getName(), public String getEmail()
  + Setter methods: public void setName(String newName), public void setEmail(String newEmail)
- Class `Customer` contains the following methods.
  + Instance creation: Use `IpoFactory.eINSTANCE.createCustomer()`
  + Public methods: public boolean createApplication(final Company company, final int shares, final double amount, final Document doc), public int getApplicationCount(), public double getApprovedTotalAmount(), public boolean cancelApplication(final String companyName)
  + Getter methods: public String getName(), public String getSurname(), public String getEmail(), public String getTelephone(), public boolean isCanApplyForIPO(), public EList<Application> getApplications()
  + Setter methods: public void setName(String newName), public void setSurname(String newSurname), public void setEmail(String newEmail), public void setTelephone(String newTelephone), public void setCanApplyForIPO(boolean newCanApplyForIPO)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.ipo;

import org.eclipse.emf.common.notify.Notification;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Email</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.ipo.Email#getReceiver <em>Receiver</em>}</li>
 *   <li>{@link edu.ipo.Email#getContent <em>Content</em>}</li>
 * </ul>
 *
 * @see edu.ipo.IpoPackage#getEmail()
 * @model kind="class"
 * @generated
 */
public class Email extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String RECEIVER_EDEFAULT = null;

  protected String receiver = RECEIVER_EDEFAULT;

  protected static final String CONTENT_EDEFAULT = null;

  protected String content = CONTENT_EDEFAULT;

  protected Email()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getReceiver()
  { ... /* omitted */ }

  public void setReceiver(String newReceiver)
  { ... /* omitted */ }

  public String getContent()
  { ... /* omitted */ }

  public void setContent(String newContent)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Generates the content of an email containing IPO application details.
   * Algorithm:
   * 1. Format a string including:
   *    - Customer name and surname
   *    - Customer email and phone
   *    - Company name
   *    - Number of shares
   *    - Amount paid
   * 2. Return this formatted string.
   * Input:
   * - company (Company): The company involved in the IPO
   * - shares (int): The number of shares applied for
   * - customer (Customer): The customer who submitted the application
   * - amount (double): The amount of money involved
   * Output:
   * - String: formatted email content with all specified fields
   * Pre-condition: None
   * Post-condition: None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public String createEmailContent(final Company company, final int shares, final Customer customer, final double amount)
  {
    StringBuilder sb = new StringBuilder();
    sb.append("Customer Name: ").append(customer.getName()).append(" ").append(customer.getSurname()).append("\n");
    sb.append("Email: ").append(customer.getEmail()).append("\n");
    sb.append("Phone: ").append(customer.getTelephone()).append("\n");
    sb.append("Company: ").append(company.getName()).append("\n");
    sb.append("Shares Applied: ").append(shares).append("\n");
    sb.append("Amount Paid: ").append(amount);
    return sb.toString();
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Email
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.ipo;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Customer</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.ipo.Customer#getName <em>Name</em>}</li>
 *   <li>{@link edu.ipo.Customer#getSurname <em>Surname</em>}</li>
 *   <li>{@link edu.ipo.Customer#getEmail <em>Email</em>}</li>
 *   <li>{@link edu.ipo.Customer#getTelephone <em>Telephone</em>}</li>
 *   <li>{@link edu.ipo.Customer#isCanApplyForIPO <em>Can Apply For IPO</em>}</li>
 *   <li>{@link edu.ipo.Customer#getApplications <em>Applications</em>}</li>
 * </ul>
 *
 * @see edu.ipo.IpoPackage#getCustomer()
 * @model kind="class"
 * @generated
 */
public class Customer extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected static final String SURNAME_EDEFAULT = null;

  protected String surname = SURNAME_EDEFAULT;

  protected static final String EMAIL_EDEFAULT = null;

  protected String email = EMAIL_EDEFAULT;

  protected static final String TELEPHONE_EDEFAULT = null;

  protected String telephone = TELEPHONE_EDEFAULT;

  protected static final boolean CAN_APPLY_FOR_IPO_EDEFAULT = false;

  protected boolean canApplyForIPO = CAN_APPLY_FOR_IPO_EDEFAULT;

  protected EList<Application> applications;

  protected Customer()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public String getSurname()
  { ... /* omitted */ }

  public void setSurname(String newSurname)
  { ... /* omitted */ }

  public String getEmail()
  { ... /* omitted */ }

  public void setEmail(String newEmail)
  { ... /* omitted */ }

  public String getTelephone()
  { ... /* omitted */ }

  public void setTelephone(String newTelephone)
  { ... /* omitted */ }

  public boolean isCanApplyForIPO()
  { ... /* omitted */ }

  public void setCanApplyForIPO(boolean newCanApplyForIPO)
  { ... /* omitted */ }

  public EList<Application> getApplications()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Creates a new IPO application for the customer with the given company, number of shares, amount of money, and allowance document.
   * Algorithm:
   * 1. Verify that the customer is eligible to apply for an IPO (canApplyForIPO == true).
   * 2. Check that the customer does not already have an approved application for the same company.
   * 3. Validate inputs:
   *    - shares > 0
   *    - amount > 0
   *    - doc is non-null
   * 4. If all checks pass, create a new Application instance with status PENDING and add it to the customer's applications list.
   * 5. Return true if the application was created; otherwise, return false.
   * Input:
   * - company (Company): the target company for the IPO application
   * - shares (int): the number of shares to apply for (> 0)
   * - amount (double): the total amount of money involved (> 0)
   * - doc (Document): the legal allowance documentation (non-null)
   * Output:
   * - boolean: true if the application was successfully created, otherwise false
   * Pre-condition:
   * - The customer must be eligible to apply for IPOs (canApplyForIPO == true)
   * Post-condition:
   * - A new Application object may be added to the customer's applications list with status PENDING
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean createApplication(final Company company, final int shares, final double amount, final Document doc)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves the count of IPO applications that have been reviewed (approved or rejected).
   * Algorithm:
   * 1. Iterate over all applications of the customer.
   * 2. Count only those with status APPROVAL or REJECTED.
   * 3. Return the count.
   * Input: None
   * Output:
   * - int: the number of reviewed applications (approved or rejected), 0 if none
   * Pre-condition: None
   * Post-condition: None
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int getApplicationCount()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Computes the total amount of money from all approved IPO applications.
   * Algorithm:
   * 1. Iterate over the customer's applications.
   * 2. For each application with status APPROVAL, accumulate its amountOfMoney.
   * 3. Return the total sum.
   * Input: None
   * Output:
   * - double: the sum of all approved application amounts, 0 if none
   * Pre-condition: None
   * Post-condition: None
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public double getApprovedTotalAmount()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Cancels a pending IPO application based on the given company name.
   * Algorithm:
   * 1. Search through the customer's applications for one associated with the given company name and has a status of PENDING.
   * 2. If such an application is found, remove it from the list.
   * 3. Return true if cancellation succeeds; otherwise, return false.
   * Input:
   * - companyName (String): name of the company for which the application was made
   * Output:
   * - boolean: true if cancellation succeeded, otherwise false
   * Pre-condition: None
   * Post-condition: The matching pending application (if found) is removed from the list
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean cancelApplication(final String companyName)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Customer
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Application` contains the following methods.
  + Instance creation: Use `IpoFactory.eINSTANCE.createApplication()`
  + Public methods: public boolean approve(), public boolean reject(), public boolean cancel(), public void sendEmailsToCustomerAndCompany(), public void sendRejectionEmail()
  + Getter methods: public int getShare(), public double getAmountOfMoney(), public ApplicationStatus getStatus(), public Customer getCustomer(), public EList<Email> getEmails(), public Company getCompany(), public Document getAllowance()
  + Setter methods: public void setShare(int newShare), public void setAmountOfMoney(double newAmountOfMoney), public void setStatus(ApplicationStatus newStatus), public void setCustomer(Customer newCustomer), public void setCompany(Company newCompany), public void setAllowance(Document newAllowance)
- Class `Company` contains the following methods.
  + Instance creation: Use `IpoFactory.eINSTANCE.createCompany()`
  + Getter methods: public String getName(), public String getEmail()
  + Setter methods: public void setName(String newName), public void setEmail(String newEmail)
- Class `Document` contains the following methods.
  + Instance creation: Use `IpoFactory.eINSTANCE.createDocument()`

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.ipo;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Customer</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.ipo.Customer#getName <em>Name</em>}</li>
 *   <li>{@link edu.ipo.Customer#getSurname <em>Surname</em>}</li>
 *   <li>{@link edu.ipo.Customer#getEmail <em>Email</em>}</li>
 *   <li>{@link edu.ipo.Customer#getTelephone <em>Telephone</em>}</li>
 *   <li>{@link edu.ipo.Customer#isCanApplyForIPO <em>Can Apply For IPO</em>}</li>
 *   <li>{@link edu.ipo.Customer#getApplications <em>Applications</em>}</li>
 * </ul>
 *
 * @see edu.ipo.IpoPackage#getCustomer()
 * @model kind="class"
 * @generated
 */
public class Customer extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected static final String SURNAME_EDEFAULT = null;

  protected String surname = SURNAME_EDEFAULT;

  protected static final String EMAIL_EDEFAULT = null;

  protected String email = EMAIL_EDEFAULT;

  protected static final String TELEPHONE_EDEFAULT = null;

  protected String telephone = TELEPHONE_EDEFAULT;

  protected static final boolean CAN_APPLY_FOR_IPO_EDEFAULT = false;

  protected boolean canApplyForIPO = CAN_APPLY_FOR_IPO_EDEFAULT;

  protected EList<Application> applications;

  protected Customer()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public String getSurname()
  { ... /* omitted */ }

  public void setSurname(String newSurname)
  { ... /* omitted */ }

  public String getEmail()
  { ... /* omitted */ }

  public void setEmail(String newEmail)
  { ... /* omitted */ }

  public String getTelephone()
  { ... /* omitted */ }

  public void setTelephone(String newTelephone)
  { ... /* omitted */ }

  public boolean isCanApplyForIPO()
  { ... /* omitted */ }

  public void setCanApplyForIPO(boolean newCanApplyForIPO)
  { ... /* omitted */ }

  public EList<Application> getApplications()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Creates a new IPO application for the customer with the given company, number of shares, amount of money, and allowance document.
   * Algorithm:
   * 1. Verify that the customer is eligible to apply for an IPO (canApplyForIPO == true).
   * 2. Check that the customer does not already have an approved application for the same company.
   * 3. Validate inputs:
   *    - shares > 0
   *    - amount > 0
   *    - doc is non-null
   * 4. If all checks pass, create a new Application instance with status PENDING and add it to the customer's applications list.
   * 5. Return true if the application was created; otherwise, return false.
   * Input:
   * - company (Company): the target company for the IPO application
   * - shares (int): the number of shares to apply for (> 0)
   * - amount (double): the total amount of money involved (> 0)
   * - doc (Document): the legal allowance documentation (non-null)
   * Output:
   * - boolean: true if the application was successfully created, otherwise false
   * Pre-condition:
   * - The customer must be eligible to apply for IPOs (canApplyForIPO == true)
   * Post-condition:
   * - A new Application object may be added to the customer's applications list with status PENDING
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean createApplication(final Company company, final int shares, final double amount, final Document doc)
  {
    // Step 1: Verify that the customer is eligible to apply for an IPO
    if (!isCanApplyForIPO()) {
      return false;
    }

    // Step 2: Check that the customer does not already have an approved application for the same company
    for (Application app : getApplications()) {
      if (app.getCompany() == company && app.getStatus() == ApplicationStatus.APPROVAL) {
        return false;
      }
    }

    // Step 3: Validate inputs
    if (shares <= 0 || amount <= 0 || doc == null) {
      return false;
    }

    // Step 4: Create a new Application instance with status PENDING
    Application newApp = IpoFactory.eINSTANCE.createApplication();
    newApp.setCompany(company);
    newApp.setShare(shares);
    newApp.setAmountOfMoney(amount);
    newApp.setAllowance(doc);
    newApp.setStatus(ApplicationStatus.PENDING);
    newApp.setCustomer(this);

    // Add it to the customer's applications list
    getApplications().add(newApp);

    // Step 5: Return true if the application was created
    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves the count of IPO applications that have been reviewed (approved or rejected).
   * Algorithm:
   * 1. Iterate over all applications of the customer.
   * 2. Count only those with status APPROVAL or REJECTED.
   * 3. Return the count.
   * Input: None
   * Output:
   * - int: the number of reviewed applications (approved or rejected), 0 if none
   * Pre-condition: None
   * Post-condition: None
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int getApplicationCount()
  {
    int count = 0;
    for (Application app : getApplications()) {
      if (app.getStatus() == ApplicationStatus.APPROVAL || app.getStatus() == ApplicationStatus.REJECTED) {
        count++;
      }
    }
    return count;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Computes the total amount of money from all approved IPO applications.
   * Algorithm:
   * 1. Iterate over the customer's applications.
   * 2. For each application with status APPROVAL, accumulate its amountOfMoney.
   * 3. Return the total sum.
   * Input: None
   * Output:
   * - double: the sum of all approved application amounts, 0 if none
   * Pre-condition: None
   * Post-condition: None
   * <!-- end-model-doc -->
   * @model kind="operation"
   *        annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public double getApprovedTotalAmount()
  {
    double total = 0.0;
    for (Application app : getApplications()) {
      if (app.getStatus() == ApplicationStatus.APPROVAL) {
        total += app.getAmountOfMoney();
      }
    }
    return total;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Cancels a pending IPO application based on the given company name.
   * Algorithm:
   * 1. Search through the customer's applications for one associated with the given company name and has a status of PENDING.
   * 2. If such an application is found, remove it from the list.
   * 3. Return true if cancellation succeeds; otherwise, return false.
   * Input:
   * - companyName (String): name of the company for which the application was made
   * Output:
   * - boolean: true if cancellation succeeded, otherwise false
   * Pre-condition: None
   * Post-condition: The matching pending application (if found) is removed from the list
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean cancelApplication(final String companyName)
  {
    EList<Application> apps = getApplications();
    for (int i = 0; i < apps.size(); i++) {
      Application app = apps.get(i);
      if (app.getStatus() == ApplicationStatus.PENDING && 
          app.getCompany() != null && 
          companyName.equals(app.getCompany().getName())) {
        apps.remove(i);
        return true;
      }
    }
    return false;
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Customer
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.ipo;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Application</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.ipo.Application#getShare <em>Share</em>}</li>
 *   <li>{@link edu.ipo.Application#getAmountOfMoney <em>Amount Of Money</em>}</li>
 *   <li>{@link edu.ipo.Application#getStatus <em>Status</em>}</li>
 *   <li>{@link edu.ipo.Application#getCustomer <em>Customer</em>}</li>
 *   <li>{@link edu.ipo.Application#getEmails <em>Emails</em>}</li>
 *   <li>{@link edu.ipo.Application#getCompany <em>Company</em>}</li>
 *   <li>{@link edu.ipo.Application#getAllowance <em>Allowance</em>}</li>
 * </ul>
 *
 * @see edu.ipo.IpoPackage#getApplication()
 * @model kind="class"
 * @generated
 */
public class Application extends MinimalEObjectImpl.Container implements EObject
{
  protected static final int SHARE_EDEFAULT = 0;

  protected int share = SHARE_EDEFAULT;

  protected static final double AMOUNT_OF_MONEY_EDEFAULT = 0.0;

  protected double amountOfMoney = AMOUNT_OF_MONEY_EDEFAULT;

  protected static final ApplicationStatus STATUS_EDEFAULT = ApplicationStatus.PENDING;

  protected ApplicationStatus status = STATUS_EDEFAULT;

  protected EList<Email> emails;

  protected Company company;

  protected Document allowance;

  protected Application()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public int getShare()
  { ... /* omitted */ }

  public void setShare(int newShare)
  { ... /* omitted */ }

  public double getAmountOfMoney()
  { ... /* omitted */ }

  public void setAmountOfMoney(double newAmountOfMoney)
  { ... /* omitted */ }

  public ApplicationStatus getStatus()
  { ... /* omitted */ }

  public void setStatus(ApplicationStatus newStatus)
  { ... /* omitted */ }

  public Customer getCustomer()
  { ... /* omitted */ }

  public NotificationChain basicSetCustomer(Customer newCustomer, NotificationChain msgs)
  { ... /* omitted */ }

  public void setCustomer(Customer newCustomer)
  { ... /* omitted */ }

  public EList<Email> getEmails()
  { ... /* omitted */ }

  public Company getCompany()
  { ... /* omitted */ }

  public Company basicGetCompany()
  { ... /* omitted */ }

  public void setCompany(Company newCompany)
  { ... /* omitted */ }

  public Document getAllowance()
  { ... /* omitted */ }

  public Document basicGetAllowance()
  { ... /* omitted */ }

  public void setAllowance(Document newAllowance)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Approves the current application after verifying that the customer is still eligible for IPO.
   * Algorithm:
   * 1. Check if the customer associated with this application is still eligible for IPO (canApplyForIPO == true).
   * 2. If eligible:
   *    - Set application status to APPROVAL
   *    - Call sendEmailsToCustomerAndCompany()
   *    - Return true
   * 3. Otherwise, return false.
   * Input: None
   * Output:
   * - boolean: true if application approved, otherwise false
   * Pre-condition: Application must be in PENDING status
   * Post-condition:
   * - Application status is set to APPROVAL
   * - Emails are sent to both customer and company upon approval
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean approve()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Rejects the pending application and sends a rejection email to the customer.
   * Algorithm:
   * 1. If the application status is PENDING:
   *    - Set the status to REJECTED
   *    - Call sendRejectionEmail()
   *    - Return true
   * 2. Otherwise, return false
   * Input: None
   * Output:
   * - boolean: true if rejection succeeded, otherwise false
   * Pre-condition: Application must be in PENDING status
   * Post-condition:
   * - Application status is set to REJECTED
   * - Rejection email is sent to the customer
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean reject()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Cancels the application if it is still pending.
   * Algorithm:
   * 1. If the application status is PENDING, set status to REJECTED.
   * 2. Return true if cancellation succeeded; otherwise, return false.
   * Input: None
   * Output:
   * - boolean: true if successfully canceled, otherwise false
   * Pre-condition: None
   * Post-condition:
   * - If the operation returns true, the application status becomes REJECTED
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean cancel()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Sends informational emails to both the customer and the company regarding a successful IPO application approval.
   * Algorithm:
   * 1. Create two Email objects:
   *    - Email to customer: includes customer info, company name, shares, amount
   *    - Email to company: includes same fields
   * 2. Use Email.createEmailContent() for generating content.
   * 3. Add both emails to the application's emails list.
   * Input: None
   * Output: None
   * Pre-condition: Application must be in APPROVAL status
   * Post-condition:
   * - Two Email objects are created and added to the emails list
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void sendEmailsToCustomerAndCompany()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Sends a rejection notification email to the customer detailing the IPO application rejection.
   * Algorithm:
   * 1. Generate an email body using Email.createEmailContent(), passing relevant parameters.
   * 2. Set the receiver as the customer’s email address.
   * 3. Add this email to the application's emails list.
   * Input: None
   * Output: None
   * Pre-condition: Application must be in REJECTED status
   * Post-condition:
   * - One Email object is created and added to the emails list
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void sendRejectionEmail()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Application
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Customer` contains the following methods.
  + Instance creation: Use `IpoFactory.eINSTANCE.createCustomer()`
  + Public methods: public boolean createApplication(final Company company, final int shares, final double amount, final Document doc), public int getApplicationCount(), public double getApprovedTotalAmount(), public boolean cancelApplication(final String companyName)
  + Getter methods: public String getName(), public String getSurname(), public String getEmail(), public String getTelephone(), public boolean isCanApplyForIPO(), public EList<Application> getApplications()
  + Setter methods: public void setName(String newName), public void setSurname(String newSurname), public void setEmail(String newEmail), public void setTelephone(String newTelephone), public void setCanApplyForIPO(boolean newCanApplyForIPO)
- Class `Email` contains the following methods.
  + Instance creation: Use `IpoFactory.eINSTANCE.createEmail()`
  + Public methods: public String createEmailContent(final Company company, final int shares, final Customer customer, final double amount)
  + Getter methods: public String getReceiver(), public String getContent()
  + Setter methods: public void setReceiver(String newReceiver), public void setContent(String newContent)
- Class `Company` contains the following methods.
  + Instance creation: Use `IpoFactory.eINSTANCE.createCompany()`
  + Getter methods: public String getName(), public String getEmail()
  + Setter methods: public void setName(String newName), public void setEmail(String newEmail)
- Class `Document` contains the following methods.
  + Instance creation: Use `IpoFactory.eINSTANCE.createDocument()`

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.ipo;

import java.util.Collection;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentEList;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Application</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.ipo.Application#getShare <em>Share</em>}</li>
 *   <li>{@link edu.ipo.Application#getAmountOfMoney <em>Amount Of Money</em>}</li>
 *   <li>{@link edu.ipo.Application#getStatus <em>Status</em>}</li>
 *   <li>{@link edu.ipo.Application#getCustomer <em>Customer</em>}</li>
 *   <li>{@link edu.ipo.Application#getEmails <em>Emails</em>}</li>
 *   <li>{@link edu.ipo.Application#getCompany <em>Company</em>}</li>
 *   <li>{@link edu.ipo.Application#getAllowance <em>Allowance</em>}</li>
 * </ul>
 *
 * @see edu.ipo.IpoPackage#getApplication()
 * @model kind="class"
 * @generated
 */
public class Application extends MinimalEObjectImpl.Container implements EObject
{
  protected static final int SHARE_EDEFAULT = 0;

  protected int share = SHARE_EDEFAULT;

  protected static final double AMOUNT_OF_MONEY_EDEFAULT = 0.0;

  protected double amountOfMoney = AMOUNT_OF_MONEY_EDEFAULT;

  protected static final ApplicationStatus STATUS_EDEFAULT = ApplicationStatus.PENDING;

  protected ApplicationStatus status = STATUS_EDEFAULT;

  protected EList<Email> emails;

  protected Company company;

  protected Document allowance;

  protected Application()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public int getShare()
  { ... /* omitted */ }

  public void setShare(int newShare)
  { ... /* omitted */ }

  public double getAmountOfMoney()
  { ... /* omitted */ }

  public void setAmountOfMoney(double newAmountOfMoney)
  { ... /* omitted */ }

  public ApplicationStatus getStatus()
  { ... /* omitted */ }

  public void setStatus(ApplicationStatus newStatus)
  { ... /* omitted */ }

  public Customer getCustomer()
  { ... /* omitted */ }

  public NotificationChain basicSetCustomer(Customer newCustomer, NotificationChain msgs)
  { ... /* omitted */ }

  public void setCustomer(Customer newCustomer)
  { ... /* omitted */ }

  public EList<Email> getEmails()
  { ... /* omitted */ }

  public Company getCompany()
  { ... /* omitted */ }

  public Company basicGetCompany()
  { ... /* omitted */ }

  public void setCompany(Company newCompany)
  { ... /* omitted */ }

  public Document getAllowance()
  { ... /* omitted */ }

  public Document basicGetAllowance()
  { ... /* omitted */ }

  public void setAllowance(Document newAllowance)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Approves the current application after verifying that the customer is still eligible for IPO.
   * Algorithm:
   * 1. Check if the customer associated with this application is still eligible for IPO (canApplyForIPO == true).
   * 2. If eligible:
   *    - Set application status to APPROVAL
   *    - Call sendEmailsToCustomerAndCompany()
   *    - Return true
   * 3. Otherwise, return false.
   * Input: None
   * Output:
   * - boolean: true if application approved, otherwise false
   * Pre-condition: Application must be in PENDING status
   * Post-condition:
   * - Application status is set to APPROVAL
   * - Emails are sent to both customer and company upon approval
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean approve()
  {
    if (getStatus() != ApplicationStatus.PENDING) {
      return false;
    }
    
    Customer customer = getCustomer();
    if (customer != null && customer.isCanApplyForIPO()) {
      setStatus(ApplicationStatus.APPROVAL);
      sendEmailsToCustomerAndCompany();
      return true;
    }
    return false;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Rejects the pending application and sends a rejection email to the customer.
   * Algorithm:
   * 1. If the application status is PENDING:
   *    - Set the status to REJECTED
   *    - Call sendRejectionEmail()
   *    - Return true
   * 2. Otherwise, return false
   * Input: None
   * Output:
   * - boolean: true if rejection succeeded, otherwise false
   * Pre-condition: Application must be in PENDING status
   * Post-condition:
   * - Application status is set to REJECTED
   * - Rejection email is sent to the customer
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean reject()
  {
    if (getStatus() != ApplicationStatus.PENDING) {
      return false;
    }
    
    setStatus(ApplicationStatus.REJECTED);
    sendRejectionEmail();
    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Cancels the application if it is still pending.
   * Algorithm:
   * 1. If the application status is PENDING, set status to REJECTED.
   * 2. Return true if cancellation succeeded; otherwise, return false.
   * Input: None
   * Output:
   * - boolean: true if successfully canceled, otherwise false
   * Pre-condition: None
   * Post-condition:
   * - If the operation returns true, the application status becomes REJECTED
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean cancel()
  {
    if (getStatus() == ApplicationStatus.PENDING) {
      setStatus(ApplicationStatus.REJECTED);
      return true;
    }
    return false;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Sends informational emails to both the customer and the company regarding a successful IPO application approval.
   * Algorithm:
   * 1. Create two Email objects:
   *    - Email to customer: includes customer info, company name, shares, amount
   *    - Email to company: includes same fields
   * 2. Use Email.createEmailContent() for generating content.
   * 3. Add both emails to the application's emails list.
   * Input: None
   * Output: None
   * Pre-condition: Application must be in APPROVAL status
   * Post-condition:
   * - Two Email objects are created and added to the emails list
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void sendEmailsToCustomerAndCompany()
  {
    if (getStatus() != ApplicationStatus.APPROVAL) {
      return;
    }

    Customer customer = getCustomer();
    Company comp = getCompany();
    
    if (customer == null || comp == null) {
      return;
    }

    // Create email to customer
    Email emailToCustomer = IpoFactory.eINSTANCE.createEmail();
    String contentToCustomer = emailToCustomer.createEmailContent(comp, getShare(), customer, getAmountOfMoney());
    emailToCustomer.setReceiver(customer.getEmail());
    emailToCustomer.setContent(contentToCustomer);

    // Create email to company
    Email emailToCompany = IpoFactory.eINSTANCE.createEmail();
    String contentToCompany = emailToCompany.createEmailContent(comp, getShare(), customer, getAmountOfMoney());
    emailToCompany.setReceiver(comp.getEmail());
    emailToCompany.setContent(contentToCompany);

    // Add emails to the list
    getEmails().add(emailToCustomer);
    getEmails().add(emailToCompany);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Sends a rejection notification email to the customer detailing the IPO application rejection.
   * Algorithm:
   * 1. Generate an email body using Email.createEmailContent(), passing relevant parameters.
   * 2. Set the receiver as the customer’s email address.
   * 3. Add this email to the application's emails list.
   * Input: None
   * Output: None
   * Pre-condition: Application must be in REJECTED status
   * Post-condition:
   * - One Email object is created and added to the emails list
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void sendRejectionEmail()
  {
    if (getStatus() != ApplicationStatus.REJECTED) {
      return;
    }

    Customer customer = getCustomer();
    Company comp = getCompany();
    
    if (customer == null || comp == null) {
      return;
    }

    Email rejectionEmail = IpoFactory.eINSTANCE.createEmail();
    String content = rejectionEmail.createEmailContent(comp, getShare(), customer, getAmountOfMoney());
    rejectionEmail.setReceiver(customer.getEmail());
    rejectionEmail.setContent(content);

    getEmails().add(rejectionEmail);
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Application
525868 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../IPOApplication/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../IPOApplication/src-gen/edu/ipo/
526007 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
526007 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - ----------
1. WARNING in D:\EclipseWorkspace\IPOApplication\src-gen\edu\ipo\Customer.java (at line 22)
	import org.eclipse.emf.common.util.BasicEList;
	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The import org.eclipse.emf.common.util.BasicEList is never used
----------
1 problem (1 warning)

526007 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
526007 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
526008 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample5.mwe2 启动完成
正在拷贝 src-gen/edu/ipo 到 qwen3-coder/ipo5...
拷贝完成！

======================================
所有任务完成！
======================================

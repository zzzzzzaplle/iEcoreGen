   *      b. Else if the pet is an instance of Cat and type equals "cat", add it to the result list.
   *   3. Return the result list.
   * Input:
   *   - type: A case-sensitive string representing the pet type. Expected values are "dog" or "cat".
   * Output:
   *   - List<Pet>: A list of pets matching the given type. Returns an empty list if no matches are found.
   * Pre-condition: None
   * Post-condition: A list of pets of the specified type is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<Pet> getPetsByType(final String type)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the total number of pets currently living in the house.
   * Algorithm:
   *   1. Return the size of the pets list.
   * Input: None
   * Output:
   *   - int: The number of pets in the house. Returns 0 if there are no pets.
   * Pre-condition: None
   * Post-condition: The count of pets in the house is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int getPetCount(final String type)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // House
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Pet` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Public methods: public void makeNoise()
  + Getter methods: public String getName(), public House getHouse()
  + Setter methods: public void setName(String newName), public void setHouse(House newHouse)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getPets <em>Pets</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Pet> pets;

  protected House()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Pet> getPets()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of names of all pets currently living in the house.
   * Algorithm:
   *   1. Create an empty list of strings for pet names.
   *   2. For each pet in the pets list:
   *      a. Add the pet's name to the list.
   *   3. Return the list of names.
   * Input: None
   * Output:
   *   - List<String>: A list containing the names of all pets. Returns an empty list if there are no pets.
   * Pre-condition: None
   * Post-condition: A list of pet names is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> retrievePetNames()
  {
    EList<String> petNames = new BasicEList<String>();
    for (Pet pet : getPets()) {
      petNames.add(pet.getName());
    }
    return petNames;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Adds a pet to the house if it does not already belong to any house and has a valid name.
   * Algorithm:
   *   1. If the pet's name is null or empty, return false.
   *   2. If the pet already belongs to a house (including this one), return false.
   *   3. Add the pet to the house's pets list.
   *   4. Set the pet's house reference to this house.
   *   5. Return true.
   * Input:
   *   - pet: The Pet object to be added. Must be a non-null instance of Pet.
   * Output:
   *   - boolean: True if the pet was successfully added; false otherwise.
   * Pre-condition: The pet must not belong to any house and must have a non-empty name.
   * Post-condition: If successful, the pet is added to this house's list of pets and its house reference is set to this house.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean addPet(final Pet pet)
  {
    if (pet == null || pet.getName() == null || pet.getName().isEmpty()) {
      return false;
    }
    if (pet.getHouse() != null) {
      return false;
    }
    getPets().add(pet);
    pet.setHouse(this);
    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Removes a specified pet from the house if it currently resides in this house.
   * Algorithm:
   *   1. If the pet is null, return false.
   *   2. If the pet is not in the pets list, return false.
   *   3. Remove the pet from the pets list.
   *   4. Set the pet's house reference to null.
   *   5. Return true.
   * Input:
   *   - pet: The Pet object to be removed. Must be a non-null instance of Pet.
   * Output:
   *   - boolean: True if the pet was successfully removed; false otherwise.
   * Pre-condition: The pet must exist and belong to this house.
   * Post-condition: If successful, the pet is removed from this house's list and its house reference is set to null.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void removePet(final Pet pet)
  {
    if (pet == null || !getPets().remove(pet)) {
      return;
    }
    pet.setHouse(null);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of pets of a specific type (e.g., "dog" or "cat") living in the house.
   * Algorithm:
   *   1. Create an empty list to store results.
   *   2. For each pet in the pets list:
   *      a. If the pet is an instance of Dog and type equals "dog", add it to the result list.
   *      b. Else if the pet is an instance of Cat and type equals "cat", add it to the result list.
   *   3. Return the result list.
   * Input:
   *   - type: A case-sensitive string representing the pet type. Expected values are "dog" or "cat".
   * Output:
   *   - List<Pet>: A list of pets matching the given type. Returns an empty list if no matches are found.
   * Pre-condition: None
   * Post-condition: A list of pets of the specified type is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Pet> getPetsByType(final String type)
  {
    EList<Pet> result = new BasicEList<Pet>();
    for (Pet pet : getPets()) {
      if (("dog".equals(type) && pet instanceof Dog) ||
          ("cat".equals(type) && pet instanceof Cat)) {
        result.add(pet);
      }
    }
    return result;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the total number of pets currently living in the house.
   * Algorithm:
   *   1. Return the size of the pets list.
   * Input: None
   * Output:
   *   - int: The number of pets in the house. Returns 0 if there are no pets.
   * Pre-condition: None
   * Post-condition: The count of pets in the house is returned.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int getPetCount(final String type)
  {
    return getPets().size();
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // House
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public House getHouse()
  { ... /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { ... /* omitted */ }

  public void setHouse(House newHouse)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet produce its characteristic sound.
   * Algorithm: 
   *   1. If the pet is a Dog, output "Woof!".
   *   2. If the pet is a Cat, output "Meow!".
   * Input: None
   * Output: None
   * Pre-condition: None
   * Post-condition: The pet has made a noise consistent with its type.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void makeNoise()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `House` contains the following methods.
  + Instance creation: Use `PetsFactory.eINSTANCE.createHouse()`
  + Public methods: public EList<String> retrievePetNames(), public boolean addPet(final Pet pet), public void removePet(final Pet pet), public EList<Pet> getPetsByType(final String type), public int getPetCount(final String type)
  + Getter methods: public EList<Pet> getPets()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public House getHouse()
  { ... /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { ... /* omitted */ }

  public void setHouse(House newHouse)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet produce its characteristic sound.
   * Algorithm: 
   *   1. If the pet is a Dog, output "Woof!".
   *   2. If the pet is a Cat, output "Meow!".
   * Input: None
   * Output: None
   * Pre-condition: None
   * Post-condition: The pet has made a noise consistent with its type.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void makeNoise()
  {
    if (this instanceof Dog) {
      System.out.println("Woof!");
    } else if (this instanceof Cat) {
      System.out.println("Meow!");
    }
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
292709 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../Pets/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../Pets/src-gen/edu/pets/
292847 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
292847 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
292847 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
292847 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
292848 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample3.mwe2 启动完成
正在拷贝 src-gen/edu/pets 到 qwen3-coder/pets3...
拷贝完成！

======================================
正在启动 sample4.mwe2...
======================================
293029 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
293101 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project Pets at 'file:/D:/EclipseWorkspace/Pets/'
293104 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
293122 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@2604940
293122 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
293124 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
293125 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
A house may have any number of pets living in it. The two possible types of pets that can live in a house are dogs and cats. Each dog or cat has a name. An animal’s house is its one and only home. You can tell an animal to make noise and it will do its thing.
Functional requirement：
+ Retrieve a list of all pet names (dogs and cats) living in a specified house. Return an empty list if there are no pets.

+ Add a pet to the house. Return false if the pet already belongs to any house (including this one) or the pet does have name; return true if the pet is added successfully.

+ Remove a specified pet from its current house. Return false if the pet does not belong to the given current house; return true if it is removed successfully.

+ Retrieve a list of pets of a specific input string ("dog" or "cat") that live in a particular house. Return an empty list if there are no pets.

+ Count the number of pets in a particular house. Return 0 if there are no pets.
```

# Class Diagram
```plantuml
@startuml

title pets Model

class Cat {
}
class Dog {
}
class House {
    pets : List<Pet>
    addPet(pet : Pet) : boolean
    getPetCount(type : String) : int
    getPetsByType(type : String) : List<Pet>
    removePet(pet : Pet) : void
    retrievePetNames() : List<String>
}
abstract class Pet {
    name : String
    house : House
    makeNoise() : void
}

Cat --|> Pet
Dog --|> Pet
House *-- "*" Pet : pets  'opposite: house
Pet --> House : house  'opposite: pets
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

312884 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@6f12fca0 (name: makeNoise) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Makes the pet produce its characteristic sound.
Algorithm: This is an abstract method; subclasses (Cat, Dog) must override it to define specific behavior.
Input: None
Output: None
Pre-condition: None
Post-condition: The pet makes a noise., org.eclipse.emf.ecore.impl.EOperationImpl@df04d12 (name: getPetsByType) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary: Retrieves a list of pets of a specified type ("dog" or "cat") that live in the house.
Algorithm:
  List<Pet> result = new List<Pet>()
  for each pet in pets do
    if type.toLowerCase() == "dog" and pet instanceof Dog then
      result.add(pet)
    else if type.toLowerCase() == "cat" and pet instanceof Cat then
      result.add(pet)
  return result
Input:
  type : String - The type of pet to filter by ("dog" or "cat"). Case-insensitive.
Output:
  List<Pet> - A list of pets matching the given type. Returns an empty list if no matches.
Pre-condition: type must be either "dog" or "cat" (case-insensitive)
Post-condition: None, org.eclipse.emf.ecore.impl.EOperationImpl@7ff7e353 (name: retrievePetNames) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary: Retrieves a list of all pet names living in the house.
Algorithm:
  List<String> names = new List<String>()
  for each pet in pets do
    names.add(pet.name)
  return names
Input: None
Output:
  List<String> - A list of names of all pets in the house. Returns an empty list if there are no pets.
Pre-condition: None
Post-condition: None, org.eclipse.emf.ecore.impl.EOperationImpl@12c30824 (name: addPet) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Adds a pet to the house if it does not already belong to a house and has a name.
Algorithm:
  if pet.house != null then return false
  if pet.name == null or pet.name.trim() == "" then return false
  pets.add(pet)
  pet.house = this
  return true
Input:
  pet : Pet - The pet to be added to the house. Must have a non-null/non-empty name.
Output:
  boolean - true if the pet was successfully added, false otherwise.
Pre-condition: None
Post-condition: If successful, the pet is added to the house's pet list and its house reference is set to this house., org.eclipse.emf.ecore.impl.EOperationImpl@7d0e43d6 (name: getPetCount) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Counts the total number of pets in the house.
Algorithm:
  return pets.size()
Input:
  type : String - Not used in current implementation; could be used for filtering by type if extended.
Output:
  int - The number of pets in the house. Returns 0 if there are no pets.
Pre-condition: None
Post-condition: None, org.eclipse.emf.ecore.impl.EOperationImpl@757f47f0 (name: removePet) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Removes a specified pet from the house.
Algorithm:
  if pet.house != this then return false
  pets.remove(pet)
  pet.house = null
  return true
Input:
  pet : Pet - The pet to be removed from the house.
Output:
  boolean - true if the pet was successfully removed, false otherwise.
Pre-condition: None
Post-condition: If successful, the pet is removed from the house's pet list and its house reference is set to null.}
312887 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
312955 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../Pets/src-gen/edu/pets
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getPets <em>Pets</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Pet> pets;

  protected House()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Pet> getPets()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of all pet names living in the house.
   * Algorithm:
   *   List<String> names = new List<String>()
   *   for each pet in pets do
   *     names.add(pet.name)
   *   return names
   * Input: None
   * Output:
   *   List<String> - A list of names of all pets in the house. Returns an empty list if there are no pets.
   * Pre-condition: None
   * Post-condition: None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<String> retrievePetNames()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Adds a pet to the house if it does not already belong to a house and has a name.
   * Algorithm:
   *   if pet.house != null then return false
   *   if pet.name == null or pet.name.trim() == "" then return false
   *   pets.add(pet)
   *   pet.house = this
   *   return true
   * Input:
   *   pet : Pet - The pet to be added to the house. Must have a non-null/non-empty name.
   * Output:
   *   boolean - true if the pet was successfully added, false otherwise.
   * Pre-condition: None
   * Post-condition: If successful, the pet is added to the house's pet list and its house reference is set to this house.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean addPet(final Pet pet)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Removes a specified pet from the house.
   * Algorithm:
   *   if pet.house != this then return false
   *   pets.remove(pet)
   *   pet.house = null
   *   return true
   * Input:
   *   pet : Pet - The pet to be removed from the house.
   * Output:
   *   boolean - true if the pet was successfully removed, false otherwise.
   * Pre-condition: None
   * Post-condition: If successful, the pet is removed from the house's pet list and its house reference is set to null.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void removePet(final Pet pet)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of pets of a specified type ("dog" or "cat") that live in the house.
   * Algorithm:
   *   List<Pet> result = new List<Pet>()
   *   for each pet in pets do
   *     if type.toLowerCase() == "dog" and pet instanceof Dog then
   *       result.add(pet)
   *     else if type.toLowerCase() == "cat" and pet instanceof Cat then
   *       result.add(pet)
   *   return result
   * Input:
   *   type : String - The type of pet to filter by ("dog" or "cat"). Case-insensitive.
   * Output:
   *   List<Pet> - A list of pets matching the given type. Returns an empty list if no matches.
   * Pre-condition: type must be either "dog" or "cat" (case-insensitive)
   * Post-condition: None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<Pet> getPetsByType(final String type)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the total number of pets in the house.
   * Algorithm:
   *   return pets.size()
   * Input:
   *   type : String - Not used in current implementation; could be used for filtering by type if extended.
   * Output:
   *   int - The number of pets in the house. Returns 0 if there are no pets.
   * Pre-condition: None
   * Post-condition: None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int getPetCount(final String type)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // House
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Pet` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Public methods: public void makeNoise()
  + Getter methods: public String getName(), public House getHouse()
  + Setter methods: public void setName(String newName), public void setHouse(House newHouse)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getPets <em>Pets</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Pet> pets;

  protected House()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Pet> getPets()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of all pet names living in the house.
   * Algorithm:
   *   List<String> names = new List<String>()
   *   for each pet in pets do
   *     names.add(pet.name)
   *   return names
   * Input: None
   * Output:
   *   List<String> - A list of names of all pets in the house. Returns an empty list if there are no pets.
   * Pre-condition: None
   * Post-condition: None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> retrievePetNames()
  {
    EList<String> names = new BasicEList<String>();
    for (Pet pet : getPets()) {
      names.add(pet.getName());
    }
    return names;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Adds a pet to the house if it does not already belong to a house and has a name.
   * Algorithm:
   *   if pet.house != null then return false
   *   if pet.name == null or pet.name.trim() == "" then return false
   *   pets.add(pet)
   *   pet.house = this
   *   return true
   * Input:
   *   pet : Pet - The pet to be added to the house. Must have a non-null/non-empty name.
   * Output:
   *   boolean - true if the pet was successfully added, false otherwise.
   * Pre-condition: None
   * Post-condition: If successful, the pet is added to the house's pet list and its house reference is set to this house.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean addPet(final Pet pet)
  {
    if (pet.getHouse() != null) {
      return false;
    }
    if (pet.getName() == null || pet.getName().trim().isEmpty()) {
      return false;
    }
    getPets().add(pet);
    pet.setHouse(this);
    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Removes a specified pet from the house.
   * Algorithm:
   *   if pet.house != this then return false
   *   pets.remove(pet)
   *   pet.house = null
   *   return true
   * Input:
   *   pet : Pet - The pet to be removed from the house.
   * Output:
   *   boolean - true if the pet was successfully removed, false otherwise.
   * Pre-condition: None
   * Post-condition: If successful, the pet is removed from the house's pet list and its house reference is set to null.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void removePet(final Pet pet)
  {
    if (pet.getHouse() != this) {
      return;
    }
    getPets().remove(pet);
    pet.setHouse(null);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of pets of a specified type ("dog" or "cat") that live in the house.
   * Algorithm:
   *   List<Pet> result = new List<Pet>()
   *   for each pet in pets do
   *     if type.toLowerCase() == "dog" and pet instanceof Dog then
   *       result.add(pet)
   *     else if type.toLowerCase() == "cat" and pet instanceof Cat then
   *       result.add(pet)
   *   return result
   * Input:
   *   type : String - The type of pet to filter by ("dog" or "cat"). Case-insensitive.
   * Output:
   *   List<Pet> - A list of pets matching the given type. Returns an empty list if no matches.
   * Pre-condition: type must be either "dog" or "cat" (case-insensitive)
   * Post-condition: None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Pet> getPetsByType(final String type)
  {
    EList<Pet> result = new BasicEList<Pet>();
    String lowerType = type.toLowerCase();
    
    for (Pet pet : getPets()) {
      if ("dog".equals(lowerType) && pet instanceof Dog) {
        result.add(pet);
      } else if ("cat".equals(lowerType) && pet instanceof Cat) {
        result.add(pet);
      }
    }
    return result;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the total number of pets in the house.
   * Algorithm:
   *   return pets.size()
   * Input:
   *   type : String - Not used in current implementation; could be used for filtering by type if extended.
   * Output:
   *   int - The number of pets in the house. Returns 0 if there are no pets.
   * Pre-condition: None
   * Post-condition: None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int getPetCount(final String type)
  {
    return getPets().size();
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // House
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public House getHouse()
  { ... /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { ... /* omitted */ }

  public void setHouse(House newHouse)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet produce its characteristic sound.
   * Algorithm: This is an abstract method; subclasses (Cat, Dog) must override it to define specific behavior.
   * Input: None
   * Output: None
   * Pre-condition: None
   * Post-condition: The pet makes a noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void makeNoise()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `House` contains the following methods.
  + Instance creation: Use `PetsFactory.eINSTANCE.createHouse()`
  + Public methods: public EList<String> retrievePetNames(), public boolean addPet(final Pet pet), public void removePet(final Pet pet), public EList<Pet> getPetsByType(final String type), public int getPetCount(final String type)
  + Getter methods: public EList<Pet> getPets()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public House getHouse()
  { ... /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { ... /* omitted */ }

  public void setHouse(House newHouse)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet produce its characteristic sound.
   * Algorithm: This is an abstract method; subclasses (Cat, Dog) must override it to define specific behavior.
   * Input: None
   * Output: None
   * Pre-condition: None
   * Post-condition: The pet makes a noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void makeNoise()
  {
    // Abstract method - implementation should be provided by subclasses
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
376156 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../Pets/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../Pets/src-gen/edu/pets/
376269 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
376269 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
376269 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
376269 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
376271 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample4.mwe2 启动完成
正在拷贝 src-gen/edu/pets 到 qwen3-coder/pets4...
拷贝完成！

======================================
正在启动 sample5.mwe2...
======================================
376484 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Initializing Xtext generator
376561 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Registering project Pets at 'file:/D:/EclipseWorkspace/Pets/'
376564 [main] INFO  lipse.emf.mwe.utils.StandaloneSetup  - Using resourceSet registry. The registered Packages will not be registered in the global EPackage.Registry.INSTANCE!
376586 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating edu.ustb.sei.mde.mwe2.EcoreLanguage@2f1b8770
376586 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing Ecore model
376588 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Annotating EOperations
376590 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - # Task
You will be given a **Requirement** and a **Class Diagram** in PlantUML. Your task is to annotate every operation in the class diagram with a specfication.

An operation specification must describe the following sections about the operation:
1. Summary: the summary of functionality;
2. Algorithm: The algorithm or pesudo code;
3. Input: the input parameters, including the meaning, the format, and the value ranges if necessary;
4. Output: output value, including the meaning, the format, and the value ranges if necessary
4. Pre-condition and Post-condition: the pre-/post-conditions if necessary.

Finish this task by following the guidelines below.
1. Take the principle of modularization into account.
2. For each operation, determine its functional boundary based on the given requirement. Ensure high cohesion and low coupling.
3. If there is any unspecified details, such as undefined constants, rates, and ratios, then you must infer them.
4. Make sure that all requirements can be covered.

# Requirement
```text
A house may have any number of pets living in it. The two possible types of pets that can live in a house are dogs and cats. Each dog or cat has a name. An animal’s house is its one and only home. You can tell an animal to make noise and it will do its thing.
Functional requirement：
+ Retrieve a list of all pet names (dogs and cats) living in a specified house. Return an empty list if there are no pets.

+ Add a pet to the house. Return false if the pet already belongs to any house (including this one) or the pet does have name; return true if the pet is added successfully.

+ Remove a specified pet from its current house. Return false if the pet does not belong to the given current house; return true if it is removed successfully.

+ Retrieve a list of pets of a specific input string ("dog" or "cat") that live in a particular house. Return an empty list if there are no pets.

+ Count the number of pets in a particular house. Return 0 if there are no pets.
```

# Class Diagram
```plantuml
@startuml

title pets Model

class Cat {
}
class Dog {
}
class House {
    pets : List<Pet>
    addPet(pet : Pet) : boolean
    getPetCount(type : String) : int
    getPetsByType(type : String) : List<Pet>
    removePet(pet : Pet) : void
    retrievePetNames() : List<String>
}
abstract class Pet {
    name : String
    house : House
    makeNoise() : void
}

Cat --|> Pet
Dog --|> Pet
House *-- "*" Pet : pets  'opposite: house
Pet --> House : house  'opposite: pets
@enduml
```

# Output Format
Put all your results in a single block as illustrated below:

```result

class_1::operation_1
/*
 * your description for operation_1
 */

class_1::operation_2
/*
 * your description for this operation_2
 */

...
```

412251 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - {org.eclipse.emf.ecore.impl.EOperationImpl@61b6f287 (name: getPetsByType) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary: Retrieves a list of pets of a specified type living in the house.
Algorithm:
  1. Create an empty result list
  2. For each pet in this.pets:
     a. If type equals "dog" and pet is an instance of Dog, add to result
     b. If type equals "cat" and pet is an instance of Cat, add to result
  3. Return result list
Input: 
  - type: String - the type of pets to retrieve ("dog" or "cat")
Output: 
  - List<Pet> - a list of pets matching the specified type (may be empty)
Pre-condition: 
  - type is either "dog" or "cat" (case-sensitive)
Post-condition: None, org.eclipse.emf.ecore.impl.EOperationImpl@2c9430c6 (name: makeNoise) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Makes the pet produce its characteristic sound.
Algorithm: 
  1. If the pet is a Dog, print "Woof!"
  2. If the pet is a Cat, print "Meow!"
Input: None
Output: None
Pre-condition: None
Post-condition: The pet has made its noise., org.eclipse.emf.ecore.impl.EOperationImpl@66978c15 (name: addPet) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Adds a pet to the house if it does not already belong to any house and has a name.
Algorithm:
  1. If pet.name is null or empty, return false
  2. If pet.house is not null, return false
  3. Add pet to this.pets list
  4. Set pet.house to this house
  5. Return true
Input: 
  - pet: Pet - the pet to be added (must have a non-null/non-empty name and no current house)
Output: 
  - boolean - true if the pet was added successfully, false otherwise
Pre-condition: 
  - pet is not null
Post-condition: 
  - If successful, pet is in this house's pets list and pet.house refers to this house, org.eclipse.emf.ecore.impl.EOperationImpl@360432d3 (name: retrievePetNames) (ordered: true, unique: true, lowerBound: 0, upperBound: -1)=Summary: Retrieves a list of all pet names living in the house.
Algorithm:
  1. Create an empty list of strings called names
  2. For each pet in this.pets:
     a. Add pet.name to names list
  3. Return names list
Input: None
Output: 
  - List<String> - a list containing the names of all pets in the house (may be empty)
Pre-condition: None
Post-condition: None, org.eclipse.emf.ecore.impl.EOperationImpl@6c96dc5c (name: getPetCount) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Counts the total number of pets in the house.
Algorithm:
  1. Return the size of this.pets list
Input: None
Output: 
  - int - the number of pets in the house (zero or positive integer)
Pre-condition: None
Post-condition: None, org.eclipse.emf.ecore.impl.EOperationImpl@6ca9ec77 (name: removePet) (ordered: true, unique: true, lowerBound: 0, upperBound: 1)=Summary: Removes a specified pet from the house.
Algorithm:
  1. If pet.house is not this house, return false
  2. Remove pet from this.pets list
  3. Set pet.house to null
  4. Return true
Input: 
  - pet: Pet - the pet to be removed
Output: 
  - boolean - true if the pet was removed successfully, false otherwise
Pre-condition: 
  - pet is not null
Post-condition: 
  - If successful, pet is not in this house's pets list and pet.house is null}
412253 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Generating EMF model code
412276 [main] INFO  .sei.mde.mwe2.EMFGeneratorFragment2  - Enhancing generated code at ../Pets/src-gen/edu/pets
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getPets <em>Pets</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Pet> pets;

  protected House()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Pet> getPets()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of all pet names living in the house.
   * Algorithm:
   *   1. Create an empty list of strings called names
   *   2. For each pet in this.pets:
   *      a. Add pet.name to names list
   *   3. Return names list
   * Input: None
   * Output: 
   *   - List<String> - a list containing the names of all pets in the house (may be empty)
   * Pre-condition: None
   * Post-condition: None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<String> retrievePetNames()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Adds a pet to the house if it does not already belong to any house and has a name.
   * Algorithm:
   *   1. If pet.name is null or empty, return false
   *   2. If pet.house is not null, return false
   *   3. Add pet to this.pets list
   *   4. Set pet.house to this house
   *   5. Return true
   * Input: 
   *   - pet: Pet - the pet to be added (must have a non-null/non-empty name and no current house)
   * Output: 
   *   - boolean - true if the pet was added successfully, false otherwise
   * Pre-condition: 
   *   - pet is not null
   * Post-condition: 
   *   - If successful, pet is in this house's pets list and pet.house refers to this house
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public boolean addPet(final Pet pet)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Removes a specified pet from the house.
   * Algorithm:
   *   1. If pet.house is not this house, return false
   *   2. Remove pet from this.pets list
   *   3. Set pet.house to null
   *   4. Return true
   * Input: 
   *   - pet: Pet - the pet to be removed
   * Output: 
   *   - boolean - true if the pet was removed successfully, false otherwise
   * Pre-condition: 
   *   - pet is not null
   * Post-condition: 
   *   - If successful, pet is not in this house's pets list and pet.house is null
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void removePet(final Pet pet)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of pets of a specified type living in the house.
   * Algorithm:
   *   1. Create an empty result list
   *   2. For each pet in this.pets:
   *      a. If type equals "dog" and pet is an instance of Dog, add to result
   *      b. If type equals "cat" and pet is an instance of Cat, add to result
   *   3. Return result list
   * Input: 
   *   - type: String - the type of pets to retrieve ("dog" or "cat")
   * Output: 
   *   - List<Pet> - a list of pets matching the specified type (may be empty)
   * Pre-condition: 
   *   - type is either "dog" or "cat" (case-sensitive)
   * Post-condition: None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public EList<Pet> getPetsByType(final String type)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the total number of pets in the house.
   * Algorithm:
   *   1. Return the size of this.pets list
   * Input: None
   * Output: 
   *   - int - the number of pets in the house (zero or positive integer)
   * Pre-condition: None
   * Post-condition: None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public int getPetCount(final String type)
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // House
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `Pet` contains the following methods.
  + Instance creation: Can only be used as an abstract type
  + Public methods: public void makeNoise()
  + Getter methods: public String getName(), public House getHouse()
  + Setter methods: public void setName(String newName), public void setHouse(House newHouse)

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import java.util.Collection;

import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EObjectContainmentWithInverseEList;
import org.eclipse.emf.ecore.util.InternalEList;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>House</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.House#getPets <em>Pets</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getHouse()
 * @model kind="class"
 * @generated
 */
public class House extends MinimalEObjectImpl.Container implements EObject
{
  protected EList<Pet> pets;

  protected House()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public EList<Pet> getPets()
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of all pet names living in the house.
   * Algorithm:
   *   1. Create an empty list of strings called names
   *   2. For each pet in this.pets:
   *      a. Add pet.name to names list
   *   3. Return names list
   * Input: None
   * Output: 
   *   - List<String> - a list containing the names of all pets in the house (may be empty)
   * Pre-condition: None
   * Post-condition: None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<String> retrievePetNames()
  {
    EList<String> names = new BasicEList<String>();
    for (Pet pet : getPets()) {
      names.add(pet.getName());
    }
    return names;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Adds a pet to the house if it does not already belong to any house and has a name.
   * Algorithm:
   *   1. If pet.name is null or empty, return false
   *   2. If pet.house is not null, return false
   *   3. Add pet to this.pets list
   *   4. Set pet.house to this house
   *   5. Return true
   * Input: 
   *   - pet: Pet - the pet to be added (must have a non-null/non-empty name and no current house)
   * Output: 
   *   - boolean - true if the pet was added successfully, false otherwise
   * Pre-condition: 
   *   - pet is not null
   * Post-condition: 
   *   - If successful, pet is in this house's pets list and pet.house refers to this house
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public boolean addPet(final Pet pet)
  {
    if (pet.getName() == null || pet.getName().isEmpty()) {
      return false;
    }
    if (pet.getHouse() != null) {
      return false;
    }
    getPets().add(pet);
    pet.setHouse(this);
    return true;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Removes a specified pet from the house.
   * Algorithm:
   *   1. If pet.house is not this house, return false
   *   2. Remove pet from this.pets list
   *   3. Set pet.house to null
   *   4. Return true
   * Input: 
   *   - pet: Pet - the pet to be removed
   * Output: 
   *   - boolean - true if the pet was removed successfully, false otherwise
   * Pre-condition: 
   *   - pet is not null
   * Post-condition: 
   *   - If successful, pet is not in this house's pets list and pet.house is null
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void removePet(final Pet pet)
  {
    if (pet.getHouse() != this) {
      return;
    }
    getPets().remove(pet);
    pet.setHouse(null);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Retrieves a list of pets of a specified type living in the house.
   * Algorithm:
   *   1. Create an empty result list
   *   2. For each pet in this.pets:
   *      a. If type equals "dog" and pet is an instance of Dog, add to result
   *      b. If type equals "cat" and pet is an instance of Cat, add to result
   *   3. Return result list
   * Input: 
   *   - type: String - the type of pets to retrieve ("dog" or "cat")
   * Output: 
   *   - List<Pet> - a list of pets matching the specified type (may be empty)
   * Pre-condition: 
   *   - type is either "dog" or "cat" (case-sensitive)
   * Post-condition: None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public EList<Pet> getPetsByType(final String type)
  {
    EList<Pet> result = new BasicEList<Pet>();
    for (Pet pet : getPets()) {
      if ("dog".equals(type) && pet instanceof Dog) {
        result.add(pet);
      } else if ("cat".equals(type) && pet instanceof Cat) {
        result.add(pet);
      }
    }
    return result;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Counts the total number of pets in the house.
   * Algorithm:
   *   1. Return the size of this.pets list
   * Input: None
   * Output: 
   *   - int - the number of pets in the house (zero or positive integer)
   * Pre-condition: None
   * Post-condition: None
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public int getPetCount(final String type)
  {
    return getPets().size();
  }

  @SuppressWarnings("unchecked")
  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @SuppressWarnings("unchecked")
  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

} // House
# Task
You will be given a **Java Class** generated from an Ecore model by EMF code generator with `suppressInterfaces=true`. Your task is to implement the Java methods unimplemented by taking additional **Context** information into account.

Complete this task by following the guidelines below.
1. A method is unimplemented if its body contains `// TODO: Please complete this Java method based on the docstring`.
2. For every unimplemented method, 
  2.1 You must read the docstring of this method. The fragment between `<!-- begin-model-doc -->` and `<!-- end-model-doc -->` contains the method specification;
  2.2 Generate your code strictly according to the algorithm; Be aware of the EMF code style and APIs; Note that the getter of a boolean attribute `bv` looks like `isBv()`, e.g., `isIsTrue()` for `isTrue`;
  2.3 You should not change the method signature;
  2.4 After generation, replace the current body with the one you generate;
  2.5 Keep and update the docstring by changing `@generated` to `@generated NOT`.
3. Check the import list. Add missing imports if needed. Collection types provided by EMF is listed below
  - BasicEList: `org.eclipse.emf.common.util.BasicEList`;
4. Do not change other part.
5. Be aware of the method signatures, particularly, the input and output types, provided in the **Context**.

# Java Class
```java
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { ... /* omitted */ }

  @Override
  protected EClass eStaticClass()
  { ... /* omitted */ }

  public String getName()
  { ... /* omitted */ }

  public void setName(String newName)
  { ... /* omitted */ }

  public House getHouse()
  { ... /* omitted */ }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  { ... /* omitted */ }

  public void setHouse(House newHouse)
  { ... /* omitted */ }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet produce its characteristic sound.
   * Algorithm: 
   *   1. If the pet is a Dog, print "Woof!"
   *   2. If the pet is a Cat, print "Meow!"
   * Input: None
   * Output: None
   * Pre-condition: None
   * Post-condition: The pet has made its noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated
   */
  public void makeNoise()
  {
    // TODO: Please generate a body of this unimplemented method based on the docstring
    // TODO: Replace the current body with the generated body 
    // TODO: Ensure that you mark it @generated NOT after code completion
    throw new UnsupportedOperationException();
    
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  { ... /* omitted */ }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  { ... /* omitted */ }

  @Override
  public void eSet(int featureID, Object newValue)
  { ... /* omitted */ }

  @Override
  public void eUnset(int featureID)
  { ... /* omitted */ }

  @Override
  public boolean eIsSet(int featureID)
  { ... /* omitted */ }

  @Override
  public String toString()
  { ... /* omitted */ }

} // Pet
```

# Context
The following classes' information may be helpful for you. **DO NOT** call methods that are not listed.
- Class `House` contains the following methods.
  + Instance creation: Use `PetsFactory.eINSTANCE.createHouse()`
  + Public methods: public EList<String> retrievePetNames(), public boolean addPet(final Pet pet), public void removePet(final Pet pet), public EList<Pet> getPetsByType(final String type), public int getPetCount(final String type)
  + Getter methods: public EList<Pet> getPets()
  + Setter methods: 

# Output Format
Put the new Java class code into a single block as follows.

```java
(completed Java class)
```

generated code:
/**
 * generated by Enhanced EcoreGen
 */
package edu.pets;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.InternalEObject;

import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.MinimalEObjectImpl;

import org.eclipse.emf.ecore.util.EcoreUtil;

/**
 * <!-- begin-user-doc -->
 * A representation of the model object '<em><b>Pet</b></em>'.
 * <!-- end-user-doc -->
 *
 * <p>
 * The following features are supported:
 * </p>
 * <ul>
 *   <li>{@link edu.pets.Pet#getName <em>Name</em>}</li>
 *   <li>{@link edu.pets.Pet#getHouse <em>House</em>}</li>
 * </ul>
 *
 * @see edu.pets.PetsPackage#getPet()
 * @model kind="class" abstract="true"
 * @generated
 */
public abstract class Pet extends MinimalEObjectImpl.Container implements EObject
{
  protected static final String NAME_EDEFAULT = null;

  protected String name = NAME_EDEFAULT;

  protected Pet()
  { }

  @Override
  protected EClass eStaticClass()
  {
    return PetsPackage.Literals.PET;
  }

  public String getName()
  {
    return name;
  }

  public void setName(String newName)
  {
    String oldName = name;
    name = newName;
    if (eNotificationRequired())
      eNotify(new ENotificationImpl(this, Notification.SET, PetsPackage.PET__NAME, oldName, name));
  }

  public House getHouse()
  {
    if (eContainerFeatureID() != PetsPackage.PET__HOUSE) return null;
    return (House)eContainer();
  }

  public NotificationChain basicSetHouse(House newHouse, NotificationChain msgs)
  {
    msgs = eBasicSetContainer((InternalEObject)newHouse, PetsPackage.PET__HOUSE, msgs);
    return msgs;
  }

  public void setHouse(House newHouse)
  {
    if (newHouse != eInternalContainer() || (eContainerFeatureID() != PetsPackage.PET__HOUSE && newHouse != null))
    {
      if (EcoreUtil.isAncestor(this, newHouse))
        throw new IllegalArgumentException("Recursive containment not allowed for " + toString());
      NotificationChain msgs = null;
      if (eInternalContainer() != null)
        msgs = eBasicRemoveFromContainer(msgs);
      if (newHouse != null)
        msgs = ((InternalEObject)newHouse).eInverseAdd(this, PetsPackage.HOUSE__PETS, House.class, msgs);
      msgs = basicSetHouse(newHouse, msgs);
      if (msgs != null) msgs.dispatch();
    }
    else if (eNotificationRequired())
      eNotify(new ENotificationImpl(this, Notification.SET, PetsPackage.PET__HOUSE, newHouse, newHouse));
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * <!-- begin-model-doc -->
   * Summary: Makes the pet produce its characteristic sound.
   * Algorithm: 
   *   1. If the pet is a Dog, print "Woof!"
   *   2. If the pet is a Cat, print "Meow!"
   * Input: None
   * Output: None
   * Pre-condition: None
   * Post-condition: The pet has made its noise.
   * <!-- end-model-doc -->
   * @model annotation="http://www.ustb.edu.cn/sei/mde/EnhancedCodeGen generated='true'"
   * @generated NOT
   */
  public void makeNoise()
  {
    if (this instanceof Dog) {
      System.out.println("Woof!");
    } else if (this instanceof Cat) {
      System.out.println("Meow!");
    }
  }

  @Override
  public NotificationChain eInverseAdd(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  {
    switch (featureID)
    {
      case PetsPackage.PET__HOUSE:
        if (eInternalContainer() != null)
          msgs = eBasicRemoveFromContainer(msgs);
        return basicSetHouse((House)otherEnd, msgs);
    }
    return super.eInverseAdd(otherEnd, featureID, msgs);
  }

  @Override
  public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs)
  {
    switch (featureID)
    {
      case PetsPackage.PET__HOUSE:
        return basicSetHouse(null, msgs);
    }
    return super.eInverseRemove(otherEnd, featureID, msgs);
  }

  @Override
  public NotificationChain eBasicRemoveFromContainerFeature(NotificationChain msgs)
  {
    switch (eContainerFeatureID())
    {
      case PetsPackage.PET__HOUSE:
        return eInternalContainer().eInverseRemove(this, PetsPackage.HOUSE__PETS, House.class, msgs);
    }
    return super.eBasicRemoveFromContainerFeature(msgs);
  }

  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  {
    switch (featureID)
    {
      case PetsPackage.PET__NAME:
        return getName();
      case PetsPackage.PET__HOUSE:
        return getHouse();
    }
    return super.eGet(featureID, resolve, coreType);
  }

  @Override
  public void eSet(int featureID, Object newValue)
  {
    switch (featureID)
    {
      case PetsPackage.PET__NAME:
        setName((String)newValue);
        return;
      case PetsPackage.PET__HOUSE:
        setHouse((House)newValue);
        return;
    }
    super.eSet(featureID, newValue);
  }

  @Override
  public void eUnset(int featureID)
  {
    switch (featureID)
    {
      case PetsPackage.PET__NAME:
        setName(NAME_EDEFAULT);
        return;
      case PetsPackage.PET__HOUSE:
        setHouse((House)null);
        return;
    }
    super.eUnset(featureID);
  }

  @Override
  public boolean eIsSet(int featureID)
  {
    switch (featureID)
    {
      case PetsPackage.PET__NAME:
        return NAME_EDEFAULT == null ? name != null : !NAME_EDEFAULT.equals(name);
      case PetsPackage.PET__HOUSE:
        return getHouse() != null;
    }
    return super.eIsSet(featureID);
  }

  @Override
  public String toString()
  {
    if (eIsProxy()) return super.toString();

    StringBuilder result = new StringBuilder(super.toString());
    result.append(" (name: ");
    result.append(name);
    result.append(')');
    return result.toString();
  }

} // Pet
452705 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - BatchCompiler -11 -d ../Pets/src-gen/../llm-bin -classpath "C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.ecore_2.40.0.v20250803-1633.jar;C:/Users/20936/.p2/pool/plugins/org.eclipse.emf.common_2.43.0.v20250629-1403.jar" ../Pets/src-gen/edu/pets/
452845 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - 
452845 [main] ERROR du.ustb.sei.mde.mwe2.EcoreGenerator  - 
452845 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - There is more compilation error
452845 [main] INFO  du.ustb.sei.mde.mwe2.EcoreGenerator  - Generating common infrastructure
452846 [main] INFO  .emf.mwe2.runtime.workflow.Workflow  - Done.
sample5.mwe2 启动完成
正在拷贝 src-gen/edu/pets 到 qwen3-coder/pets5...
拷贝完成！

======================================
所有任务完成！
======================================

package edu.ustb.sei.mde.eecg.facade

import java.io.File
import java.io.FileOutputStream
import java.io.PrintStream
import java.util.List
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EcoreFactory
import org.eclipse.emf.ecore.resource.Resource

class WorkflowInitializer {
	def String generateMWEFile(String srcFolder, String mweName, Resource ecore, String rootPath, String baseProject, String basePackage, String eclipseClasspath, boolean force) {
		val mwePathFile = '''«rootPath»/«baseProject»/«srcFolder»/«mweName».mwe2'''
		val mweFile = new File(mwePathFile)
		
		if(mweFile.exists && !force) return null
		else {
			val print = new PrintStream(new FileOutputStream(mweFile, false))
			val content = generateMWEContent(srcFolder, ecore, rootPath, baseProject, basePackage, eclipseClasspath)
			print.print(content)
			print.flush
			print.close
			return mwePathFile
		}
	}
	
	def void saveLastMweToEcore(Resource ecore, File mwe) {
		val pkg = ecore.contents.first as EPackage
		val ann = pkg.getEAnnotation('workflow') ?: {
			EcoreFactory.eINSTANCE.createEAnnotation => [
				pkg.EAnnotations += it
				it.source = 'workflow'
			]
		}
		ann.details.put('last', mwe.absolutePath)
		ecore.save(null);
	}
	
	def void generateConfFile(String srcFolder, String rootPath, String baseProject,boolean force) {
		val confPathFile = '''«rootPath»/«baseProject»/«srcFolder»/conf.properties'''
		val confFile = new File(confPathFile)
		
		if(confFile.exists) return
		else {
			val print = new PrintStream(new FileOutputStream(confFile, false))
			val content = generateConfContent()
			print.print(content)
			print.flush
			print.close
		}
	}
	
	def wrapPath(String path){
		path.replaceAll('\\\\', '/')
	}
	
	def generateConfContent() {
		'''
		url=https://api.deepseek.com/
		model=deepseek-chat
		apikey=<replace with your key>
		timeout=600
		'''
	}
	
	def generateMWEContent(String srcFolder, Resource ecore, String rootPath, String baseProject, String basePackage, String eclipseClasspath) {
		val ePkg = ecore.contents.first as EPackage
		val classPath = new File(eclipseClasspath)
		'''
		module «baseProject».Generate«ePkg.name.toFirstUpper»
		
		import org.eclipse.xtext.xtext.generator.*
		import org.eclipse.xtext.xtext.generator.model.project.*
		import edu.ustb.sei.mde.mwe2.*
		
		var rootPath = "«IF rootPath===null»..«ELSE»«rootPath.wrapPath»«ENDIF»"
		
		Workflow {
			component = EcoreGenerator auto-inject {
				configuration = {
					project = StandardProjectConfig {
						baseName = "«baseProject»"
						rootPath = rootPath
						createEclipseMetaData = true
					}
					code = {
						encoding = "UTF-8"
						lineDelimiter = "\r\n"
						fileHeader = "/*\n * generated by Enhanced EcoreGen\n */"
						preferXtendStubs = false
					}
				}
				language = EcoreLanguage {
					ecoreFile="file://«ecore.URI.toFileString.wrapPath»"
					basePackage = "«basePackage»"
					fileExtensions = "«ePkg.name»"
					suppressInterfaces = true
					llmConfig = '«rootPath.wrapPath»/«baseProject»/«srcFolder»/conf.properties'
					
					«FOR path : searchLibraryPaths(classPath, #[])»					
					classpath = '«path.replaceAll('\\\\', '/')»'
					«ENDFOR»
				}
				
				languageModule = 'edu.ustb.sei.mde.eecg.llm.languageModule.DefaultEnhancedEcoreGenModule'
			}
		}
		'''
	}
	
	val emfLibNames = #['org.eclipse.emf.ecore', 'org.eclipse.emf.common']
	def searchLibraryPaths(File path, List<String> additionalLibraries) {
		val pats = (emfLibNames+additionalLibraries).map[it+'_'].toList
		
		if(path.isDirectory && path.exists) {
			path.listFiles[file|
				val filename = file.name
				val isJar = filename.endsWith('.jar')
				return (file.isFile && isJar && pats.exists[filename.startsWith(it)])
			].map[it.absolutePath].toList
		} else #[]
	}
}
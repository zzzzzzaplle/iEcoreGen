# iEcoreGen
A Hybrid Approach for EMF Code Generation: Code Templates Meet Large Language Models

# Introduction

**iEcoreGen** is a LLM-enhanced model-driven code generation project. It combines conventional MDE code generation with LLM-based code generation.

MDE allows to generate correct code from a model. However, MDE fails when the model cannot express our intention. In contrast, LLM-based code generation can always give a response, even though its answer may be incorrect.

The basic idea of iEcoreGen is to combine MDE and LLM. Given an Ecore model, we ask EMF to generate source code from the model, while leaving unspecified operations to LLMs.

We hope that such a combination can allow us to benefit from both MDE and LLM.

# Approach

![workflow](image/workflow.jpg)

The input is an ecore model, optionally with a system requirement.

The system requirement can be provided in this way:
 **Embedded in the Ecore model**: Using an EAnnotation (typically named "EnhancedCodeGen") with a Details Entry containing the functional requirements (equivalent to FR.md content)

Our tool will read the ecore model and check if there is a requirement. If not, our tool will ask LLMs to synthesize a requirement according to the model.

Then, we ask LLMs to write a specification for every operation. An operation specification includes a summary of functionality, an algorithm, input and output values, and pre-/post-conditions.

We will extract the specifications returned and store them as operation documents in the model.

After that, EMF code generator will be invoked to generate Java code from the ecore model.

Note that operations defined in the model are still unimplemented and the specifications will be generated as docstrings.

We further send Java code generated by EMF to LLMs and ask them to complete unimplemented operations based on their docstrings.

Due to token limit, we must minimize the Java code sent to LLMs by hiding details of Java methods and fields that are not intended to be completed by LLMs.

We also provide necessary context, such as related classes and their methods, to facilitate code generation.

At last, we merge the code returned by LLMs into the EMF generated code to complete the entire generation process.

# Repository Structure

```
iEcoreGen/
├── benchmarks/              # Evaluation datasets with 20 domain models
│   ├── AcademicProgram/
│   ├── AirlineFlights/
│   ├── BankSystem/
│   ├── Cinemas/
│   └── ...
│       ├── *.ecore         # Ecore model files
│       ├── DD.md           # Domain Description
│       ├── FR.md           # Functional Requirements
│       ├── DeM.md          # Design Model·
│       └── TS.md           # Test Specifications
├── raw_data/               # Experimental results
│   ├── RQ1/               # Baseline comparison experiments
│   └── RQ2/               # Ablation study results
├── sourceCode/
│   ├── baseline/          # Baseline implementations
│   └── iecoregen/         # iEcoreGen implementation
├──iecoregen jars 		   # 
└── README.md
```

# Benchmarks

The `benchmarks/` directory contains 20 real-world domain models for evaluation, including:
- Academic Program Management
- Airline Flight Systems
- Banking Systems
- Cinema Management
- Company Warehouses
- Employee Management Systems
- File Management
- Football Team Management
- And more...

Each benchmark provides comprehensive documentation:
- **Ecore Model**: Domain model definition (may include an EAnnotation with embedded functional requirements in a Details Entry)
- **DD.md**: Domain description and context
- **FR.md**: Functional requirements specification (can also be embedded in the Ecore model's EAnnotation)
- **DeM.md**: Design model
- **TS.md**: Test specifications

**Note**: The Ecore models can embed functional requirements directly using an EAnnotation (e.g., "EnhancedCodeGen") with a Details Entry. This allows the requirements to be stored within the model itself, making it self-contained and eliminating the need for separate FR.md files.

# Experimental Evaluation

## RQ1: Comparison with Baselines

We compare iEcoreGen against three baseline approaches:

- **Base-R**: LLM generates code from domain requirements only
- **Base-R+CD**: LLM generates code from domain requirements + functional descriptions + class diagrams
- **Base-R+CD+Fix**: Base-R+CD with error fixing capability (if generated code has errors, fix them)

**iEcoreGen**: Uses Ecore models with requirement decomposition and context-compressed fix (if generated code has errors, compress context to relevant classes and methods for fixing)

## RQ2: Ablation Study

Evaluates the contribution of individual components in iEcoreGen.

Experimental results are available in `raw_data/RQ1/` and `raw_data/RQ2/`.

# Workflow

iEcoreGen uses MWE2 to automate the entire workflow. Users need to create a MWE file to enable the generation. A simple MWE file looks like below.

```
module iecoregen.sample

import org.eclipse.xtext.xtext.generator.*
import org.eclipse.xtext.xtext.generator.model.project.*
import edu.ustb.sei.mde.mwe2.*

var rootPath = ".."

Workflow {
    component = EcoreGenerator {
        configuration = {
            project = StandardProjectConfig {
                baseName = "<project name>"
                rootPath = rootPath
                createEclipseMetaData = true
            }
            code = {
                encoding = "UTF-8"
                lineDelimiter = "\r\n"
                fileHeader = "/*\n * generated by Enhanced EcoreGen\n */"
                preferXtendStubs = false
            }
        }
        language = EcoreLanguage {
            ecoreFile = "<path to ecore model>"
            basePackage = "<a base package name, e.g., edu.ustb.sei.mde>"
            fileExtensions = "<EMF extension, usually the name of the EPackage>"
            suppressInterfaces = true
            llmConfig = '<your path>/conf.properties'
        }
        languageModule = 'edu.ustb.sei.mde.eecg.llm.languageModule.DefaultEnhancedEcoreGenModule'
    }
}
```

The workflow will read a properties file to load the parameters of LLMs. The properties file looks like below.

```properties
apikey=<your api key>
url=https://api.deepseek.com/
model=<your model name>
```
# Quick Start

## Prerequisites

Before using iEcoreGen, ensure you have the following environment configured:

1. **Eclipse IDE** with the following plugins:
   - Xtext
   - MWE2 (Modeling Workflow Engine 2)
   - EMF (Eclipse Modeling Framework)

2. **Required Dependencies**:
   - `edu.ustb.sei.ai`
   - `edu.ustb.sei.ai.spring.port`
   - `edu.ustb.sei.mde.eecg`
   - `edu.ustb.sei.mde.mwe2`
   - `edu.ustb.sei.mde.eecg.ui`

## Steps to Run

### 1. Create an Ecore Model

Create a new `.ecore` file that accurately reflects your system design. This model should define your domain entities, attributes, and relationships.

### 2. Execute

####  2.1  GUI Mode

Right-click on your `.ecore` file in the Project Explorer and select **"Init iEcoreGen"** → **"Workflow Initializer"** from the context menu.

![config_sample](image/mwe_config.png)

In the configuration wizard, fill in the following parameters:

- **Source Folder**: The folder where generated code will be placed (e.g., `src`)
- **MWE File Name**: Name for the workflow file (e.g., `GenerateModel.mwe2`)
- **Base Package**: Java package name for generated classes (e.g., `edu.example.model`)
- **Classpath Folder**: Eclipse plugins directory (auto-detected)
- **Overwrite**: Check this to overwrite existing files

Click **Finish** to generate the MWE2 workflow configuration file automatically.


![run_gui](image/run_gui.png)

After initialization, right-click on your `.ecore` file (or the generated `.mwe2` file) and select **"Init iEcoreGen"** → **"Workflow Runner"**.

![run_gui](image/run_window.png)

A progress dialog will appear showing the code generation process. Wait for the task to complete. The tool will:
- Generate Java model classes from your Ecore model
- Create implementation code using LLM-based code generation
- Perform automatic code fixing and validation


> **Tip**: You can refer to the example benchmarks in the `benchmarks/` folder to see sample Ecore models and their corresponding specifications.

#### 2.2 Maven Mode

If you prefer using Maven for build automation or running in CI/CD pipelines, you can use the Maven-based workflow.

**Prerequisites:**

- Apache Maven installed
- iEcoreGen jar package (in the folder "iecoregen jars")
- A `.mwe2` configuration file (You can refer to the OFDS project or the FileManager project in the maven-ecore-modeling-example folder.)

**Steps:**
1. Install iecoregen jar packages to your local Maven repository:
   ```bash
   # edu.ustb.sei.mde.mwe2
   mvn install:install-file -Dfile="path/to/edu.ustb.sei.mde.mwe2_1.0.0.202602050211.jar" -DgroupId="edu.ustb.sei.mde" -DartifactId="edu.ustb.sei.mde.mwe2" -Dversion="1.0.0.202602050211" -Dpackaging=jar
   
   # edu.ustb.sei.mde.eecg
   mvn install:install-file -Dfile="path/to/edu.ustb.sei.mde.eecg_1.0.0.202602050211.jar" -DgroupId="edu.ustb.sei.mde" -DartifactId="edu.ustb.sei.mde.eecg" -Dversion="1.0.0.202602050211" -Dpackaging=jar
   
   # edu.ustb.sei.ai
   mvn install:install-file -Dfile="path/to/edu.ustb.sei.ai_1.0.0.202602050211.jar" -DgroupId="edu.ustb.sei" -DartifactId="edu.ustb.sei.ai" -Dversion="1.0.0.202602050211" -Dpackaging=jar
   
   # edu.ustb.sei.ai.spring.port
   mvn install:install-file -Dfile="path/to/edu.ustb.sei.ai.spring.port_1.0.0.202602050211.jar" -DgroupId="edu.ustb.sei" -DartifactId="edu.ustb.sei.ai.spring.port" -Dversion="1.0.0.202602050211" -Dpackaging=jar
   
   # edu.ustb.sei.plantuml2model
   mvn install:install-file -Dfile="path/to/edu.ustb.sei.plantuml2model_1.0.0.202602050211.jar" -DgroupId="edu.ustb.sei" -DartifactId="edu.ustb.sei.plantuml2model" -Dversion="1.0.0.202602050211" -Dpackaging=jar

2. Configure your `pom.xml` with the required plugins and dependencies (see example snippet.For details, please refer to the pom.xml file in OFDS under the maven-ecore-modeling-example folder.)

   ```java
   <!-- Generates the Ecore model via MWE2 -->
         <plugin>
           <groupId>org.codehaus.mojo</groupId>
           <artifactId>exec-maven-plugin</artifactId>
           <version>3.6.3</version>
           <executions>
             <execution>
               <id>mwe2Launcher</id>
               <phase>generate-sources</phase>
               <goals>
                 <goal>java</goal>
               </goals>
             </execution>
           </executions>
           <configuration>
             <mainClass>org.eclipse.emf.mwe2.launch.runtime.Mwe2Launcher</mainClass>
             <arguments>
           <argument>file:///${project.basedir}/src/main/java/sample5.mwe2</argument>
               <argument>-p</argument>
               <argument>rootPath=${project.basedir}</argument>
             </arguments>
             <classpathScope>runtime</classpathScope>
             <includePluginDependencies>true</includePluginDependencies>
             <includeProjectDependencies>true</includeProjectDependencies>
             <cleanupDaemonThreads>false</cleanupDaemonThreads>
           </configuration>
           <dependencies>
             <dependency>
               <groupId>org.eclipse.text</groupId>
               <artifactId>org.eclipse.text</artifactId>
               <version>${eclipse-text-version}</version>
             </dependency>
             <dependency>
               <groupId>org.eclipse.core</groupId>
               <artifactId>org.eclipse.core.resources</artifactId>
               <version>${core-resources-version}</version>
               <exclusions>
                 <exclusion>
                   <groupId>org.eclipse.core</groupId>
                   <artifactId>org.eclipse.core.runtime</artifactId>
                 </exclusion>
               </exclusions>
             </dependency>
   
             <dependency>
               <groupId>org.eclipse.xtext</groupId>
               <artifactId>org.eclipse.xtext</artifactId>
               <version>${xtext-version}</version>
             </dependency>
             <dependency>
               <groupId>org.eclipse.xtext</groupId>
               <artifactId>org.eclipse.xtext.ecore</artifactId>
               <version>${xtext-version}</version>
             </dependency>
             <dependency>
               <groupId>org.eclipse.xtext</groupId>
               <artifactId>org.eclipse.xtext.common.types</artifactId>
               <version>${xtext-version}</version>
             </dependency>
             <dependency>
               <groupId>org.eclipse.xtext</groupId>
               <artifactId>org.eclipse.xtext.xtext.generator</artifactId>
               <version>${xtext-version}</version>
             </dependency>
   
             <dependency>
               <groupId>org.eclipse.emf</groupId>
               <artifactId>org.eclipse.emf.mwe2.launch</artifactId>
               <version>${emf-mwe2-version}</version>
             </dependency>
             <dependency>
               <groupId>org.eclipse.emf</groupId>
               <artifactId>org.eclipse.emf.mwe2.language</artifactId>
               <version>${emf-mwe2-version}</version>
             </dependency>
             <dependency>
               <groupId>org.eclipse.emf</groupId>
               <artifactId>org.eclipse.emf.mwe2.runtime</artifactId>
               <version>${emf-mwe2-version}</version>
             </dependency>
             <dependency>
               <groupId>org.eclipse.emf</groupId>
               <artifactId>org.eclipse.emf.mwe2.lib</artifactId>
               <version>${emf-mwe2-version}</version>
             </dependency>
   
             <dependency>
               <groupId>org.eclipse.emf</groupId>
               <artifactId>org.eclipse.emf.codegen.ecore.xtext</artifactId>
               <version>${ecore-xtext-version}</version>
             </dependency>
             <dependency>
               <groupId>org.eclipse.emf</groupId>
               <artifactId>org.eclipse.emf.common</artifactId>
               <version>${emf-common-version}</version>
             </dependency>
             <dependency>
               <groupId>org.eclipse.emf</groupId>
               <artifactId>org.eclipse.emf.ecore</artifactId>
               <version>${emf-version}</version>
             </dependency>
             <dependency>
               <groupId>org.eclipse.emf</groupId>
               <artifactId>org.eclipse.emf.ecore.xmi</artifactId>
               <version>${emf-version}</version>
             </dependency>
             <dependency>
               <groupId>org.eclipse.emf</groupId>
               <artifactId>org.eclipse.emf.codegen</artifactId>
               <version>${emf-codegen-version}</version>
             </dependency>
             <dependency>
               <groupId>org.eclipse.emf</groupId>
               <artifactId>org.eclipse.emf.codegen.ecore</artifactId>
               <version>${emf-codegen-version}</version>
             </dependency>
   
             <!-- iecoregen dependencies -->
             <dependency>
               <groupId>edu.ustb.sei.mde</groupId>
               <artifactId>edu.ustb.sei.mde.mwe2</artifactId>
               <version>1.0.0.202602050211</version>
             </dependency>
             <dependency>
               <groupId>edu.ustb.sei.mde</groupId>
               <artifactId>edu.ustb.sei.mde.eecg</artifactId>
               <version>1.0.0.202602050211</version>
             </dependency>
             <dependency>
               <groupId>edu.ustb.sei</groupId>
               <artifactId>edu.ustb.sei.ai</artifactId>
               <version>1.0.0.202602050211</version>
             </dependency>
             <dependency>
               <groupId>edu.ustb.sei</groupId>
               <artifactId>edu.ustb.sei.ai.spring.port</artifactId>
               <version>1.0.0.202602050211</version>
             </dependency>
           </dependencies>
         </plugin>
   ```

   

3. Place your `.ecore` model file in the appropriate directory

4. Attention: iEcoreGen requires compiling the generated Java code to capture errors for LLM-based fixing. To handle EMF dependencies without manual classpath configuration, we use `maven-dependency-plugin` to export dependencies to a file during build, which is read at runtime. For example, in the OFDS system, the `sample5.mwe2` file under `src` reads `classpath.txt` from the `target` folder.

   ![run_gui](image/classpathtxt.png)

5. Run `mvn clean package` to generate sources and build the project

> **Summary:** Maven Mode leverages the `exec-maven-plugin` to invoke the MWE2 workflow engine as part of the Maven build lifecycle, enabling automated code generation within CI/CD pipelines.

#### 2.3 Manual .mwe2 Mode

If you prefer more control over the workflow, you can manually create a `.mwe2` file and execute it directly.

**Steps:**
1. Create a `.mwe2` workflow file with your custom configuration
2. Configure the LLM parameters in the `conf.properties` file
3. Execute the workflow using the MWE2 runner

> For a complete `.mwe2` file example, please refer to the **Workflow** section above.